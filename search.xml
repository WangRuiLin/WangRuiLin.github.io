<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数组</title>
    <url>/2021/09/15/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>​    作为一个程序员，数据结构与算法是基础知识。就好比是武侠小说里的“内功心法”，只有掌握了内功心法，才能以不变应万变。接下来会跟着极客时间里王铮老师的专栏《数据结构与算法之美》，对这一块知识进行学习总结。</p>
<span id="more"></span>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p>
</blockquote>
<p>重点理解：</p>
<ol>
<li><p>线性表。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈等都是线性表结构。非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为数据之间并不是简单的前后关系。</p>
<p>这里我的理解是，数组和链表是两种最基础的数据结构。队列、栈等线性表结构和二叉树、堆等非线性表都可以通过数组和链表来实现。或者说数组和链表是数据在内存中的表示方式，要么是连续的(数组)，要么是非连续的(链表)。</p>
</li>
<li><p>连续的内存空间和相同类型的数据。优点：随机访问。缺点：插入删除数据时，为保证连续性，需要做数据搬移操作。</p>
</li>
</ol>
<h2 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h2><p>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，会通过寻址公式，来计算该元素存储的内存地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure>

<p>数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度O(1)；数组适合查找，查找的复杂度为O(1)”。这种表述不准确，数组是适合查找操作，但是查找的时间复杂度并不是O(1)。即使是排好序的数组，使用二分查找，时间复杂度为O(logn)。所以，正确的表述是数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。</p>
<p>关于这两种表述方式，我理解之间的差异是，一个通过下标查找<code>value</code>，通过寻址方式，时间复杂度是O(1)；另一种是在数组中查找<code>value</code>，排好序的数据，通过二分查找，时间复杂度为O(logn)。(直观理解为字典里根据<code>key</code>查找<code>value</code>和遍历字典查找<code>value</code>的区别，这种理解方式可能不太恰当)</p>
<h2 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h2><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>平均时间复杂度O(n)。计算方式：<code>(1+2+....+n)/n=O(n)</code></p>
<p>改进：将要插入指定位置的原元素放到最后，然后将新元素插入指定位置。时间复杂度O(1)</p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>平均时间复杂度O(n)</p>
<p>改进：先记录下已经删除的数据，当数组没有更多空间存储数据时，再触发执行一次真正的删除操作(JVM标记清除垃圾回收算法的核心思想)。时间复杂度视情况而定</p>
<h2 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h2><p>在C语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。</p>
<p>数组越界在C语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p>
<p>很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。但并非所有的语言都像C语言一样，把数组越界检测的工作丢给程序员来做，像Java本身就会做越界检查，会抛出越界异常。</p>
<p>文中的代码我在Mac终端通过<code>gcc</code>编译后执行，打印了四次<code>hello world</code>后异常退出，如图，</p>
<p><img src="index_out_of_bound.jpeg"></p>
<p>这个问题在文章后的评论里找到了答案：<code>gcc</code>有一个编译选项(<code>-fno-stack-protectot</code>)用于关闭堆栈保护功能。默认情况下启动了堆栈保护，不管<code>i</code>声明在前还是在后，<code>i</code>都会在数组之后压栈，只会循环四次；如果关闭堆栈保护功能，则会出现死循环。C语言代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">		arr[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器能否完全替代数组"><a href="#容器能否完全替代数组" class="headerlink" title="容器能否完全替代数组"></a>容器能否完全替代数组</h2><p>针对数组类型，很多语言都提供了容器类，比如<code>Java</code>中的<code>ArrayList</code>、<code>C++ STL</code>中的<code>vector</code>。我的理解，平时<code>Python</code>中经常使用的<code>list</code>、<code>dict</code>、<code>set</code>等提供操作<code>api</code>的类都称之为容器类。</p>
<p><code>ArrayList</code>最大的优势就是<strong>可以将很多数组操作的细节封装起来</strong>。比如数组插入、删除数据时需要搬移其他数据等。另外，还有一个优势，就是支持<strong>支持动态扩容</strong>。</p>
<p>需要注意的是，扩容操作涉及内存申请和数据搬移，是比较耗时的，所以，如果事先能确定需要存储的数据大小，最好在<strong>创建<code>ArrayList</code>的时候事先指定数据大小</strong></p>
<p>总结：</p>
<ol>
<li><code>Java ArrayList</code>无法存储基本数据类型，比如<code>int</code>、<code>long</code>，需要封装为<code>Integer</code>、<code>Long</code>类，而<code>Autoboxing(自动装箱)</code>、<code>Unboxing(自动拆箱)</code>则有一定的性能消耗，所以如果特别关注性能，或希望使用基本数据类型，就可以选用数组。</li>
<li>如果数据大小事先已知，并且对数据的操作非常简单，用不到<code>ArrayList</code>提供的大部分方法，也可以直接使用数组。</li>
<li>当表示多维数组时，用数组往往会更加直观。比如，<code>Object[][] array</code>；而用容器的话，<code>ArrayList&lt;ArrayList&lt;object&gt;&gt; array</code></li>
</ol>
<p>对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能，但是如果做一些特别底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器。</p>
<h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>为什么大多数编程语言中，数组要从0开始编号，而不是从1开始呢？</p>
<ol>
<li>通过寻址公式来看，从0开始编号，<code>a[k]_address = base_address + k * data_type_size</code>；从1开始编号，<code>a[k]_address = base_address + (k-1) * data_type_size</code>。不难发现，从1开始编号，每次随机访问数组元素都多了一次减法元素，对于CPU来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。</li>
<li>历史原因。C语言设计者用0开始计数数组下标，之后的Java、JavaScript等高级语言都效仿了C语言，或者说，为了在一定程度上减少C语言程序员学习Java的学习成本，因此继续沿用了从0开始计数的习惯。</li>
</ol>
<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><ol>
<li><p>JVM的标记清除垃圾回收算法的核心理念</p>
<p>大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有的<code>GC ROOTS</code>，将所有的<code>GC ROOTS</code>可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。</p>
<p>不足：1. 效率问题，标记和清理效率都不高，但是当知道只有少数垃圾产生时会很高效。2.空间问题，会产生不连续的内存空间碎片。</p>
<p>联想：Python中的垃圾回收机制：主要通过引用计数法进行垃圾回收，通过“标记-清除”解决容器对象可能产生的循环引用问题；通过“分代回收”以空间换时间的方法提高垃圾回收率</p>
</li>
<li><p>二维数组的内存寻址公式</p>
<p>对于<code>m*n</code>的数组，<code>a[i][j] (i&lt;m, j&lt;n)</code>的地址为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address = base_address + (i*n + j) * data_type_size</span><br></pre></td></tr></table></figure></li>
</ol>
<p>参考链接：</p>
<ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/83251959">Python垃圾回收机制！非常实用</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_42019874/article/details/111599687">二维数组和多维数组的本质及寻址方式</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
