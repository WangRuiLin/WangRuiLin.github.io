<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数组</title>
    <url>/2021/09/15/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>​    作为一个程序员，数据结构与算法是基础知识。就好比是武侠小说里的“内功心法”，只有掌握了内功心法，才能以不变应万变。接下来会跟着极客时间里王争老师的专栏《数据结构与算法之美》，对这一块知识进行学习总结。</p>
<span id="more"></span>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p>
</blockquote>
<p>重点理解：</p>
<ol>
<li><p>线性表。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈等都是线性表结构。非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为数据之间并不是简单的前后关系。</p>
<p>这里我的理解是，数组和链表是两种最基础的数据结构。队列、栈等线性表结构和二叉树、堆等非线性表都可以通过数组和链表来实现。或者说数组和链表是数据在内存中的表示方式，要么是连续的(数组)，要么是非连续的(链表)。</p>
</li>
<li><p>连续的内存空间和相同类型的数据。优点：随机访问。缺点：插入删除数据时，为保证连续性，需要做数据搬移操作。</p>
</li>
</ol>
<h2 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h2><p>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，会通过寻址公式，来计算该元素存储的内存地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure>

<p>数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度O(1)；数组适合查找，查找的复杂度为O(1)”。这种表述不准确，数组是适合查找操作，但是查找的时间复杂度并不是O(1)。即使是排好序的数组，使用二分查找，时间复杂度为O(logn)。所以，正确的表述是数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。</p>
<p>关于这两种表述方式，我理解之间的差异是，一个通过下标查找<code>value</code>，通过寻址方式，时间复杂度是O(1)；另一种是在数组中查找<code>value</code>，排好序的数据，通过二分查找，时间复杂度为O(logn)。(直观理解为字典里根据<code>key</code>查找<code>value</code>和遍历字典查找<code>value</code>的区别，这种理解方式可能不太恰当)</p>
<h2 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h2><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>平均时间复杂度O(n)。计算方式：<code>(1+2+....+n)/n=O(n)</code></p>
<p>改进：将要插入指定位置的原元素放到最后，然后将新元素插入指定位置。时间复杂度O(1)</p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>平均时间复杂度O(n)</p>
<p>改进：先记录下已经删除的数据，当数组没有更多空间存储数据时，再触发执行一次真正的删除操作(JVM标记清除垃圾回收算法的核心思想)。时间复杂度视情况而定</p>
<h2 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h2><p>在C语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。</p>
<p>数组越界在C语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p>
<p>很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。但并非所有的语言都像C语言一样，把数组越界检测的工作丢给程序员来做，像Java本身就会做越界检查，会抛出越界异常。</p>
<p>文中的代码我在Mac终端通过<code>gcc</code>编译后执行，打印了四次<code>hello world</code>后异常退出，如图，</p>
<p><img src="index_out_of_bound.jpeg"></p>
<p>这个问题在文章后的评论里找到了答案：<code>gcc</code>有一个编译选项(<code>-fno-stack-protectot</code>)用于关闭堆栈保护功能。默认情况下启动了堆栈保护，不管<code>i</code>声明在前还是在后，<code>i</code>都会在数组之后压栈，只会循环四次；如果关闭堆栈保护功能，则会出现死循环。C语言代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">		arr[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器能否完全替代数组"><a href="#容器能否完全替代数组" class="headerlink" title="容器能否完全替代数组"></a>容器能否完全替代数组</h2><p>针对数组类型，很多语言都提供了容器类，比如<code>Java</code>中的<code>ArrayList</code>、<code>C++ STL</code>中的<code>vector</code>。我的理解，平时<code>Python</code>中经常使用的<code>list</code>、<code>dict</code>、<code>set</code>等提供操作<code>api</code>的类都称之为容器类。</p>
<p><code>ArrayList</code>最大的优势就是<strong>可以将很多数组操作的细节封装起来</strong>。比如数组插入、删除数据时需要搬移其他数据等。另外，还有一个优势，就是支持<strong>支持动态扩容</strong>。</p>
<p>需要注意的是，扩容操作涉及内存申请和数据搬移，是比较耗时的，所以，如果事先能确定需要存储的数据大小，最好在<strong>创建<code>ArrayList</code>的时候事先指定数据大小</strong></p>
<p>总结：</p>
<ol>
<li><code>Java ArrayList</code>无法存储基本数据类型，比如<code>int</code>、<code>long</code>，需要封装为<code>Integer</code>、<code>Long</code>类，而<code>Autoboxing(自动装箱)</code>、<code>Unboxing(自动拆箱)</code>则有一定的性能消耗，所以如果特别关注性能，或希望使用基本数据类型，就可以选用数组。</li>
<li>如果数据大小事先已知，并且对数据的操作非常简单，用不到<code>ArrayList</code>提供的大部分方法，也可以直接使用数组。</li>
<li>当表示多维数组时，用数组往往会更加直观。比如，<code>Object[][] array</code>；而用容器的话，<code>ArrayList&lt;ArrayList&lt;object&gt;&gt; array</code></li>
</ol>
<p>对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能，但是如果做一些特别底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器。</p>
<h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>为什么大多数编程语言中，数组要从0开始编号，而不是从1开始呢？</p>
<ol>
<li>通过寻址公式来看，从0开始编号，<code>a[k]_address = base_address + k * data_type_size</code>；从1开始编号，<code>a[k]_address = base_address + (k-1) * data_type_size</code>。不难发现，从1开始编号，每次随机访问数组元素都多了一次减法元素，对于CPU来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。</li>
<li>历史原因。C语言设计者用0开始计数数组下标，之后的Java、JavaScript等高级语言都效仿了C语言，或者说，为了在一定程度上减少C语言程序员学习Java的学习成本，因此继续沿用了从0开始计数的习惯。</li>
</ol>
<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><ol>
<li><p>JVM的标记清除垃圾回收算法的核心理念</p>
<p>大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有的<code>GC ROOTS</code>，将所有的<code>GC ROOTS</code>可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。</p>
<p>不足：1. 效率问题，标记和清理效率都不高，但是当知道只有少数垃圾产生时会很高效。2.空间问题，会产生不连续的内存空间碎片。</p>
<p>联想：Python中的垃圾回收机制：主要通过引用计数法进行垃圾回收，通过“标记-清除”解决容器对象可能产生的循环引用问题；通过“分代回收”以空间换时间的方法提高垃圾回收率</p>
</li>
<li><p>二维数组的内存寻址公式</p>
<p>对于<code>m*n</code>的数组，<code>a[i][j] (i&lt;m, j&lt;n)</code>的地址为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address = base_address + (i*n + j) * data_type_size</span><br></pre></td></tr></table></figure></li>
</ol>
<p>参考链接：</p>
<ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/83251959">Python垃圾回收机制！非常实用</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_42019874/article/details/111599687">二维数组和多维数组的本质及寻址方式</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>链表(上)</title>
    <url>/2021/09/16/%E9%93%BE%E8%A1%A8-%E4%B8%8A/</url>
    <content><![CDATA[<p>今天来学习链表(上)。</p>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。</p>
<p>缓存大小有限，当缓存被用满时，就涉及到了缓存淘汰策略。</p>
<ol>
<li>先进先出策略<code>FIFO</code>(First In, First Out)</li>
<li>最少使用策略<code>LFU</code>(Least Frequently Used)</li>
<li>最近最少使用策略<code>LRU</code>(Least Recently Used)</li>
</ol>
<p>经典的链表应用场景，<code>LRU</code>缓存淘汰算法。</p>
<h2 id="五花八门的链表结构"><a href="#五花八门的链表结构" class="headerlink" title="五花八门的链表结构"></a>五花八门的链表结构</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>首先需要搞清几个概念</p>
<ul>
<li>链表结点：存储数据和后继指针的内存块</li>
<li>后继指针：记录下个结点地址的指针</li>
<li>头结点：第一个结点</li>
<li>尾结点：最后一个结点，<strong>指向一个空地址NULL</strong></li>
</ul>
<p>插入删除操作时间复杂度O(1)，随机访问时间复杂度O(n)</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><strong>循环链表是一种特殊的单链表</strong>，它跟单链表唯一的区别就在尾结点。单链表的尾结点指针指向空地址。而循环链表的尾结点指针是指向链表的头结点。</p>
<p>和单链表相比，<strong>循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环形结构特点时，就特别适合采用循环链表，比如著名的约瑟夫问题。</strong>尽管用单链表也可以实现，但使用循环链表实现的话，代码会简洁很多。</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>在实际的软件开发，双向链表更加常用。</p>
<p>单链表只有一个方向，结点只有一个后继指针，<code>next</code>指向后面的结点。而双向链表，它支持两个方向，每个结点不止有一个后继指针<code>next</code>指向后面的结点，还有一个前驱指针<code>prev</code>指向前面的结点。</p>
<p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样带来了双向链表操作的灵活性。</p>
<h4 id="单链表-vs-双向链表"><a href="#单链表-vs-双向链表" class="headerlink" title="单链表 vs 双向链表"></a>单链表 vs 双向链表</h4><p>在实际的软件开发中，从链表删除一个数据无外乎这两种情况：</p>
<ul>
<li>删除结点中“值等于某个给定值”的结点</li>
<li>删除给定指针指向的结点</li>
</ul>
<p>对于第一种情况，无论是单链表和双向链表，都需要遍历查找。所以删除操作的时间复杂度是O(1)，遍历查找的时间复杂度是O(n)，根据加法法则，总的时间复杂度O(n)。</p>
<p>对于第二种情况，由于删除某个结点<code>q</code>需要知道其前驱结点，而单链表并不支持直接获取前驱结点，时间复杂度O(n)；而双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历，时间复杂度O(1)</p>
<p>同理在链表的某个结点前面或者后面插入一个结点，双向链表时间复杂度O(1)；单链表时间复杂度O(n)</p>
<p>除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为双向链表可以记录上次查找的位置<code>p</code>，每次查询时，根据要查询值和位置p的值的大小关系，决定往前查找还是往后查找，所以平均只需要查找一半的数据。</p>
<p><code>Java</code>语言中的<code>LinkedHashMap</code>就用到了双向链表，尽管比较费内存，但是应用比较广泛。</p>
<p>这里面，涉及到一个重要的涉及思想：<strong>空间换时间</strong>。对于执行比较慢的程序，可以通过消耗更多的内存(空间换时间)，来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间(时间换空间)来降低内存的消耗。</p>
<h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p>概念容易理解，但是代码写起来更复杂了….</p>
<h3 id="数组-vs-链表"><a href="#数组-vs-链表" class="headerlink" title="数组 vs 链表"></a>数组 vs 链表</h3><p>底层结构上：数组连续的内存空间；链表零散的内存块</p>
<p>时间复杂度：</p>
<table>
<thead>
<tr>
<th>时间复杂度</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td>插入、删除</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>随机访问</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<p>在实际开发中，不能简单的根据时间复杂度来决定使用哪个数据结构来存储数据。</p>
<p>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。</p>
<p>数组的缺点是大小固定，一经声明就要占用整块连续内存。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足”。如果声明的数组过小，则可能出现不够用的情况。这是只能再申请一个更大的内存空间，把原数组拷贝过去，非常耗时。链表本身没有大小的限制，天然地支持动态扩容。这是数组和链表最大的区别</p>
<p>除此之外，如果对内存的使用非常苛刻，那么数组更适合。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片。</p>
<h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>如何基于链表实现LRU缓存淘汰算法？</p>
<p>思路：维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历单链表。</p>
<ol>
<li>如果此数据之前已经被缓存在链表中，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li>
<li>如果此数据没有在缓存链表中，又可以分为两种情况：<ul>
<li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li>
<li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li>
</ul>
</li>
</ol>
<p>时间复杂度O(n)</p>
<p>思考：如何利用数组来实现LRU缓存淘汰策略？</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>如何判断一个字符串是否是回文字符串的问题？</p>
<p>这个问题考查了两个知识点：</p>
<ol>
<li>快慢指针</li>
<li>反转相邻结点</li>
</ol>
<p>花了一个下午写了关于链表的一些基本操作—。—，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  	单链表-结点</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data, next_node=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = next_node</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  	单链表</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__head = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_by_value</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            根据value在链表中查找</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.__head</span><br><span class="line">        <span class="keyword">while</span> (node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (node.data != value):</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_by_index</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            根据index在链表中查找</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.__head</span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (pos != index):</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_to_head</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            头结点插入</span></span><br><span class="line"><span class="string">            时间复杂度O(1)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.<span class="built_in">next</span> = self.__head</span><br><span class="line">        self.__head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_after</span>(<span class="params">self, node, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            在链表的某个指定Node节点之后插入一个存储value数据的Node节点</span></span><br><span class="line"><span class="string">            时间复杂度O(1)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 如果在空结点之后插入数据结点 则什么都不做</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        new_node = Node(value)</span><br><span class="line"></span><br><span class="line">        new_node.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span> = new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_before</span>(<span class="params">self, node, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            在链表的某个指定Node节点之前插入一个存储value数据的Node节点</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 如果在空结点之前或者空链表之前插入结点 则什么都不做</span></span><br><span class="line">        <span class="keyword">if</span> (node <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (self.__head <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 头结点插入</span></span><br><span class="line">        <span class="keyword">if</span> node == self.__head:</span><br><span class="line">            self.insert_to_head(value)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        new_node = Node(value)</span><br><span class="line">        pos = self.__head</span><br><span class="line">        <span class="comment"># 注意：判断node是否存在链表中</span></span><br><span class="line">        not_found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> pos.<span class="built_in">next</span> != node:</span><br><span class="line">            <span class="keyword">if</span> pos.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                not_found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            pos = pos.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> not_found:</span><br><span class="line">            pos.<span class="built_in">next</span> = new_node</span><br><span class="line">            new_node.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_by_node</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            在链表中删除指定Node的节点</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 空链表 什么都不做</span></span><br><span class="line">        <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 删除头结点 头结点后移</span></span><br><span class="line">        <span class="keyword">if</span> node == self.__head:</span><br><span class="line">            self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        pos = self.__head</span><br><span class="line">        not_found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> pos.<span class="built_in">next</span> != node:</span><br><span class="line">            <span class="keyword">if</span> pos.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                not_found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            pos = pos.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> not_found:</span><br><span class="line">            pos.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_by_value</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            在链表中删除指定存储数据的Node节点</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.__head.data == value:</span><br><span class="line">            self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里用到了pre结点 因为删除指定value结点时候需要用到前一个结点</span></span><br><span class="line">        pre = self.__head</span><br><span class="line">        node = self.__head.<span class="built_in">next</span></span><br><span class="line">        not_found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> node.data != value:</span><br><span class="line">            <span class="keyword">if</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                not_found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            pre = node</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> not_found:</span><br><span class="line">            pre.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_last_n_node</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            删除链表中倒数第N个节点</span></span><br><span class="line"><span class="string">            主要思路：</span></span><br><span class="line"><span class="string">                设置快、慢两个指针，快指针先行，慢指针不动；当快指针走了N步时，快慢指针同时向链表尾部移动，</span></span><br><span class="line"><span class="string">                当快指针到达链表尾部时，慢指针指向的就是链表倒数第N个结点(脑子绕不过弯来时，画画图就明白了)</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            ** 单链表删除结点的时候，一定要注意保存被删除结点的前驱结点</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast = self.__head</span><br><span class="line">        slow = self.__head</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> step &lt;= n:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        tmp = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            tmp = slow</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        tmp.<span class="built_in">next</span> = slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_mid_node</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            查找链表中的中间节点</span></span><br><span class="line"><span class="string">            主要思想：</span></span><br><span class="line"><span class="string">                设置快慢指针，快指针每次跨两步，满指针每次跨一步，则当快指针到达链表尾部的时候，慢指针指向链表的中间结点</span></span><br><span class="line"><span class="string">                同理 脑子绕不过弯时，画画图就明白了</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast = self.__head</span><br><span class="line">        slow = self.__head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单链表个数局限为奇数</span></span><br><span class="line">        <span class="comment"># while (fast.next is not None):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单链表个数为奇数或者偶数可以</span></span><br><span class="line">        <span class="keyword">while</span> (fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_node</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            创建一个存储value值的Node节点</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> Node(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_all</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            打印当前链表所有节点数据</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        node = self.__head</span><br><span class="line">        <span class="keyword">while</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(node.data, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 打印最后一个结点</span></span><br><span class="line">        <span class="built_in">print</span>(node.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversed_self</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            翻转链表</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pre = self.__head</span><br><span class="line">        node = self.__head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 结束条件 pre为链表最后一个结点 node为None</span></span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            pre, node = self.__reversed_with_two_node(pre, node)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 修改尾结点和头结点</span></span><br><span class="line">        self.__head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.__head = pre</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed_with_two_node</span>(<span class="params">self, pre, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            翻转相邻两个结点</span></span><br><span class="line"><span class="string">            思路：利用一个中间结点tmp</span></span><br><span class="line"><span class="string">        :return: node, node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 保存node的下一个结点</span></span><br><span class="line">        tmp = node.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 修改node指针</span></span><br><span class="line">        node.<span class="built_in">next</span> = pre</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这两行的意思应该是后移结点</span></span><br><span class="line">        pre = node</span><br><span class="line">        node = tmp</span><br><span class="line">        <span class="keyword">return</span> pre, node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_ring</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            检测是否有环</span></span><br><span class="line"><span class="string">            主要思想：</span></span><br><span class="line"><span class="string">                设置快、慢两个指针，快指针每次跨两步、慢指针每次跨一步，</span></span><br><span class="line"><span class="string">                如果快指针没有与慢指针相遇而是顺利到达链表尾部，说明没有环，反之存在环</span></span><br><span class="line"><span class="string">                自己画画图看看 就明白了</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: True or False</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast = self.__head</span><br><span class="line">        slow = self.__head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当链表为空或者只有一个结点时，直接返回False</span></span><br><span class="line">        <span class="keyword">while</span> (fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_head</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            根据给的结点，翻转之后的结点</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        reverse_head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            next_node = head.<span class="built_in">next</span></span><br><span class="line">            head.<span class="built_in">next</span> = reverse_head</span><br><span class="line">            reverse_head = head</span><br><span class="line">            head = next_node</span><br><span class="line">        <span class="keyword">return</span> reverse_head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            判断是否是回文串</span></span><br><span class="line"><span class="string">            主要思路：快、慢两个指针，快指针每次前进两步、慢指针每次前进一步。当快指针到达链表尾部时，慢指针到达链表中间节点，翻转慢指针到链表尾部的这部分结										点，然后依次对比链表头部和翻转后的部分链表数据是否相同</span></span><br><span class="line"><span class="string">        :return: True or False</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow = self.__head</span><br><span class="line">        fast = self.__head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        head_a = self.__head</span><br><span class="line">        head_b = self.reverse_head(slow)</span><br><span class="line"></span><br><span class="line">        is_palin = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> head_a <span class="keyword">and</span> head_b:</span><br><span class="line">            <span class="keyword">if</span> head_a.data == head_b.data:</span><br><span class="line">                head_a = head_a.<span class="built_in">next</span></span><br><span class="line">                head_b = head_b.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                is_palin = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> is_palin</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写链表代码时有几点感受：</p>
<ol>
<li>在删除链表结点的时候一定要注意利用中间变量保存前驱结点</li>
<li>快慢指针法在链表中有着广泛的应用，比如说查找中间结点、检测链表是否包含环、判断是否为回文串、删除链表倒数第N个结点等等。</li>
<li>多写多练</li>
</ol>
<p>参考链接：</p>
<ol>
<li><a href="https://github.com/wangzheng0822/algo">数据结构与算法之美相关代码</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表(下)</title>
    <url>/2021/09/17/%E9%93%BE%E8%A1%A8-%E4%B8%8B/</url>
    <content><![CDATA[<p>链表这块知识理解起来简单，代码实现起来，容易出错，谁写谁知道，所以就有了链表(下)。</p>
<span id="more"></span>

<h2 id="写链表代码的技巧"><a href="#写链表代码的技巧" class="headerlink" title="写链表代码的技巧"></a>写链表代码的技巧</h2><h3 id="理解指针或引用的含义"><a href="#理解指针或引用的含义" class="headerlink" title="理解指针或引用的含义"></a>理解指针或引用的含义</h3><p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针里存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p>
<p>指针，英文定义，<code>A pointer is a variable whose value is the address of another variable.</code></p>
<h3 id="警惕指针丢失和内存泄漏"><a href="#警惕指针丢失和内存泄漏" class="headerlink" title="警惕指针丢失和内存泄漏"></a>警惕指针丢失和内存泄漏</h3><p>比如，在<code>a</code>、<code>b</code>两个结点之间插入一个结点<code>c</code>，一定是先执行<code>c-&gt;next=a-&gt;next</code>，先把结点<code>c</code>指向结点<code>b</code>，然后再将结点<code>a</code>指向结点<code>c</code>，即<code>a-&gt;next=c</code>。如果顺序颠倒了，就会造成结点<code>b</code>的丢失，链表分成了两半，进而造成内存泄漏。因此，<strong>在插入结点时，一定要注意操作的顺序</strong>。</p>
<p><strong>删除链表结点时，也一定要记得手动释放内存空间</strong>，否则也会出现内存泄漏的情况。当然，对于像<code>Java</code>这种虚拟机自动管理内存的编程语言来说，就不需要考虑那么多了。</p>
<h3 id="利用哨兵简化实现难度"><a href="#利用哨兵简化实现难度" class="headerlink" title="利用哨兵简化实现难度"></a>利用哨兵简化实现难度</h3><p>非哨兵模式下链表的插入，比如在<code>p</code>结点后插入一个新结点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常情况</span></span><br><span class="line">new_node.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">p.<span class="built_in">next</span> = new_node</span><br><span class="line"><span class="comment"># 边界情况，比如向空链表中插入第一个结点</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">None</span>)&#123;head = new_node&#125;</span><br></pre></td></tr></table></figure>

<p>非哨兵模式下链表的删除，比如删除结点<code>p</code>的后继结点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常情况</span></span><br><span class="line">p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"><span class="comment"># 边界情况，比如删除最后一个结点</span></span><br><span class="line">p.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p><strong>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。</strong></p>
<p>为了解决边界问题，引入哨兵结点。</p>
<p>哨兵结点，结点本身不存储数据，指定链表头结点，称为新的头结点，如图所示，</p>
<p><img src="sentinel.webp"></p>
<p>带有哨兵结点的链表叫<strong>带头链表</strong>；没有哨兵结点的链表叫做<strong>不带头链表</strong>。</p>
<p>因为哨兵结点一直存在，所以插入第一个节点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑。</p>
<p>不信的话，自己画画图，理解一下代码，发现确实是真的耶</p>
<h3 id="重点留意边界条件处理"><a href="#重点留意边界条件处理" class="headerlink" title="重点留意边界条件处理"></a>重点留意边界条件处理</h3><p>检查链表代码是否正确的边界条件有这样几个：</p>
<ul>
<li>如果链表为空时，代码是否能正常工作</li>
<li>如果链表只包含一个结点时，代码是否能正常工作</li>
<li>如果链表只包含两个结点时，代码是否能正常工作</li>
<li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作</li>
</ul>
<h3 id="举例画图，辅助思考"><a href="#举例画图，辅助思考" class="headerlink" title="举例画图，辅助思考"></a>举例画图，辅助思考</h3><p>举例法和画图法</p>
<h3 id="多写多练，没有捷径"><a href="#多写多练，没有捷径" class="headerlink" title="多写多练，没有捷径"></a>多写多练，没有捷径</h3><p>5个常见的链表操作</p>
<ul>
<li>单链表反转</li>
<li>链表中环的检测</li>
<li>两个有序的链表合并</li>
<li>删除链表倒数第n个结点</li>
<li>求链表的中间结点</li>
</ul>
<p>其实除了两个有序的链表合并，其余的在链表上(上)都写过了，总结起来就是1.快慢指针2.反转相邻的结点。上节课后思考判断回文串这一道题目就把这两个知识点都考查到了，简直是妙啊！</p>
<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>哨兵模式在其他场景上的应用。</p>
<p>暂时没想到，后续用到了再来补充吧=.=</p>
<h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><h3 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sorted_list</span>(<span class="params">l1: Node, l2: Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        合并两个有序链表</span></span><br><span class="line"><span class="string">        时间复杂度O(m)+O(n)</span></span><br><span class="line"><span class="string">    :param l1: 链表1头结点</span></span><br><span class="line"><span class="string">    :param l2: 链表2头结点</span></span><br><span class="line"><span class="string">    :return: 合并后链表的头结点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    node = Node(data=-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 需要一个变量保存头结点</span></span><br><span class="line">    head = node</span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.data &lt;= l2.data:</span><br><span class="line">            node.<span class="built_in">next</span> = l1</span><br><span class="line">            <span class="comment"># 后移链表1结点</span></span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = l2</span><br><span class="line">            <span class="comment"># 后移链表2结点</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        node = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并 未合并完的链表</span></span><br><span class="line">    node.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">    <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = SingleLinkedList()</span><br><span class="line"></span><br><span class="line">    s.insert_to_head(<span class="number">5</span>)</span><br><span class="line">    s.insert_to_head(<span class="number">3</span>)</span><br><span class="line">    s.insert_to_head(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    p = SingleLinkedList()</span><br><span class="line">    p.insert_to_head(<span class="number">6</span>)</span><br><span class="line">    p.insert_to_head(<span class="number">5</span>)</span><br><span class="line">    p.insert_to_head(<span class="number">4</span>)</span><br><span class="line">    p.insert_to_head(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    q = merge_sorted_list(s.get_head_node(), p.get_head_node())</span><br></pre></td></tr></table></figure>

<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>代码先放到这，等学完递归在回过头来看。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sorted_list2</span>(<span class="params">l1: Node, l2: Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        合并两个有序链表</span></span><br><span class="line"><span class="string">        主要思路：</span></span><br><span class="line"><span class="string">        	list1[0] + merge(list1[1], list2[0]) 当list1[0]&lt;list2[0]</span></span><br><span class="line"><span class="string">          list2[0] + merge(list1[0], list2[1]) otherwise</span></span><br><span class="line"><span class="string">    :param l1: 链表1头结点</span></span><br><span class="line"><span class="string">    :param l2: 链表2头结点</span></span><br><span class="line"><span class="string">    :return: 合并后链表的头结点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l2:</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1.data &lt;= l2.data:</span><br><span class="line">        l1.<span class="built_in">next</span> = merge_sorted_list(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l2.<span class="built_in">next</span> = merge_sorted_list(l1, l2.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>

<h2 id="LRU缓存算法"><a href="#LRU缓存算法" class="headerlink" title="LRU缓存算法"></a>LRU缓存算法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.key = x</span><br><span class="line">        self.value = y</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cap = capacity</span><br><span class="line">        <span class="comment"># 存储key和node</span></span><br><span class="line">        self.hkeys = &#123;&#125;</span><br><span class="line">        <span class="comment"># 哨兵结点 避免考虑边界问题</span></span><br><span class="line">        self.top = Node(<span class="literal">None</span>, -<span class="number">1</span>)</span><br><span class="line">        self.tail = Node(<span class="literal">None</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.top.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.top</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hkeys.keys():</span><br><span class="line">            <span class="comment"># 1.获取结点</span></span><br><span class="line">            cur = self.hkeys[key]</span><br><span class="line">            <span class="comment"># 2.从当前位置拿出</span></span><br><span class="line">            cur.prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span>.prev = cur.prev</span><br><span class="line">            <span class="comment"># 3.放到链表头部</span></span><br><span class="line">            <span class="comment"># 3.1 保存top后面的结点</span></span><br><span class="line">            tmp = self.top.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 3.2 top和cur绑定</span></span><br><span class="line">            self.top.<span class="built_in">next</span> = cur</span><br><span class="line">            cur.prev = self.top</span><br><span class="line">            <span class="comment"># 3.3 cur和tmp绑定</span></span><br><span class="line">            cur.<span class="built_in">next</span> = tmp</span><br><span class="line">            tmp.prev = cur</span><br><span class="line">            <span class="keyword">return</span> self.hkeys[key].value</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hkeys.keys():</span><br><span class="line">            <span class="comment"># 1.获取结点</span></span><br><span class="line">            cur = self.hkeys[key]</span><br><span class="line">            <span class="comment"># 修改value值</span></span><br><span class="line">            cur.value = value</span><br><span class="line">            <span class="comment"># 2.跳出原位置</span></span><br><span class="line">            cur.prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span>.prev = cur.prev</span><br><span class="line">            <span class="comment"># 3.将cur放到头结点</span></span><br><span class="line">            top_node = self.top.<span class="built_in">next</span></span><br><span class="line">            self.top.<span class="built_in">next</span> = cur</span><br><span class="line">            cur.prev = self.top</span><br><span class="line">            cur.<span class="built_in">next</span> = top_node</span><br><span class="line">            top_node.prev = cur</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.hkeys.keys()) &gt; self.cap:</span><br><span class="line">                <span class="comment"># 从哈希表删除key</span></span><br><span class="line">                self.hkeys.pop(self.tail.prev.key)</span><br><span class="line">                <span class="comment"># 去掉了后继指针</span></span><br><span class="line">                self.tail.prev.prev.<span class="built_in">next</span> = self.tail</span><br><span class="line">                <span class="comment"># 修改尾结点前驱指针，self.tail.prev.prev有点懵的</span></span><br><span class="line">                self.tail.prev = self.tail.prev.prev</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 新增结点</span></span><br><span class="line">            cur = Node(key, value)</span><br><span class="line">            self.hkeys[key] = cur</span><br><span class="line">            <span class="comment"># 最近用过的放到链表头部</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                我第一次写的</span></span><br><span class="line"><span class="string">                cur.next = self.top.next</span></span><br><span class="line"><span class="string">                self.top.prev = cur</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">                self.top.next = cur</span></span><br><span class="line"><span class="string">                cur.prev = self.top</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># 利用tmp保留top下一个结点</span></span><br><span class="line">            tmp = self.top.<span class="built_in">next</span>  </span><br><span class="line">            cur.<span class="built_in">next</span> = tmp</span><br><span class="line">            tmp.prev = cur</span><br><span class="line"></span><br><span class="line">            self.top.<span class="built_in">next</span> = cur</span><br><span class="line">            cur.prev = self.top</span><br></pre></td></tr></table></figure>

<h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><ol>
<li><p>写起来好像也没想象中那么难，可能是因为用到哨兵结点，不需要考虑边界问题。</p>
</li>
<li><p>主要操作包括：结点从当前位置取出、头部插入结点。</p>
</li>
<li><p>操作之间不需要考虑先后顺序，比如结点跳出原位置，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 结点跳出原位置</span></span><br><span class="line">cur.<span class="built_in">next</span>.prev = cur.prev</span><br><span class="line">cur.prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链表头部插入结点</span></span><br><span class="line">tmp = self.top.<span class="built_in">next</span></span><br><span class="line">cur.<span class="built_in">next</span> = tmp</span><br><span class="line">tmp.prev = cur</span><br><span class="line"></span><br><span class="line">self.top.<span class="built_in">next</span> = cur</span><br><span class="line">cur.prev = self.top</span><br></pre></td></tr></table></figure>

<p>于是，为了验证这个观点，写一个简单的双向链表<code>demo</code>验证一下，无论怎么更换<code>insert_node_from_head</code>方法中后四行代码的顺序，结果都是一样的。如果有不对的地方，欢迎指教哈=。=</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoWayLoop</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = Node(value=-<span class="number">1</span>)</span><br><span class="line">        self.tail = Node(value=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.top.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.top</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_node_from_head</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value=value)</span><br><span class="line"></span><br><span class="line">        tmp = self.top.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        tmp.prev = node</span><br><span class="line">        node.prev = self.top</span><br><span class="line">        self.top.<span class="built_in">next</span> = node</span><br><span class="line">        node.<span class="built_in">next</span> = tmp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_node</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            暂时没想好怎么写</span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.top.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_all</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node.<span class="built_in">next</span>:</span><br><span class="line">            <span class="built_in">print</span>(node.value)</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = TwoWayLoop()</span><br><span class="line"></span><br><span class="line">    t.insert_node_from_head(<span class="number">4</span>)</span><br><span class="line">    t.insert_node_from_head(<span class="number">3</span>)</span><br><span class="line">    t.insert_node_from_head(<span class="number">2</span>)</span><br><span class="line">    t.insert_node_from_head(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    t.print_all()  <span class="comment"># 1-&gt;2-&gt;3-&gt;4</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="附：获取类对象的私有属性"><a href="#附：获取类对象的私有属性" class="headerlink" title="附：获取类对象的私有属性"></a>附：获取类对象的私有属性</h2><p>在合并两个有序链表中，需要获取链表的头结点。上篇文章代码中，单链表的<code>SingleLinkedList</code>中的头结点初始化时定义为私有属性<code>self.__head=None</code>，如果直接通过实例对象获取<code>__head</code>会抛出<code>AttributeError</code>异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__head = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  s = SingleLinkedList()</span><br><span class="line">  s.insert_to_head(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(s.__head)  <span class="comment"># AttributeError: &#x27;SingleLinkedList&#x27; object has no attribute &#x27;__head&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="正确的打开方式"><a href="#正确的打开方式" class="headerlink" title="正确的打开方式"></a>正确的打开方式</h3><ol>
<li>通过定义一个方法获取私有属性</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__head = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_head_node</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.__head</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  s = SingleLinkedList()</span><br><span class="line">  s.insert_to_head(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(s.get_head_node().data)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过<code>property</code>将方法转化为属性</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__head = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_head_node</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.__head</span><br><span class="line"></span><br><span class="line">  head = <span class="built_in">property</span>(get_head_node)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  s = SingleLinkedList()</span><br><span class="line">  s.insert_to_head(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(s.head.data)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过<code>property</code>装饰器</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__head = <span class="literal">None</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span>(<span class="params">self</span>):</span></span><br><span class="line">  	<span class="keyword">return</span> self.__head</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  s = SingleLinkedList()</span><br><span class="line">  s.insert_to_head(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(s.head.data)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/53469919">python变量——单下划线和双下划线</a></li>
<li><a href="https://www.runoob.com/python/python-func-property.html">Python property() 函数</a></li>
<li><a href="https://blog.csdn.net/z_feng12489/article/details/106105227">合并两个有序链表（python）</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
