<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二分查找(上)</title>
    <url>/2021/10/20/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E4%B8%8A)/</url>
    <content><![CDATA[<p>今天学习二分查找。</p>
<span id="more"></span>
<h2 id="定义">定义</h2>
<p>二分查找针对的是一个<strong>有序的数据集合</strong>，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。</p>
<h2 id="时间复杂度">时间复杂度</h2>
<p>假设数据大小是<code>n</code>，每次查找后数据都会缩小为原来的一半，也就是会除以2。最坏情况下，直到查找区间被缩小为空，才停止。被查找区间的大小变化：</p>
<p><span class="math display">\[
n, \frac{n}{2}, \frac{n}{4}, \frac{n}{8},...\frac{n}{2^k}...
\]</span> 其中， <span class="math display">\[
当\frac{n}{2^k}=1时，
\]</span> <code>k</code>的值就是缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了<code>k</code>次区间缩小操作，时间复杂度就是<code>O(k)</code>。通过<code>n/(2^k)=1</code>，得到<code>k=logn</code>，所以时间复杂度就是<code>O(logn)</code>。</p>
<p>常量级时间复杂度的算法有时候可能还没有<code>O(logn)</code>的算法执行效率高。比如，<code>O(1)</code>有可能表示的是一个非常大的常量值，比如<code>O(1000)</code>，<code>O(10000)</code>。而<code>logn</code>即使<code>n</code>非常非常大，对应的<code>logn</code>也很小。比如，<code>n</code>等于2的32次方，大约是42亿，也就是说，如果在42亿个数据中用二分查找一个数据，最多需要比较32次。</p>
<h2 id="实现">实现</h2>
<h3 id="非递归">非递归</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        <span class="comment"># mid = low + ((high - low) &gt;&gt; 1)</span></span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt;= target:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    <span class="built_in">print</span>(binary_search(nums=a, target=<span class="number">2</span>))  <span class="comment"># 1</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search(nums=a, target=<span class="number">3</span>))  <span class="comment"># 2</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search(nums=a, target=<span class="number">11</span>))  <span class="comment"># -1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="递归">递归</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search_by_recursion</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line"></span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> binary_search(nums[mid+<span class="number">1</span>:], target)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> binary_search(nums[:mid-<span class="number">1</span>], target)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line">    <span class="built_in">print</span>(binary_search_by_recursion(nums=a, target=<span class="number">2</span>))  <span class="comment"># 1</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search_by_recursion(nums=a, target=<span class="number">3</span>))  <span class="comment"># 3</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search_by_recursion(nums=a, target=<span class="number">10</span>))  <span class="comment"># -1</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="易错点">易错点</h3>
<ol type="1">
<li><p>循环退出条件</p>
<p>注意是<code>low&lt;=high</code>，而不是<code>low&lt;high</code>。当<code>low=high</code>时，如果此时刚好<code>a[low]=a[high]=target</code>，加上终止条件<code>low&lt;high</code>退出循环，导致查找失败。</p></li>
<li><p><code>mid</code>的取值</p>
<p>实际上，<code>mid=(low+high)//2</code>这种写法是有问题的。因为如果<code>low</code>和<code>high</code>比较大的话，两者之和就有可能溢出。改进的方法是将<code>mid</code>的计算方式写成<code>low+(high-low)//2</code>。更进一步，如果要将性能优化到极致的话，可以将除以2操作转化成位运算<code>low+(high-low)&gt;&gt;1</code>。因为相比除法运算来说，计算机处理位运算要快得多。</p>
<p>为什么右移一位相当于除以2，左移一位相当于乘以2？以十进制数。如136，左移一位后，空出的位置用0填补，左移一位相当于把小数点右移一位，就变成了1360，相当于<code>136*10</code>；同理，136右移一位后，移出的位舍去，就变成了13，相当于136/10。因此，十进制左移一位相当于乘以10，右移一位相当于除以10。对于二进制的移位操作同样适用。</p></li>
<li><p><code>low</code>和<code>high</code>的更新</p>
<p><code>low=mid+1</code>，<code>high=mid-1</code>。注意这里的<code>+1</code>和<code>-1</code>，如果直接写成<code>low=mid</code>或者<code>high=mid</code>，就可能会发生死循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            low = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    <span class="built_in">print</span>(binary_search(nums=a, target=<span class="number">3</span>))  <span class="comment"># 出现死循环</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="局限性">局限性</h2>
<ol type="1">
<li><p>二分查找依赖的是顺序表结构，简单点说就是数组。主要原因是二分查找算法需要按照下标随机访问元素。二分查找只能用在数据是通过顺序表来存储的数据结构上。</p></li>
<li><p>二分查找针对的是有序数据。二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景。针对动态变化的数据集合，二分查找将不再使用。</p></li>
<li><p>数据量太小不适合二分查找。</p>
<p>如果要处理的数据量很小，完全没必要用二分查找，顺序遍历就足够了。</p>
<p>如果数据之间的比较操作非常耗时，不管数据量大小，都推荐使用二分查找。比如，数组中存储的都是长度超过300的字符串，如此长的两个字符串之间比对大小，就会非常耗时。需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，此时二分查找就比顺序遍历更有优势。</p></li>
<li><p>数据量太大也不适合二分查找。二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求<strong>内存空间连续</strong>，对内存的要求比较苛刻。</p></li>
</ol>
<h2 id="解答开篇">解答开篇</h2>
<p>假设我们有1000w个整数数据，每个数据占8个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这1000w数据中？希望这个功能不要占用太多的内存空间，最多不超过100MB，该怎么做？</p>
<p>内存限制是100MB，每个数据大小是8字节，最简单的办法就是将数据存储在数组中，内存占用为<code>1000w*8/1024/1024=76.3MB</code>，符合内存的限制。可以先对这1000w数据从小到大排序，然后再利用二分查找算法，就可以快速地查找想要的数据了。</p>
<p>虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是，不管是散列表还是二叉树，都会需要比较多的额外的内存空间。二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式，所以刚好能在限定的内存大小下解决这个问题。</p>
<h2 id="课后思考">课后思考</h2>
<ol type="1">
<li><p>如何编程实现“求一个数的平方根”？要求精确到小数点后6位。参考LeetCode答案：<a href="https://leetcode-cn.com/problems/sqrtx/solution/python-kai-gen-hao-bao-liu-xiao-shu-dian-sehr/">Python 开根号 保留小数点后几位</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search_sqrt</span>(<span class="params">x, k</span>):</span></span><br><span class="line">    low, high = <span class="number">0</span>, x</span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + (high-low) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(mid * mid - x) &lt; <span class="number">0.1</span> ** k:</span><br><span class="line">            <span class="comment"># 在误差范围内 保留指定位数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">round</span>(mid, k)</span><br><span class="line">        <span class="keyword">elif</span> mid * mid &gt; x:</span><br><span class="line">            high = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    result = binary_search_sqrt(<span class="number">2</span>, <span class="number">6</span>)  <span class="comment"># 1.414214</span></span><br><span class="line">    result = binary_search_sqrt(<span class="number">4</span>, <span class="number">6</span>)  <span class="comment"># 2.0</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li>
<li><p>如果数据使用链表存储，二分查找的时间复杂就会变成很高，那查找的时间复杂度究竟是多少呢？</p>
<p>来自置顶评论的答案：</p>
<p>假设链表长度为<code>n</code>，二分查找每次都要找到中间点（计算中忽略奇偶数差异）：</p>
<p>第一次查找中间点，需要移动指针<code>n/2</code>次，</p>
<p>第二次查找中间点，需要移动指针<code>n/4</code>次，</p>
<p>第三次查找中间点，需要移动指针<code>n/8</code>次，</p>
<p>...</p>
<p>以此类推，直到1次为止。</p>
<p>总共移动指针次数，根据等比数列求和公式： <span class="math display">\[
S_n = \frac{a_1*(1-q^n)}{1-q}=\frac{a_nq-a_1}{q-1}=\frac{1*\frac{1}{2}-\frac{n}{2}}{\frac{1}{2}-1}=n-1
\]</span> 所以，时间复杂度是<code>O(n)</code>。</p></li>
</ol>
<p>参考链接：</p>
<ol type="1">
<li><a href="https://zhidao.baidu.com/question/90801248.html">汇编中移位，为什么左移一位相当于乘以2</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>adb常用命令</title>
    <url>/2021/10/09/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>在安卓逆向过程中，经常会用到<code>adb</code>命令，本篇将记录一些<code>adb</code>命令，但自己又记不住的。</p>
<span id="more"></span>
<ol type="1">
<li><p>查看顶层的<code>activity</code>，这个命令我经常用来查看<code>App</code>包名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity top | grep ACTIVITY</span><br></pre></td></tr></table></figure></li>
<li><p>截图。将图片保存到<code>/sdcard</code>路径下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/screen.png</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>安卓逆向</category>
      </categories>
      <tags>
        <tag>adb命令</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>排序(上)</title>
    <url>/2021/09/29/%E6%8E%92%E5%BA%8F-%E4%B8%8A/</url>
    <content><![CDATA[<p>今天来学习排序(上)。排序非常重要。</p>
<span id="more"></span>
<h2 id="如何分析一个排序算法">如何分析一个“排序算法”</h2>
<p>除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。</p>
<p>要从以下几个方面来分析一个排序算法。</p>
<h3 id="排序算法的执行效率">排序算法的执行效率</h3>
<ol type="1">
<li><p>最好情况、最坏情况、平均情况时间复杂度</p>
<p>除了能说出最好情况、最坏情况、平均情况下的时间复杂度外，还要能说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。</p>
<p>有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。</p></li>
<li><p>时间复杂度的系数、常数、低阶</p>
<p>时间复杂度反映的是数据规模n很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但在实际开发中，我们排序的可能是10个、100个、1000个这个规模很小的数据。所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</p></li>
<li><p>比较次数和交换(或移动)次数</p>
<p>基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换和移动。所以，在分析排序算法的执行效率的时候，应该把比较次数和交换(或移动)次数也考虑进去。</p></li>
</ol>
<h3 id="排序算法的内存消耗">排序算法的内存消耗</h3>
<p>算法的内存消耗可以通过空间复杂度来衡量。</p>
<p>原地排序，就是特指空间复杂度为<code>O(1)</code>的排序算法。</p>
<h3 id="排序算法的稳定性">排序算法的稳定性</h3>
<p>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，还有一个重要的度量指标，<strong>稳定性</strong>。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<p>如果相等元素之间原有的先后顺序不变，称之为<strong>稳定的排序算法</strong>，反之称为<strong>不稳定的排序算法</strong>。</p>
<p>为什么考察排序算法的稳定性呢？在真正的软件开发中，要排序的往往不是单纯的数字，而是一组对象，我们需要按照对象的某个<code>key</code>来排序。</p>
<h4 id="举例说明">举例说明</h4>
<p>现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果现在有10w条订单数据，希望按照金额从小到大对订单数据排序。对于订单金额相同的订单，希望按照下单时间从早到晚有序。对于这样一个排序需求，怎么做？</p>
<ol type="1">
<li>方法一，先按照金额对订单数据进行排序，然后，在遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。(理解起来简单，实现起来复杂)</li>
<li>方法二，先按照下单时间给订单排序。排序完成之后，再用稳定排序算法，按照订单金额重新排序。两边排序之后，得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。因为，<strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。</strong></li>
</ol>
<p>算法稳定性的用处，多次排序中，下一次排序需要依赖上一次排序的稳定结果。(妙啊)</p>
<h2 id="冒泡排序">冒泡排序</h2>
<h3 id="思路">思路</h3>
<p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成n个数据的排序工作。</p>
<h3 id="代码">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">a: <span class="built_in">list</span></span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="comment"># n次循环</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 注意点1: 这里j没有必要循环n次,因为倒数i个是有序的</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>-i):</span><br><span class="line">            <span class="keyword">if</span> a[j] &gt; a[j+<span class="number">1</span>]:</span><br><span class="line">                a[j], a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>], a[j]</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 注意点2: 当没有数据交换时，结束排序操作</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    aa = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="built_in">print</span>(bubble_sort(aa))</span><br></pre></td></tr></table></figure>
<h3 id="特点">特点</h3>
<ol type="1">
<li>原地排序，空间复杂度为<code>O(1)</code></li>
<li>稳定的排序算法</li>
<li>最好情况、最坏情况时间复杂度分别为<code>O(n)</code>、<code>O(n^2)</code></li>
</ol>
<h3 id="平均时间复杂度分析">平均时间复杂度分析</h3>
<p>利用“有序度”和“满序度”来分析平均时间复杂度。</p>
<p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。数学表达式：<code>有序元素对：a[i] &lt;= a[j], 如果i &lt; j</code>。其中完全有序的数组的有序度叫做<strong>满有序度</strong>。</p>
<p><strong>逆序度</strong>是数组中具有逆序关系的元素对的个数。数学表达式：<code>逆序元素对：a[i] &gt; a[j], 如果i &lt; j</code>。</p>
<p><strong>逆序度 = 满有序度 - 有序度</strong></p>
<p>举例：数组的初始状态是<code>4 5 6 3 2 1</code>，其中有序元素对有3个，分别是<code>(4, 5)</code>，<code>(4, 6)</code>，<code>(5, 6)</code>；逆序元素对有<code>(4, 3)</code>，<code>(4, 2)</code>，<code>(4, 1)</code>，<code>(5, 3)</code>，<code>(5, 2)</code>，<code>(5, 1)</code>，<code>(6, 3)</code>，<code>(6, 2)</code>，<code>(6, 1)</code>，<code>(3, 2)</code>，<code>(3, 1)</code>，<code>(2, 1)</code>共12个。</p>
<p><code>n</code>个元素的满有序度个数等于<code>n-1</code>个元素等差数列为1的求和公式，即<code>(n-1+1)*(n-1)/2=15</code>。</p>
<p>评论区有提到<code>C(n, m)</code>，自己也有印象，然后百度了一下，时间一长，都还给高中数学老师了。。。</p>
<blockquote>
<p>组合数公式是指从n个不同元素中，任取m(m&lt;=n)个元素并为一组，叫做从n个不同元素中取出m个元素的一个组合；从n个不同元素中取出m(m&lt;=n)个元素的所有组合的个数，叫做n个不同元素中取出m个元素的组合数。用符号C(n, m)表示。</p>
</blockquote>
<p>冒泡排序包含两个操作原子，<strong>比较</strong>和<strong>交换</strong>，其中交换次数等于逆有序度。</p>
<p>对于包含n个数据的数组进行冒泡排序，最坏情况下，初始状态的有序度0，所以要进行<code>n*(n-1)/2</code>次交换；最好情况下，初始状态的有序度为<code>n*(n-1)/2</code>，不需要进行交换。取一个中间值<code>n*(n-1)/4</code>来表示初始有序度既不是很高也不是很低的平均情况。</p>
<p>平均情况下，需要<code>n*(n-1)/4</code>次交换操作，比较操作比交换操作多，而复杂度的上限是<code>O(n^2)</code>，所以平均情况下的时间复杂度就是<code>O(n^2)</code></p>
<h2 id="插入排序">插入排序</h2>
<h3 id="思路-1">思路</h3>
<p>插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中的元素为空，算法结束。上图，(<a href="https://www.runoob.com/w3cnote/insertion-sort.html">菜鸟教程-插入排序</a>)</p>
<p><img src="insertion_sort.gif" /></p>
<h3 id="代码-1">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">a: <span class="built_in">list</span></span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        value = a[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> a[j] &gt; value:</span><br><span class="line">          	<span class="comment"># 向后移动数据</span></span><br><span class="line">            a[j+<span class="number">1</span>] = a[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        a[j+<span class="number">1</span>] = value</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<p>这个很难理解啊。调试了很久。。</p>
<h3 id="特点-1">特点</h3>
<ol type="1">
<li>原地排序，空间复杂度为<code>O(1)</code></li>
<li>稳定的排序算法。如果代码<code>a[j] &gt; value</code>修改为<code>a[j] &gt;= value</code>，则为不稳定的排序算法。</li>
<li>最好情况下时间复杂度为<code>O(n)</code>，此时不需要走<code>while</code>循环，只需要遍历<code>n</code>次；最坏情况下时间复杂度为<code>O(n^2)</code>，每次都需要走<code>while</code>循环，移动数据；平均情况时间复杂度为<code>O(n^2)</code>，数组那节提到数组插入的平均时间复杂度为<code>O(n)</code>，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行<code>n</code>次操作。</li>
</ol>
<h2 id="选择排序">选择排序</h2>
<h3 id="思路-2">思路</h3>
<p>选择排序和插入排序类似，也分为已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。一开始没理解，上图就一目了然了。</p>
<p><img src="select_sort.webp" /></p>
<h3 id="代码-2">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">a: <span class="built_in">list</span></span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        min_index = i</span><br><span class="line">        min_value = a[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            <span class="comment"># 找到最小值位置</span></span><br><span class="line">            <span class="keyword">if</span> a[j] &lt; min_value:</span><br><span class="line">                min_value = a[j]</span><br><span class="line">                min_index = j</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 交换位置</span></span><br><span class="line">        a[i], a[min_index] = a[min_index], a[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<h3 id="特点-2">特点</h3>
<ol type="1">
<li>原地排序，空间复杂度为<code>O(1)</code></li>
<li>最好情况、最坏情况、平均情况时间复杂度均为<code>O(n^2)</code>。因为每次都需要从未排序区间找到最小值，而最小值只能通过全部比较一次得到。比较次数为：<code>(n-1)+...+1=n*(n-1)/2</code>次</li>
<li>不稳定的排序算法。选择排序每次都要找到剩余未排序元素中的最小值，并<strong>和前面的元素交换位置</strong>，这样破坏了稳定性。</li>
</ol>
<h2 id="希尔排序">希尔排序</h2>
<h3 id="思路-3">思路</h3>
<p>先将整个待排序的记录序列分割成若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h3 id="代码-3">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">a: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    gap = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (gap &lt; <span class="built_in">len</span>(a) / <span class="number">3</span>):</span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, <span class="built_in">len</span>(a)):</span><br><span class="line">            temp = a[i]</span><br><span class="line">            j = i - gap</span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> a[j] &gt; temp:</span><br><span class="line">                a[j + gap] = a[j]</span><br><span class="line">                j -= gap</span><br><span class="line">            a[j + gap] = temp</span><br><span class="line">        gap = math.floor(gap / <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<p>代码看的有点晕，看动图也比较晕，<a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">比较排序算法-动图演示</a>，先放到这吧，慢慢理解...</p>
<h3 id="特点-3">特点</h3>
<ol type="1">
<li>原地排序，空间复杂度为<code>O(1)</code></li>
<li>不稳定的排序算法。</li>
<li>时间复杂度<code>O(n^(1.3-2))</code></li>
</ol>
<h2 id="解答开篇">解答开篇</h2>
<p>为什么冒泡排序和插入排序的时间复杂度都是<code>O(n^2)</code>，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？</p>
<p>冒泡排序和插入排序数据移动次数都是一样的，都等于数据的逆序度。但是在交换数据上，冒泡排序比插入排序更复杂一些，冒泡排序需要3个赋值操作，插入排序只需要1个。<code>Java</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序中数据的交换操作</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123;  <span class="comment">// 交换</span></span><br><span class="line">	<span class="keyword">int</span> tmp = a[j];</span><br><span class="line">	a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">	a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">	flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序中数据的移动操作</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j]  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把执行一个赋值语句的时间粗略地计为单位时间，然后分别用冒泡排序和插入排序对同一个逆序度是<code>K</code>的数组进行排序，用冒泡排序，需要<code>K</code>次交换操作，每次需要3个赋值语句，所以交换操作总耗时就是<code>3*K</code>单位时间。而插入排序中数据移动操作只需要<code>K</code>个单位时间。以上是分析<code>Java</code>代码的分析。</p>
<h3 id="性能测试">性能测试</h3>
<p>接下来和文章中类似的，用<code>Python</code>写一个性能对比测试程序，随机生成1000个数组，每个数组包含200个数据，然后分别用冒泡排序和插入排序来排序，来看看耗时。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bb = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    aa = [random.randint(<span class="number">100</span>, <span class="number">1000</span>) <span class="keyword">for</span> each <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>)]</span><br><span class="line">    bb.append(aa)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> bb:</span><br><span class="line">    insertion_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;insertion_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))  <span class="comment"># insertion_sort: 1.467289686203003</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> bb:</span><br><span class="line">    bubble_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bubble_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))  <span class="comment"># bubble_sort: 0.015933990478515625</span></span><br></pre></td></tr></table></figure>
<p>咦，怎么插入排序比冒泡排序耗时还要长？反过来试试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bb = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    aa = [random.randint(<span class="number">100</span>, <span class="number">1000</span>) <span class="keyword">for</span> each <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>)]</span><br><span class="line">    bb.append(aa)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> bb:</span><br><span class="line">    bubble_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bubble_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))  <span class="comment"># bubble_sort: 2.7117371559143066</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> bb:</span><br><span class="line">    insertion_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;insertion_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))  <span class="comment"># insertion_sort: 0.029211997985839844</span></span><br></pre></td></tr></table></figure>
<p>咦，怎么回事，仔细一想，哦，原来执行一次排序后，列表<code>bb</code>中的每个元素都已经有序了。好吧，再来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bb = []</span><br><span class="line">dd = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    aa = [random.randint(<span class="number">100</span>, <span class="number">1000</span>) <span class="keyword">for</span> each <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>)]</span><br><span class="line">    bb.append(aa)</span><br><span class="line">    dd.append(aa)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> bb:</span><br><span class="line">    bubble_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bubble_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))  <span class="comment"># bubble_sort: 2.657896041870117</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> dd:</span><br><span class="line">    insertion_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;insertion_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))  <span class="comment"># insertion_sort: 0.029906749725341797</span></span><br></pre></td></tr></table></figure>
<p>咦，和上次的执行结果基本一致，这是怎么回事？原来执行过一次排序后，列表<code>bb</code>和列表<code>dd</code>中的每个元素都是有序的。这主要是因为列表是可变对象，经过第一次排序后，列表<code>bb</code>中的元素是有序的，而列表<code>dd</code>中的元素和列表<code>bb</code>中存储的是同一批数据，指向同一块内存地址。那用深拷贝试试。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bb = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    aa = [random.randint(<span class="number">100</span>, <span class="number">1000</span>) <span class="keyword">for</span> each <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>)]</span><br><span class="line">    bb.append(aa)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">dd = copy.deepcopy(bb)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> bb:</span><br><span class="line">    insertion_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;insertion_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))  <span class="comment"># insertion_sort: 1.3626751899719238</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> dd:</span><br><span class="line">    bubble_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bubble_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time()-start))  <span class="comment"># bubble_sort: 2.683237075805664</span></span><br></pre></td></tr></table></figure>
<p>看起来有点对了，但是和文章中说的3倍关系好像还是有点差异，那么来看看<code>Python</code>中交换两个数<code>a[j], a[j+1] = a[j+1], a[j]</code>的原理吧。参考链接：<a href="https://www.zhihu.com/question/275696055">Python交换两个数</a>。回答中提到，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a, b = b, a</span><br><span class="line"></span><br><span class="line"># 等效于</span><br><span class="line"></span><br><span class="line">c = (b, a)  # 这个c是一个临时的元组</span><br><span class="line"></span><br><span class="line">a = c[0]  # 取出元组中的b</span><br><span class="line">b = c[1]  # 取出元组中的a</span><br></pre></td></tr></table></figure>
<p>从这段代码中来看，是只有两次赋值操作的。和上面性能测试中耗时时间2倍关系是相吻合的。</p>
<p>另外，可以对比一下最好情况下，冒泡排序和插入排序的耗时情况。尽管时间复杂度都是<code>O(n)</code>，但冒泡排序优于插入排序。</p>
<h2 id="课后思考">课后思考</h2>
<p>上面写的几种排序算法，都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那么相应的时间、空间复杂度是多少？</p>
<p>来吧，先把置顶评论放到这吧。前提，是否允许修改链表的节点value值，还是只能改变节点的位置。一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。</p>
<p>个人思考，如果允许修改链表的节点value值，就会和数组有点类似。数组的优势是根据下标随机访问，劣势是搬移数据；链表的优势是插入删除数据，劣势是随机访问。修改链表的节点value值也是赋值操作，跟数组操作一致。如果改变节点位置，比较次数同循环次数一致，交换(或移动)次数同数据逆序度。但是链表交换位置，意味着需要修改指针指向，如果是单链表需要节点的上一个节点的引用，这样就增加了时间复杂度。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序(下)</title>
    <url>/2021/10/15/%E6%8E%92%E5%BA%8F-%E4%B8%8B/</url>
    <content><![CDATA[<p>今天来学习排序(下)。</p>
<span id="more"></span>
<h2 id="归并排序的原理">归并排序的原理</h2>
<p>核心思想：如果要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>
<p>归并排序使用的是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。</p>
<p>分治思想跟递归思想很像。分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>。</p>
<p>自己又陷入思维误区，试图理解整个递归的过程，然后脑子就懵了...</p>
<p>回顾一下写递归代码的技巧，<strong>分析得出递归公式，然后找到终止条件，最后将递推公式翻译成递归代码</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递推公式</span></span><br><span class="line">merge_sort(p...r) = merge(merge_sort(p...q), merge_sort(q+<span class="number">1.</span>..r))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终止条件</span></span><br><span class="line">p &gt;= r 不用再继续分解</span><br></pre></td></tr></table></figure>
<p><strong>通过递归代码来实现归并排序</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">a: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">    _merge_sort(a, <span class="number">0</span>, <span class="built_in">len</span>(a)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_merge_sort</span>(<span class="params">a: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">        _merge_sort(a, low, mid)</span><br><span class="line">        _merge_sort(a, mid+<span class="number">1</span>, high)</span><br><span class="line">        _merge(a, low, mid, high)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_merge</span>(<span class="params">a: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, mid: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        合并两个有序数组</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i, j = low, mid+<span class="number">1</span></span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt;= a[j]:</span><br><span class="line">            tmp.append(a[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(a[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    start = i <span class="keyword">if</span> i &lt;= mid <span class="keyword">else</span> j</span><br><span class="line">    end = mid <span class="keyword">if</span> i &lt;= mid <span class="keyword">else</span> high</span><br><span class="line">    tmp.extend(a[start: end + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    a[low: high+<span class="number">1</span>] = tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line">    merge_sort(t)</span><br><span class="line">    <span class="built_in">print</span>(t)  <span class="comment"># [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>通过递归写出来的代码，总想看看递归的过程是什么样的。用文章中这张图来说明。</p>
<p><img src="merge_sort.webp" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始数组：[11, 8, 3, 9, 7, 1, 2, 5] </span><br><span class="line"></span><br><span class="line">第一次：[8, 11, 3, 9, 7, 1, 2, 5] </span><br><span class="line"></span><br><span class="line">第二次：[8, 11, 3, 9, 7, 1, 2, 5]</span><br><span class="line"></span><br><span class="line">第三次：[3, 8, 9, 11, 7, 1, 2, 5]</span><br><span class="line"></span><br><span class="line">第四次：[3, 8, 9, 11, 1, 7, 2, 5]</span><br><span class="line"></span><br><span class="line">第五次：[3, 8, 9, 11, 1, 7, 2, 5]</span><br><span class="line"></span><br><span class="line">第六次：[3, 8, 9, 11, 1, 2, 5, 7]</span><br><span class="line"></span><br><span class="line">最终结果：[1, 2, 3, 5, 7, 8, 9, 11]</span><br></pre></td></tr></table></figure>
<p>递归真的很难理解呀！</p>
<h2 id="归并排序的性能分析">归并排序的性能分析</h2>
<h3 id="稳定性">稳定性</h3>
<p>归并排序是稳定的排序算法。在<code>_merge()</code>函数合并两个有序子数组的代码中，当<code>a[i] &lt;= a[j]</code>时，<code>tmp.append(a[i])</code>，即不改变值相同元素的先后顺序，所以归并排序是稳定的排序算法。</p>
<h3 id="时间复杂度">时间复杂度</h3>
<p>归并排序的时间复杂度是<code>O(nlogn)</code></p>
<p>归并排序涉及递归，如何分析递归代码的时间复杂度？</p>
<p>如果定义求解问题<code>a</code>的时间是<code>T(a)</code>，求解问题<code>b</code>、<code>c</code>的时间分别是<code>T(b)</code>、<code>T(c)</code>，那么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T(a) = T(b) + T(c) + K</span><br></pre></td></tr></table></figure>
<p>其中<code>K</code>等于将两个子问题<code>b</code>、<code>c</code>的结果合并成问题<code>a</code>的结果所消耗的时间。</p>
<p><strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong></p>
<p>假设对<code>n</code>个元素进行归并排序需要的时间是<code>T(n)</code>，那么分解成两个子数组排序的时间都是<code>T(n/2)</code>，<code>_merge()</code>函数合并两个有序子数组的时间复杂度是<code>O(n)</code>(因为两个有序子数组一共有<code>n</code>个元素)。</p>
<p>所以，套用上面的公式，归并排序的时间复杂度的计算公式就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T(1) = C; n=1时，只需要常量级的执行时间，所以表示为C</span><br><span class="line">T(n) = 2*T(n/2) + n; n&gt;1</span><br></pre></td></tr></table></figure>
<p>进一步分解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T(n) = 2*T(n/2) + n</span><br><span class="line"> = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n  (将n=n/2整体代入)</span><br><span class="line"> = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n</span><br><span class="line"> ...</span><br><span class="line"> = 2^k * T(n/2^k) + k*n</span><br></pre></td></tr></table></figure>
<p>最终得到<code>T(n) = 2^k * T(n/2^k) + k*n</code>，<code>n</code>代表待排序数组的长度，<code>k</code>代表分解次数，当<code>T(n/2^k)=T(1)</code>时，代表分解数组中个数为1，递归到了尽头，也就是<code>n/2^k=1</code>，此时 <span class="math display">\[
k=\log_2n
\]</span> 将<code>k</code>值代入上面的公式，得到 <span class="math display">\[
T(n) = Cn + n\log_2n
\]</span> 用大O标记法来表示的话，<code>T(n)=O(nlogn)</code>，所以归并排序的时间复杂度为<code>O(nlogn)</code></p>
<p>归并排序的执行效率与要排序的原始数组的有序程度无关，其时间复杂度是非常稳定的，不管是最好情况、最坏情况、还是平均情况，时间复杂度都是<code>O(nlogn)</code></p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>归并排序的空间复杂度是<code>O(n)</code>。归并排序的时间复杂度任何情况下都是<code>O(nlogn)</code>，看起来非常优秀，但归并排序不是原地排序算法。</p>
<p>因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。如果继续按照分析递归时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是<code>O(nlogn)</code>。</p>
<p>实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。尽管每次合并操作都需要额外申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过<code>n</code>个数据的大小(只考虑最大临时内存空间就好了)，所以空间复杂度是<code>O(n)</code>。</p>
<h2 id="快速排序的原理">快速排序的原理</h2>
<p>快速排序，简称快排，利用的也是分治思想。</p>
<p>核心思想：</p>
<ol type="1">
<li><p>如果要排序数组中下标从<code>p</code>到<code>r</code>之间的一组数据，我们选择<code>p</code>到<code>r</code>之间的任意一个数据作为<code>pivot</code>(分区点)。</p></li>
<li><p>遍历<code>p</code>到<code>r</code>之间的数据，将小于<code>pivot</code>的放到左边，将大于<code>pivot</code>的放到右边，将<code>pivot</code>放到中间。经过这一步骤之后，数组<code>p</code>到<code>r</code>之间的数据就被分成了三个部分，前面<code>p</code>到<code>q-1</code>之间都是小于<code>pivot</code>的，中间是<code>pivot</code>，后面的<code>q+1</code>到<code>r</code>之间是大于<code>pivot</code>的。如图所示，</p>
<p><img src="quick_sort.webp" /></p></li>
<li><p>根据分治、递归的处理思想，可以用递归排序下标从<code>p</code>到<code>q-1</code>之间的数据和下标从<code>q+1</code>到<code>r</code>之间的数据，直到区间缩小为1，就说明所有的数据都有序了。</p></li>
</ol>
<p>递推公式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递推公式</span></span><br><span class="line">quick_sort(p...r) = quick_sort(p...q-<span class="number">1</span>) + quick_sort(q...r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终止条件</span></span><br><span class="line">p &gt;= r</span><br></pre></td></tr></table></figure>
<p><strong>通过递归代码来实现快速排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">a: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">    _quick_sort(a, <span class="number">0</span>, <span class="built_in">len</span>(a)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_quick_sort</span>(<span class="params">a: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        k = random.randint(low, high)</span><br><span class="line">        <span class="comment"># 把pivot放到首部</span></span><br><span class="line">        a[low], a[k] = a[k], a[low]</span><br><span class="line"></span><br><span class="line">        m = _partition(a, low, high)</span><br><span class="line">        _quick_sort(a, low, m-<span class="number">1</span>)</span><br><span class="line">        _quick_sort(a, m+<span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_partition</span>(<span class="params">a: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>):</span></span><br><span class="line">    pivot, j = a[low], low</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(low+<span class="number">1</span>, high+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt;= pivot:</span><br><span class="line">            j += <span class="number">1</span>  <span class="comment"># 这里j是记录pivot要放的位置</span></span><br><span class="line">            a[i], a[j] = a[j], a[i]</span><br><span class="line"></span><br><span class="line">    a[low], a[j] = a[j], a[low]</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">    quick_sort(t)</span><br><span class="line">    <span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure>
<p>快速排序中有个<code>partition()</code>分区函数，随机选择一个元素作为<code>pivot</code>然后对<code>a[p..r]</code>分区，函数返回<code>pivot</code>的下标。如果不考虑空间消耗，<code>partition</code>分区函数可以写的非常简单。申请两个临时数组<code>X</code>和<code>Y</code>，将小于<code>pivot</code>的元素都拷贝到临时数组<code>X</code>，将大于<code>pivot</code>的元素都拷贝到临时数组<code>Y</code>，最后再将数组<code>X</code>和<code>Y</code>中的元素顺序拷贝到<code>a[p...r]</code>。</p>
<p>但是，如果这样实现的话，快速排序就不是原地排序算法了。如果考虑空间复杂度为<code>O(1)</code>的话，需要用到类似<strong>选择排序</strong>的处理方式，通过游标<code>j</code>把<code>a[low:high]</code>分成两部分。<code>a[low:j-1]</code>的元素都是小于<code>pivot</code>的，称作“已处理区间”，<code>a[j+1:high]</code>是“未处理区间”。每次从未处理区间取一个值，和<code>pivot</code>对比，如果小于<code>pivot</code>，就把它放到已处理区间的尾部。但在数组某个位置插入元素，需要搬移操作，非常耗时。因此，选择交换的处理方式。</p>
<p>实现方式：通过游标<code>i</code>从前往后遍历数组<code>a</code>，如果<code>a[i]</code>的值小于<code>pivot</code>，则<code>j+=1</code>，说明有一个元素小于<code>pivot</code>，直至遍历结束。最后，交换<code>pivot</code>和下标为<code>j</code>的值。这样，下标<code>j</code>左边的值都小于<code>pivot</code>，右边的值都大于<code>pivot</code>，</p>
<h3 id="归并排序vs快速排序">归并排序vs快速排序</h3>
<p><img src="merge_sort_vs_quick_sort.webp" /></p>
<p>归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为<code>O(nlogn)</code>的排序算法，但是非原地排序算法。而快速排序通过原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p>
<h2 id="快速排序的性能分析">快速排序的性能分析</h2>
<h3 id="稳定性-1">稳定性</h3>
<p>快速排序是不稳定的排序算法。我这里根据序列<code>6, 8, 7, 6, 3, 5, 9, 4</code>仿照文章中的分析，也画了张图。</p>
<p><img src="quick_sort_stable.jpg" /></p>
<p>显而易见，当比较<code>3&lt;4</code>时，需要交换下标<code>i</code>和<code>j</code>的值，这样第一个6就跑到了第二个6的后面，因此，快速排序是不稳定的排序算法。想了半天想不明白，画了画图，豁然开朗。</p>
<p>评论里说，涉及到交换操作的排序算法都是不稳定的，这里先记录一下，后续验证一下。</p>
<h3 id="时间复杂度-1">时间复杂度</h3>
<p>快排也是用递归来实现的，对于上面分析归并排序的公式，对于快排同样适用。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那么快排的时间复杂度递推求解公式跟归并排序是相同的。所以快速排序的时间复杂度是<code>O(nlogn)</code>。</p>
<p>但是，公式成立的前提是每次分区操作，选择的<code>pivot</code>都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。</p>
<p>举一个比较极端的例子。如果数组中的数据原来已经是有序的了，比如<code>1, 3, 5, 6, 8</code>。如果每次选择最后一个元素作为<code>pivot</code>，那每次分区得到的两个区间都是不均等的。这种情况下，快排的时间复杂度就从<code>O(nlogn)</code>退化成了<code>O(n^2)</code>。</p>
<p>结论：快速排序在大部分情况下的时间复杂度都可以做到<code>O(nlogn)</code>，只有在极端情况下，才会退化到<code>O(n^2)</code>。</p>
<h3 id="空间复杂度-1">空间复杂度</h3>
<p>快速排序是原地排序算法。主要取决于分区函数的实现。</p>
<h2 id="排序算法对比">排序算法对比</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>冒泡排序</td>
<td><code>O(n^2)</code></td>
<td><code>O(1)</code></td>
<td>稳定</td>
</tr>
<tr class="even">
<td>插入排序</td>
<td><code>O(n^2)</code></td>
<td><code>O(1)</code></td>
<td>稳定</td>
</tr>
<tr class="odd">
<td>选择排序</td>
<td><code>O(n^2)</code></td>
<td><code>O(1)</code></td>
<td>不稳定(涉及交换元素)</td>
</tr>
<tr class="even">
<td>归并排序</td>
<td><code>O(nlogn)</code></td>
<td><code>O(n)</code></td>
<td>稳定</td>
</tr>
<tr class="odd">
<td>快速排序</td>
<td><code>O(nlogn)</code></td>
<td><code>O(1)</code></td>
<td>不稳定(涉及交换元素)</td>
</tr>
</tbody>
</table>
<p>冒泡排序、插入排序、选择排序时间复杂度都为<code>O(n^2)</code>，比较高，适合小规模数据的排序。</p>
<p>归并排序、快速排序时间复杂度都为<code>O(nlogn)</code>，适合大规模的数据排序。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>问题：<code>O(n)</code>时间复杂度内求无序数组中的第<code>K</code>大元素？比如，<code>4, 2, 5, 12, 3</code>这样一组数据，第3大元素就是4</p>
<p>答案：利用分区的思想。我们选择数组区间<code>A[0...n-1]</code>的最后一个元素<code>A[n-1]</code>作为<code>pivot</code>，对数组<code>A[0...n-1]</code>原地分区，这样数组就分成了三部分，<code>A[0...p-1]</code>、<code>A[p]</code>、<code>A[p+1...n-1]</code>。</p>
<p>如果<code>p+1=K</code>，那么<code>A[p]</code>就是要求解的元素（如果要查找第3大元素，那么下标为2的元素就是要查找的值）；如果<code>K&gt;p+1</code>，说明第<code>K</code>大元素出现在<code>A[p+1...n-1]</code>区间，然后递归地在<code>A[p+1...n-1]</code>这个区间查找。反之，就在<code>A[0...p-1]</code>区间查找。</p>
<p>那么为什么时间复杂度是<code>O(n)</code>呢？</p>
<p>第一次分区查找，需要对大小为<code>n</code>的数组执行分区操作，需要遍历<code>n</code>个元素。第二次分区查找，只需要对大小为<code>n/2</code>的数组执行分区操作，需要遍历<code>n/2</code>个元素，依次类推，分区遍历的元素个数分别为：<code>n/2</code>、<code>n/4</code>、<code>n/8</code>、<code>n/16</code>...直到区间缩小为1。</p>
<p>把每次分区遍历的元素个数加起来，就是<code>n+n/2+n/4+n/8+n/16+...+1</code>，这是一个等比数列求和。</p>
<p>等比数列求和公式： <span class="math display">\[
S_n = \frac{a_1*(1-q^n)}{1-q}=\frac{a_1-a_nq}{1-q}=\frac{a_nq-a_1}{q-1},(q\neq1)
\]</span> 即： <span class="math display">\[
S_n = \frac{(1*\frac{1}{2}-n)}{\frac{1}{2}-1}=\frac{1-2n}{1-2}=2n-1
\]</span> 所以上述思路的时间复杂度就为<code>O(n)</code>。</p>
<p>文章中提到一个方法，每次取数组中的最大值，将其移动到数组的最前面，然后在剩下的数组中继续找最大值，以此类推，执行<code>K</code>次，找到的数据不就是第<code>K</code>大元素了吗？</p>
<p>首先，这是选择排序的思路，其次寻找第<code>K</code>大元素的时间复杂度是<code>O(K*n)</code>，并不是<code>O(n)</code>，时间复杂度前面的系数<code>K</code>是比较小的常量时，那么时间复杂度确实是<code>O(n)</code>，但当<code>K</code>等于<code>n/2</code>或是<code>n</code>时，这种最坏情况下的时间复杂度就是<code>O(n^2)</code>。</p>
<h2 id="课后思考">课后思考</h2>
<p>现在有10个接口访问日志文件，每个日志文件大小约300MB，每个文件里的日志都是按照时间戳从小到大排序的。希望将这10个较小的日志文件，合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有1GB，有什么好的解决思路，能“快速”地将这10个日志文件合并吗？</p>
<p>来自置顶评论的答案：每次从各个文件中取一条数据，在内存中根据数据时间戳构建一个最小堆，然后每次把最小值给写入新文件，同时将最小值来自的那个文件再出来一个数据，加入到最小堆中。这个空间复杂度为常数，但没能很好利用1G内存，而且磁盘单个读取比较慢，所以考虑每次读取一批数据，没了再从磁盘中取，时间复杂度还是<code>O(n)</code>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序优化</title>
    <url>/2021/10/18/%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>今天来学一下排序优化。</p>
<span id="more"></span>
<p>如何实现一个通用的、高性能的排序函数？</p>
<h2 id="如何选择合适的排序算法">如何选择合适的排序算法</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th>时间复杂度</th>
<th>稳定排序</th>
<th>原地排序</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>冒泡排序</td>
<td><code>O(n^2)</code></td>
<td>是</td>
<td>是</td>
</tr>
<tr class="even">
<td>插入排序</td>
<td><code>O(n^2)</code></td>
<td>是</td>
<td>是</td>
</tr>
<tr class="odd">
<td>选择排序</td>
<td><code>O(n^2)</code></td>
<td>否</td>
<td>是</td>
</tr>
<tr class="even">
<td>快速排序</td>
<td><code>O(nlogn)</code></td>
<td>否</td>
<td>是</td>
</tr>
<tr class="odd">
<td>归并排序</td>
<td><code>O(nlogn)</code></td>
<td>是</td>
<td>否</td>
</tr>
<tr class="even">
<td>桶排序</td>
<td><code>O(n)</code></td>
<td>是</td>
<td>否</td>
</tr>
<tr class="odd">
<td>计数排序</td>
<td><code>O(n+k)</code> k是数据范围</td>
<td>是</td>
<td>否</td>
</tr>
<tr class="even">
<td>基数排序</td>
<td><code>O(dn)</code> d是维度</td>
<td>是</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>这里计数排序和基数排序的时间复杂度为什么是<code>O(n+k)</code>和<code>O(dn)</code>？</p>
<p>线性排序算法的时间复杂度比较低，适用场景比较特殊。如果要写一个通用的排序函数，不能选择线性排序算法。</p>
<p>如果对小规模数据进行排序，可以选择时间复杂度是<code>O(n^2)</code>的算法；如果对大规模数据进行排序，时间复杂度是<code>O(nlogn)</code>的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是<code>O(nlogn)</code>的排序算法来实现排序函数。</p>
<p>时间复杂度是<code>O(nlogn)</code>的排序算法不止一个，除了快速排序和归并排序，还有堆排序。堆排序和快速排序都有比较多的应用。比如<code>Java</code>语言采用堆排序实现排序函数、<code>C</code>语言采用快速排序实现排序函数。</p>
<p>快速排序在最坏情况下的时间复杂度是<code>O(n^2)</code>，而归并排序可以在平均情况、最坏情况下的时间复杂度都是<code>O(nlogn)</code>，但是由于归并排序并不是原地排序算法，空间复杂度是<code>O(n)</code>，因此没有得到广泛应用。</p>
<h2 id="如何优化快速排序">如何优化快速排序</h2>
<p>如果数据本身就是有序或者接近有序的，每次分区点选择最后一个数据，那么快速排序算法时间复杂度就会退化成<code>O(n^2)</code>。这种情况的出现的主要原因是分区点选的不够合理。</p>
<p>最理想的分区点：<strong>被分区点分开的两个分区中，数据的数量差不多。</strong></p>
<h3 id="三数取中法">三数取中法</h3>
<p>从区间的首、尾、中间，分别取出一个数，然后对比大小，取这3个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p>
<h3 id="随机法">随机法</h3>
<p>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能出现每次分区点都选得很差，所以，平均情况下，这样选的分区点是比较好的。时间复杂度退化为<code>O(n^2)</code>的情况，出现的可能性不大。</p>
<p>快速排序是用递归来实现的，递归要警惕堆栈溢出。</p>
<h2 id="举例分析排序函数">举例分析排序函数</h2>
<p><code>C</code>运行库<code>Glibc</code>中的<code>qsort()</code>函数举例说明。</p>
<p><code>qsort()</code>会优先使用归并排序来排序输入数据。因为归并排序的空间复杂度是<code>O(n)</code>，对于小数据量的排序，比如1KB、2KB等，归并排序需要的空间可以忽略。</p>
<p>但<strong>如果数据量太大，比如说100MB，<code>qsort()</code>会改为快速排序算法来排序。</strong><code>qsort()</code>选择分区点的方法就是“三数取中法”。对于递归太深会导致堆栈溢出的问题，<code>qsort()</code>是通过自己实现一个堆上的栈，手动模拟递归实现的。</p>
<p>实际上，<code>qsort()</code>并不仅仅用到了归并排序和快速排序，还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于4时，<code>qsort()</code>就会退化为插入排序，不再继续使用递归来做快速排序。</p>
<p><strong>在小规模数据中，<code>O(n^2)</code>时间复杂度的算法并不一定比<code>O(nlogn)</code>的算法执行时间长。</strong></p>
<p>算法的性能可以通过时间复杂度来分析，但是，这种复杂度分析是比较偏理论的，实际上时间复杂度并不等于代码实际的运行时间。</p>
<p>时间复杂度代表的是一个增长趋势，如果画成增长曲线，会发现<code>O(n^2)</code>比<code>O(nlogn)</code>增长趋势更猛一些，但是，在大<code>O</code>复杂度表示法中，会忽略低阶、系数和常数。也就是说，<code>O(nlogn)</code>在没有省略低阶、系数、常数之前可能是<code>O(knlogn+c)</code>，而且<code>k</code>和<code>c</code>有可能还是一个比较大的数。</p>
<p>对于小规模数据的排序，<code>O(n^2)</code>的排序算法并不一定比<code>O(nlogn)</code>排序算法执行的时间长。对于小数据量的排序，选择比较简单、不需要递归的插入排序算法。</p>
<p>同时，<code>qsort()</code>排序算法中还通过哨兵来简化代码、提高执行效率。</p>
<p>看来，一个优秀的源码是把各种细节做到了极致。不仅仅用到了三种排序算法，还考虑到递归潜在风险，通过手动实现堆来模拟递归以及哨兵模式。真的赞。</p>
<h2 id="课后思考">课后思考</h2>
<p>所熟悉的语言中的排序函数都是用什么排序算法实现的？有哪些优化技巧？</p>
<p><code>Python</code>中列表排序是在<code>CPython</code>中<a href="https://github.com/python/cpython/blob/main/Objects/listobject.c"><code>listobject.c</code></a>来实现的。说明文档：<a href="https://github.com/python/cpython/blob/main/Objects/listsort.txt">listsort.txt</a>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2021/09/15/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>​ 作为一个程序员，数据结构与算法是基础知识。就好比是武侠小说里的“内功心法”，只有掌握了内功心法，才能以不变应万变。接下来会跟着极客时间里王争老师的专栏《数据结构与算法之美》，对这一块知识进行学习总结。</p>
<span id="more"></span>
<h2 id="定义">定义</h2>
<blockquote>
<p>数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p>
</blockquote>
<p>重点理解：</p>
<ol type="1">
<li><p>线性表。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈等都是线性表结构。非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为数据之间并不是简单的前后关系。</p>
<p>这里我的理解是，数组和链表是两种最基础的数据结构。队列、栈等线性表结构和二叉树、堆等非线性表都可以通过数组和链表来实现。或者说数组和链表是数据在内存中的表示方式，要么是连续的(数组)，要么是非连续的(链表)。</p></li>
<li><p>连续的内存空间和相同类型的数据。优点：随机访问。缺点：插入删除数据时，为保证连续性，需要做数据搬移操作。</p></li>
</ol>
<h2 id="随机访问">随机访问</h2>
<p>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，会通过寻址公式，来计算该元素存储的内存地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure>
<p>数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度O(1)；数组适合查找，查找的复杂度为O(1)”。这种表述不准确，数组是适合查找操作，但是查找的时间复杂度并不是O(1)。即使是排好序的数组，使用二分查找，时间复杂度为O(logn)。所以，正确的表述是数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。</p>
<p>关于这两种表述方式，我理解之间的差异是，一个通过下标查找<code>value</code>，通过寻址方式，时间复杂度是O(1)；另一种是在数组中查找<code>value</code>，排好序的数据，通过二分查找，时间复杂度为O(logn)。(直观理解为字典里根据<code>key</code>查找<code>value</code>和遍历字典查找<code>value</code>的区别，这种理解方式可能不太恰当)</p>
<h2 id="低效的插入和删除">低效的“插入”和“删除”</h2>
<h3 id="插入操作">插入操作</h3>
<p>平均时间复杂度O(n)。计算方式：<code>(1+2+....+n)/n=O(n)</code></p>
<p>改进：将要插入指定位置的原元素放到最后，然后将新元素插入指定位置。时间复杂度O(1)</p>
<h3 id="删除操作">删除操作</h3>
<p>平均时间复杂度O(n)</p>
<p>改进：先记录下已经删除的数据，当数组没有更多空间存储数据时，再触发执行一次真正的删除操作(JVM标记清除垃圾回收算法的核心思想)。时间复杂度视情况而定</p>
<h2 id="警惕数组的访问越界问题">警惕数组的访问越界问题</h2>
<p>在C语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。</p>
<p>数组越界在C语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p>
<p>很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。但并非所有的语言都像C语言一样，把数组越界检测的工作丢给程序员来做，像Java本身就会做越界检查，会抛出越界异常。</p>
<p>文中的代码我在Mac终端通过<code>gcc</code>编译后执行，打印了四次<code>hello world</code>后异常退出，如图，</p>
<p><img src="index_out_of_bound.jpeg" /></p>
<p>这个问题在文章后的评论里找到了答案：<code>gcc</code>有一个编译选项(<code>-fno-stack-protectot</code>)用于关闭堆栈保护功能。默认情况下启动了堆栈保护，不管<code>i</code>声明在前还是在后，<code>i</code>都会在数组之后压栈，只会循环四次；如果关闭堆栈保护功能，则会出现死循环。C语言代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">		arr[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容器能否完全替代数组">容器能否完全替代数组</h2>
<p>针对数组类型，很多语言都提供了容器类，比如<code>Java</code>中的<code>ArrayList</code>、<code>C++ STL</code>中的<code>vector</code>。我的理解，平时<code>Python</code>中经常使用的<code>list</code>、<code>dict</code>、<code>set</code>等提供操作<code>api</code>的类都称之为容器类。</p>
<p><code>ArrayList</code>最大的优势就是<strong>可以将很多数组操作的细节封装起来</strong>。比如数组插入、删除数据时需要搬移其他数据等。另外，还有一个优势，就是支持<strong>支持动态扩容</strong>。</p>
<p>需要注意的是，扩容操作涉及内存申请和数据搬移，是比较耗时的，所以，如果事先能确定需要存储的数据大小，最好在<strong>创建<code>ArrayList</code>的时候事先指定数据大小</strong></p>
<p>总结：</p>
<ol type="1">
<li><code>Java ArrayList</code>无法存储基本数据类型，比如<code>int</code>、<code>long</code>，需要封装为<code>Integer</code>、<code>Long</code>类，而<code>Autoboxing(自动装箱)</code>、<code>Unboxing(自动拆箱)</code>则有一定的性能消耗，所以如果特别关注性能，或希望使用基本数据类型，就可以选用数组。</li>
<li>如果数据大小事先已知，并且对数据的操作非常简单，用不到<code>ArrayList</code>提供的大部分方法，也可以直接使用数组。</li>
<li>当表示多维数组时，用数组往往会更加直观。比如，<code>Object[][] array</code>；而用容器的话，<code>ArrayList&lt;ArrayList&lt;object&gt;&gt; array</code></li>
</ol>
<p>对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能，但是如果做一些特别底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>为什么大多数编程语言中，数组要从0开始编号，而不是从1开始呢？</p>
<ol type="1">
<li>通过寻址公式来看，从0开始编号，<code>a[k]_address = base_address + k * data_type_size</code>；从1开始编号，<code>a[k]_address = base_address + (k-1) * data_type_size</code>。不难发现，从1开始编号，每次随机访问数组元素都多了一次减法元素，对于CPU来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。</li>
<li>历史原因。C语言设计者用0开始计数数组下标，之后的Java、JavaScript等高级语言都效仿了C语言，或者说，为了在一定程度上减少C语言程序员学习Java的学习成本，因此继续沿用了从0开始计数的习惯。</li>
</ol>
<h2 id="课后思考">课后思考</h2>
<ol type="1">
<li><p>JVM的标记清除垃圾回收算法的核心理念</p>
<p>大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有的<code>GC ROOTS</code>，将所有的<code>GC ROOTS</code>可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。</p>
<p>不足：1. 效率问题，标记和清理效率都不高，但是当知道只有少数垃圾产生时会很高效。2.空间问题，会产生不连续的内存空间碎片。</p>
<p>联想：Python中的垃圾回收机制：主要通过引用计数法进行垃圾回收，通过“标记-清除”解决容器对象可能产生的循环引用问题；通过“分代回收”以空间换时间的方法提高垃圾回收率</p></li>
<li><p>二维数组的内存寻址公式</p>
<p>对于<code>m*n</code>的数组，<code>a[i][j] (i&lt;m, j&lt;n)</code>的地址为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address = base_address + (i*n + j) * data_type_size</span><br></pre></td></tr></table></figure></li>
</ol>
<p>参考链接：</p>
<ol type="1">
<li><p><a href="https://zhuanlan.zhihu.com/p/83251959">Python垃圾回收机制！非常实用</a></p></li>
<li><p><a href="https://blog.csdn.net/qq_42019874/article/details/111599687">二维数组和多维数组的本质及寻址方式</a></p></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2021/09/18/%E6%A0%88/</url>
    <content><![CDATA[<p>今天来学习栈。</p>
<span id="more"></span>
<h2 id="如何理解栈">如何理解“栈”</h2>
<p><strong>后进者先出，先进者后出</strong>，这就是典型的”栈“结构。</p>
<p>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这是就应该首选”栈“这种数据结构。</p>
<h2 id="如何实现一个栈">如何实现一个“栈”</h2>
<p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，叫做<strong>顺序栈</strong>，用链表实现的栈，叫做<strong>链式栈</strong>。</p>
<h3 id="基于数组实现">基于数组实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.items = []</span><br><span class="line">        self.length = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.items) == self.length:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>, item)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.items) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;栈为空&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stack = ArrayStack(<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        a.push(<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(a.items)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(a.pop())</span><br></pre></td></tr></table></figure>
<h3 id="基于链表实现">基于链表实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data, next_node=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = next_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.<span class="built_in">next</span> = self.__head</span><br><span class="line">        self.__head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.__head:</span><br><span class="line">            data = self.__head.data</span><br><span class="line">            self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        data = []</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            data.append(cur.data)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;-&gt;&#x27;</span>.join(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stack = LinkedStack()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        stack.push(<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(stack)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(stack.pop(), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>时间复杂度<code>O(1)</code>，空间复杂度<code>O(1)</code></p>
<h2 id="支持动态扩容的顺序栈">支持动态扩容的顺序栈</h2>
<p>当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。</p>
<p>所以如果要实现一个支持动态扩容的栈，只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数组搬移到新数组中。</p>
<p><img src="array_stack.webp" /></p>
<p>实际上，支持动态扩容的顺序栈，平时开发中并不常用到。这里还是重点练习一下复杂度分析。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p>对于出栈操作来说，不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是<code>O(1)</code></p>
<p>对于入栈操作来说，当栈中有空闲空间时，最好情况时间复杂度是<code>O(1)</code>，当空间不够时，就需要重新申请内存和数据搬移，最坏情况时间复杂度是<code>O(n)</code>。</p>
<p>利用<strong>摊还分析法</strong>来分析平均时间复杂度。为了分析的方便，做一些假设和定义：</p>
<ul>
<li>栈空间不够时，重新申请一个是原来大小两倍的数组；</li>
<li>为了简化分析，假设只有入栈操作没有出栈操作；</li>
<li>定义不涉及内存搬移的入栈操作为<code>simple-push</code>操作，时间复杂度为<code>O(1)</code></li>
</ul>
<p>如果当前栈大小为K，并且已满，当再有新的数据要入栈时，就需要重新申请2倍大小的内存，并且做K个数据的搬移操作，然后再入栈。但是，接下来的K-1次入栈操作，都不需要再重新申请内存和搬移数据，所以这K-1次入栈操作都只需要一个<code>simple-push</code>操作就可以完成。</p>
<p><img src="push_stack.jpg" /></p>
<p>这里有一个疑惑点，为什么是K-1次入栈操作？分析，当前栈大小为K，并且已满。当K+1次入栈时，触发内存申请(申请空间为2K)和数据搬移(K个数据)操作，然后再将K+1个元素入栈，接下来的2K-K-1=K-1次入栈操作不需要触发内存申请和数据搬移。</p>
<p><strong>结论：</strong>均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度O都是<code>O(1)</code>，只有在个别时刻才会退化为<code>O(n)</code>，所以把耗时多的入栈操作时间均摊到其他入栈操作上，平均情况下的耗时就接近<code>O(1)</code></p>
<h2 id="栈在函数调用中的应用">栈在函数调用中的应用</h2>
<p>栈比较经典的一个应用场景就是<strong>函数调用栈</strong>。</p>
<p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">   ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">   reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行到<code>add()</code>函数时，函数调用栈的情况</p>
<p><img src="call_stack.webp" /></p>
<p>这里有一个疑惑点，为什么<code>x=3</code>、<code>y=5</code>比<code>sum=0</code>先入栈，翻了翻评论，应该是因为<code>x</code>和<code>y</code>是函数参数，所以先入栈。</p>
<h2 id="栈在表达式求值中的应用">栈在表达式求值中的应用</h2>
<p>栈的另一个应用场景，<strong>表达式求值</strong>。</p>
<p>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p>
<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈(为了拿到下一个操作数)；如果比运算符栈顶元素的优先级低或相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行运算，再把计算完的结果压入操作数栈，继续比较。</p>
<h3 id="后缀逆波兰表达式定义">后缀(逆波兰)表达式定义</h3>
<p><code>9+(3-1)*3+10/2</code>用后缀表示法表示<code>9 3 1 - 3 * 10 2 / +</code></p>
<p>叫后缀的原因在于所有的符号都是在要运算数字的后面出现</p>
<h3 id="后缀表达式计算结果">后缀表达式计算结果</h3>
<p>后缀表达式：<code>9 3 1 - 3 * 10 2 / +</code></p>
<p>规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p>
<h4 id="代码">代码</h4>
<p>待补充...</p>
<h3 id="中缀表达式转后缀表达式">中缀表达式转后缀表达式</h3>
<p>平时所用的标准四则运算表达式，<code>9+(3-1)*3+10/2</code>叫做中缀表达式。</p>
<p>规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p>
<h4 id="代码-1">代码</h4>
<p>待补充...</p>
<h2 id="栈在括号匹配中的应用">栈在括号匹配中的应用</h2>
<p>思路：用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如<code>(</code>和<code>)</code>、<code>[</code>和<code>]</code>、<code>&#123;</code>和<code>&#125;</code>匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p>
<h3 id="代码-2">代码</h3>
<p>待补充...</p>
<h2 id="解答开篇">解答开篇</h2>
<p>如何实现浏览器的前进、后退功能？</p>
<p>思路：使用两个栈，X和Y，我们把首次浏览的页面依次压入栈X，点击后退按钮时，再依次从栈X中出栈，并将出栈的数据依次放入栈Y。当我们点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X没有数据时，那就说明没有页面可以继续后退浏览了。当栈Y中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p>
<h3 id="代码-3">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;LinkedStack.py&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> LinkedStack <span class="keyword">import</span> LinkedStack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewLinkedStack</span>(<span class="params">LinkedStack</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Browser</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 存储要后退的页面</span></span><br><span class="line">        self.x = NewLinkedStack()</span><br><span class="line">        <span class="comment"># 存储要前进的页面</span></span><br><span class="line">        self.y = NewLinkedStack()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">can_forward</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            是否可以前进</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.y.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">can_back</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            是否可以后退</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.x.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            打开页面</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Open new url: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url))</span><br><span class="line">        <span class="comment"># 将浏览过的页面压入栈x</span></span><br><span class="line">        self.x.push(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            后退</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.x.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将浏览过的url从栈x拿出来 实现后退</span></span><br><span class="line">        url = self.x.pop()</span><br><span class="line">        self.y.push(url)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;back: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            前进</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.y.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将后退的页面从栈y拿出来 实现前进</span></span><br><span class="line">        url = self.y.pop()</span><br><span class="line">        self.x.push(url)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;forward: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    browser = Browser()</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> browser.can_back():</span><br><span class="line">        browser.back()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> browser.can_forward():</span><br><span class="line">        browser.forward()</span><br><span class="line"></span><br><span class="line">    browser.back()</span><br><span class="line">    browser.back()</span><br><span class="line">    browser.back()</span><br></pre></td></tr></table></figure>
<h3 id="感受">感受</h3>
<ol type="1">
<li>写这些代码特别锻炼自己抽象能力。</li>
</ol>
<h2 id="课后思考">课后思考</h2>
<ol type="1">
<li><p>为什么函数调用要用栈来保存临时变量？用其他数据结构不行吗？</p>
<p>以下答案来自评论区置顶</p>
<p>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。</p>
<p>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p></li>
<li><p><code>JVM</code>内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储<code>Java</code>中的对象。那么<code>JVM</code>里面的“栈”跟我们这里说的“栈”是不是一回事，如果不是，那它为什么又叫作“栈”呢？</p>
<p>以下答案来自评论区置顶</p>
<p>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。</p>
<p>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区。动态数据区又分为栈区和堆区。</p>
<ul>
<li><p>代码区：存储方法体的二进制代码。高级调度(作业调度)、中级调度(内存调度)、低级调度(进程调度)控制代码区执行代码的切换。</p></li>
<li><p>静态数据区：存储全局变量、静态变量、常量。常量包括<code>final</code>修饰的常量和<code>String</code>常量。系统自动分配和回收。</p></li>
<li><p>动态数据区：</p>
<ul>
<li>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。</li>
<li>堆区：<code>new</code>一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</li>
</ul></li>
</ul></li>
</ol>
<p>参考链接：</p>
<ol type="1">
<li><a href="https://baozoulin.gitbook.io/-data-structure/di-4-zhang-zhan-yu-dui-lie/48zhan-de-ying-yong-2014-2014-si-ze-yun-suan-biao-da-shi-qiu-zhi">栈的应用——四则运算表达式求值</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>线性排序</title>
    <url>/2021/10/17/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>今天来学习三种时间复杂度是<code>O(n)</code>的排序算法：桶排序、计数排序、基数排序。</p>
<span id="more"></span>
<p>因为这些排序算法的时间复杂度是线性的，所以把这类排序算法叫做<strong>线性排序</strong>。之所以能做到线性的时间复杂度，主要原因是，这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。</p>
<p>学习重点是掌握这些排序算法的适用场景。</p>
<h2 id="桶排序">桶排序</h2>
<h3 id="核心思想">核心思想</h3>
<p>将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<p><img src="bucket_sort.webp" /></p>
<h3 id="时间复杂度">时间复杂度</h3>
<p>如果要排序的数据有<code>n</code>个，把它均匀地划分到<code>m</code>个桶内，每个桶里就有<code>k=n/m</code>个元素。每个桶内部使用快速排序，时间复杂度为<code>O(k*logk)</code>。<code>m</code>个桶排序的时间复杂度就是<code>O(m*k*logk)</code>，因为<code>k=n/m</code>，所以整个桶排序的时间复杂度就是<code>O(n*log(n/m))</code>。当桶的个数<code>m</code>接近数据个数<code>n</code>时，<code>log(n/m)</code>就是一个非常小的常量，这个时候桶排序的时间复杂度接近<code>O(n)</code>。</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>空间复杂度为<code>O(n+m)</code>。</p>
<h3 id="稳定性">稳定性</h3>
<p>如果每次桶内使用快速排序，则桶排序是不稳定的。而每次桶内使用归并排序，则桶排序是稳定的排序算法。</p>
<h3 id="前提条件">前提条件</h3>
<p>首先，要排序的数据需要很容易就能划分成<code>m</code>个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</p>
<p>其次，数据在各个桶之间的分布是比较均匀的。</p>
<h3 id="适用场景">适用场景</h3>
<p><strong>桶排序比较适合用在外部排序中。</strong>所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>
<p>比如有10GB的订单数据，希望按订单金额（假设金额都是正整数）进行排序，但是内存有限，只有几百MB，没办法一次性把10GB的数据都加载到内存中，这时候该怎么办？</p>
<p>先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是1元，最大是10万元。我们将所有订单根据金额划分到100个桶里，第一个桶我们存储金额在1元到1000元之间的订单，第二桶存储金额在1001元到2000元之内的订单，以此类推。每个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02...99）。</p>
<p>理想的情况下，如果订单金额在1到10万之间均匀分布，那订单会被均匀划分到100个文件中，每个小文件中存储大约100MB的订单数据，就可以将这100个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。</p>
<p>这里有一个问题，桶的实现方式是文件。还有就是需要注意的是，时间复杂度为<code>O(n)</code>，并不意味着只遍历一次，也可能是两次三次，这里遍历次数很小，系数可以忽略。<code>O(n)</code>指的是程序执行时间随数据规模呈线性关系。</p>
<p>不过，订单按照金额在1元到10万元之间并不一定是均匀分布的，所以10GB订单数据是无法均匀地被划分到100个文件中的。有可能某个金额区间的数据特别多，划分之后对应的文件会很大，没法一次性读入内存。</p>
<p>针对这些划分之后还是比较大的文件，可以继续划分，比如，订单金额在1元到1000元之间的比较多，就将这个区间继续划分为10个小区间，1元到100元，101元到200元...901元到1000元。如果划分之后，101元到200元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。</p>
<h2 id="计数排序">计数排序</h2>
<p><strong>计数排序其实是桶排序的一种特殊情况。</strong>当要排序的<code>n</code>个数据，所处的范围并不大的时候，比如最大值是<code>k</code>，就可以把数据划分成<code>k</code>个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间。计数排序的算法思想跟桶排序非常类似，只是桶的大小粒度不一样。桶排序的粒度是多个，而计数排序的粒度是一个。</p>
<h3 id="适用场景-1">适用场景</h3>
<p>如果所在的省有50万考生，如果通过成绩快速排序得出名次呢？</p>
<p>考生的满分是900分，最小是0分，这个数据的范围很小，所以可以分成901个桶，对应分数从0分到900分。根据考生的成绩，将这50万考生划分到这901个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了50万考生的排序。因为只涉及扫描遍历操作，时间复杂度为<code>O(n)</code>。</p>
<p>和桶排序不同的是，计数排序中桶存的不是元素而是元素的数量。</p>
<h3 id="总结">总结</h3>
<p>计数排序只能用在数据范围不大的场景中，如果数据范围<code>k</code>比要排序的数据<code>n</code>大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
<p>比如，还是拿考生这个例子。如果考生成绩精确到小数后一位，就需要将所有的分数都先乘以10，转化成整数，然后再放到9010个桶内。再比如，如果要排序的数据中有负数，数据的范围是<code>[-1000, 1000]</code>，那我们就需要先对每个数据都加1000，转化成非负整数。</p>
<h2 id="基数排序">基数排序</h2>
<h3 id="适用场景-2">适用场景</h3>
<p>假设有10w个手机号码，希望将这10万个手机号码从小到大排序，有什么比较快速的排序方法？</p>
<p>先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过11次排序之后，手机号码就都有序了。这里按照每位来排序的排序算法必须是稳定的，否则最后一次排序只会考虑最高位的大小顺序，完全不管其他位的大小关系，低位的排序就完全没有意义了。</p>
<p>根据每一位来排序，可以用桶排序或者计数排序，时间复杂度可以做到<code>O(n)</code>。如果要排序的数据有<code>k</code>位，那么就需要<code>k</code>次桶排序或者计数排序，总的时间复杂度是<code>O(k*n)</code>。当<code>k</code>不大的时候，比如手机号码排序的例子，<code>k</code>最大就是11，所以基数排序的时间复杂度近似于<code>O(n)</code>。</p>
<p>当排序的数据不是等长的的时候，可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”，因为根据<code>ASCII</code>值，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续使用基数排序了。</p>
<h3 id="总结-1">总结</h3>
<p>基数排序对要排序的数据是有要求的。需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果<code>a</code>数据的高位比<code>b</code>数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到<code>O(n)</code>了。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>如何根据年龄给100w用户排序？</p>
<p>实际上，根据年龄给100w用户排序，就类似按照成绩给50w考生排序。我们假设年龄的范围最小1岁，最大不超过120岁（或者可以通过遍历看一下年龄范围）。遍历这100w用户，根据年龄将其划分到这120个桶里，然后依次顺序遍历这120个桶中的元素，这样就得到了按照年龄排序的100w用户数据。</p>
<p>那么，这种排序方式是桶排序还是计数排序呢？</p>
<h2 id="课后思考">课后思考</h2>
<p>假设现在需要对<code>D, a, F, B, c, A，z</code>这个字符串进行排序，要求将其中所有小写的字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为<code>a, c, z, D, F, B, A</code>，这个该如何实现呢？如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母的放到后面，数字放在中间，不用排序算法，该怎么解决？</p>
<p>答案一：用两个指针<code>a</code>，<code>b</code>：<code>a</code>指针从头开始往后遍历，遇到大写字母就停下，<code>b</code>从后往前遍历，遇到小写字母就停下，交换<code>a</code>、<code>b</code>指针对应的元素；重复如上过程，直到<code>a</code>、<code>b</code>指针相交。对于小写字母放前面，数字放中间，大写字母放后面，可以先将数据分为小写字母和非小写字母两大类，进行如上交换再在非小写字母区间内分为数字和大写字母做同样处理。</p>
<p>答案二：利用桶排序思想，共小写、大写、数字三个桶，遍历一遍，都放进去，然后再从桶中取出来。时间复杂度为<code>O(n)</code>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>线性排序</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2021/09/27/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>今天来学习递归。</p>
<span id="more"></span>
<h2 id="如何理解递归">如何理解“递归”</h2>
<p>数据结构和算法中两个最难理解的知识点，一个是动态规划，另一个是递归。</p>
<p>递归是一种应用非常广泛的算法(或者编程技巧)。比如，合并两个有序链表、斐波那契数列等等。</p>
<p>去的过程称为“递”，回来的过程称为“归”。</p>
<h2 id="递归需要满足的三个条件">递归需要满足的三个条件</h2>
<ol type="1">
<li>一个问题的解可以分解为几个子问题的解。子问题就是数据规模更小的问题。</li>
<li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。</li>
<li>存在递归终止条件</li>
</ol>
<h2 id="如何编写递归代码">如何编写递归代码</h2>
<p>写递归代码最关键的是<strong>写出递归公式，找到终止条件</strong>。</p>
<p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递归公式，然后再敲定终止条件，最后将递推公式和终止条件翻译为代码。</p>
<p>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</p>
<h2 id="递归代码要警惕堆栈溢出">递归代码要警惕堆栈溢出</h2>
<p>原因：函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>
<p>解决方法：在代码中限制递归调用的最大深度。但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如10、50，就可以用这种方法，否则这种方法并不很实用。</p>
<p>将递归代码改为循环处理以避免堆栈溢出。</p>
<h2 id="递归代码要警惕重复计算">递归代码要警惕重复计算</h2>
<p>为了避免重复计算，可以通过一个数据结构(散列表)来保存已经求解过得<code>f(k)</code>。当递归调用到<code>f(k)</code>时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。</p>
<h2 id="将递归代码改写为非递归代码">将递归代码改写为非递归代码</h2>
<p>递归代码有利有弊，利是递归代码的表达能力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。</p>
<p><code>f(x)=f(x-1)+1</code>改写为非递归代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">n</span>):</span></span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        result = result + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>笼统的讲，所有的递归代码都可以改为迭代循环的非递归写法。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>给定一个用户ID，如何查找这个用户的“最终推荐人”。伪代码如下，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">findRootReferrerId</span><span class="params">(<span class="keyword">long</span> actorId)</span> </span>&#123;</span><br><span class="line">  Long referrerId = select referrer_id from [table] where actor_id = actorId;</span><br><span class="line">  <span class="keyword">if</span> (referrerId == <span class="keyword">null</span>) <span class="keyword">return</span> actorId;</span><br><span class="line">  <span class="keyword">return</span> findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在的问题：</p>
<ol type="1">
<li>递归很深，存在堆栈溢出的风险(限制递归次数)</li>
<li>如果数据库里存在脏数据，还需要处理由此产生的无限递归问题，如何检测环？(限制递归次数、快慢指针检测环)</li>
</ol>
<h2 id="课后思考">课后思考</h2>
<p>对于递归代码，有什么好的调试方法？(答案来自评论区)</p>
<ul>
<li>打印日志发现，递归值</li>
<li>结合条件断点进行调试</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>链表(上)</title>
    <url>/2021/09/16/%E9%93%BE%E8%A1%A8-%E4%B8%8A/</url>
    <content><![CDATA[<p>今天来学习链表(上)。</p>
<span id="more"></span>
<h2 id="引言">引言</h2>
<p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。</p>
<p>缓存大小有限，当缓存被用满时，就涉及到了缓存淘汰策略。</p>
<ol type="1">
<li>先进先出策略<code>FIFO</code>(First In, First Out)</li>
<li>最少使用策略<code>LFU</code>(Least Frequently Used)</li>
<li>最近最少使用策略<code>LRU</code>(Least Recently Used)</li>
</ol>
<p>经典的链表应用场景，<code>LRU</code>缓存淘汰算法。</p>
<h2 id="五花八门的链表结构">五花八门的链表结构</h2>
<h3 id="单链表">单链表</h3>
<p>首先需要搞清几个概念</p>
<ul>
<li>链表结点：存储数据和后继指针的内存块</li>
<li>后继指针：记录下个结点地址的指针</li>
<li>头结点：第一个结点</li>
<li>尾结点：最后一个结点，<strong>指向一个空地址NULL</strong></li>
</ul>
<p>插入删除操作时间复杂度O(1)，随机访问时间复杂度O(n)</p>
<h3 id="循环链表">循环链表</h3>
<p><strong>循环链表是一种特殊的单链表</strong>，它跟单链表唯一的区别就在尾结点。单链表的尾结点指针指向空地址。而循环链表的尾结点指针是指向链表的头结点。</p>
<p>和单链表相比，<strong>循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环形结构特点时，就特别适合采用循环链表，比如著名的约瑟夫问题。</strong>尽管用单链表也可以实现，但使用循环链表实现的话，代码会简洁很多。</p>
<h3 id="双向链表">双向链表</h3>
<p>在实际的软件开发，双向链表更加常用。</p>
<p>单链表只有一个方向，结点只有一个后继指针，<code>next</code>指向后面的结点。而双向链表，它支持两个方向，每个结点不止有一个后继指针<code>next</code>指向后面的结点，还有一个前驱指针<code>prev</code>指向前面的结点。</p>
<p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样带来了双向链表操作的灵活性。</p>
<h4 id="单链表-vs-双向链表">单链表 vs 双向链表</h4>
<p>在实际的软件开发中，从链表删除一个数据无外乎这两种情况：</p>
<ul>
<li>删除结点中“值等于某个给定值”的结点</li>
<li>删除给定指针指向的结点</li>
</ul>
<p>对于第一种情况，无论是单链表和双向链表，都需要遍历查找。所以删除操作的时间复杂度是O(1)，遍历查找的时间复杂度是O(n)，根据加法法则，总的时间复杂度O(n)。</p>
<p>对于第二种情况，由于删除某个结点<code>q</code>需要知道其前驱结点，而单链表并不支持直接获取前驱结点，时间复杂度O(n)；而双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历，时间复杂度O(1)</p>
<p>同理在链表的某个结点前面或者后面插入一个结点，双向链表时间复杂度O(1)；单链表时间复杂度O(n)</p>
<p>除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为双向链表可以记录上次查找的位置<code>p</code>，每次查询时，根据要查询值和位置p的值的大小关系，决定往前查找还是往后查找，所以平均只需要查找一半的数据。</p>
<p><code>Java</code>语言中的<code>LinkedHashMap</code>就用到了双向链表，尽管比较费内存，但是应用比较广泛。</p>
<p>这里面，涉及到一个重要的涉及思想：<strong>空间换时间</strong>。对于执行比较慢的程序，可以通过消耗更多的内存(空间换时间)，来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间(时间换空间)来降低内存的消耗。</p>
<h3 id="双向循环链表">双向循环链表</h3>
<p>概念容易理解，但是代码写起来更复杂了....</p>
<h3 id="数组-vs-链表">数组 vs 链表</h3>
<p>底层结构上：数组连续的内存空间；链表零散的内存块</p>
<p>时间复杂度：</p>
<table>
<thead>
<tr class="header">
<th>时间复杂度</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>插入、删除</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr class="even">
<td>随机访问</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<p>在实际开发中，不能简单的根据时间复杂度来决定使用哪个数据结构来存储数据。</p>
<p>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。</p>
<p>数组的缺点是大小固定，一经声明就要占用整块连续内存。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足”。如果声明的数组过小，则可能出现不够用的情况。这是只能再申请一个更大的内存空间，把原数组拷贝过去，非常耗时。链表本身没有大小的限制，天然地支持动态扩容。这是数组和链表最大的区别</p>
<p>除此之外，如果对内存的使用非常苛刻，那么数组更适合。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>如何基于链表实现LRU缓存淘汰算法？</p>
<p>思路：维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历单链表。</p>
<ol type="1">
<li>如果此数据之前已经被缓存在链表中，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li>
<li>如果此数据没有在缓存链表中，又可以分为两种情况：
<ul>
<li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li>
<li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li>
</ul></li>
</ol>
<p>时间复杂度O(n)</p>
<p>思考：如何利用数组来实现LRU缓存淘汰策略？</p>
<h2 id="思考">思考</h2>
<p>如何判断一个字符串是否是回文字符串的问题？</p>
<p>这个问题考查了两个知识点：</p>
<ol type="1">
<li>快慢指针</li>
<li>反转相邻结点</li>
</ol>
<p>花了一个下午写了关于链表的一些基本操作—。—，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  	单链表-结点</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data, next_node=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = next_node</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  	单链表</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__head = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_by_value</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            根据value在链表中查找</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.__head</span><br><span class="line">        <span class="keyword">while</span> (node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (node.data != value):</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_by_index</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            根据index在链表中查找</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.__head</span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (pos != index):</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_to_head</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            头结点插入</span></span><br><span class="line"><span class="string">            时间复杂度O(1)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.<span class="built_in">next</span> = self.__head</span><br><span class="line">        self.__head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_after</span>(<span class="params">self, node, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            在链表的某个指定Node节点之后插入一个存储value数据的Node节点</span></span><br><span class="line"><span class="string">            时间复杂度O(1)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 如果在空结点之后插入数据结点 则什么都不做</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        new_node = Node(value)</span><br><span class="line"></span><br><span class="line">        new_node.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span> = new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_before</span>(<span class="params">self, node, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            在链表的某个指定Node节点之前插入一个存储value数据的Node节点</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 如果在空结点之前或者空链表之前插入结点 则什么都不做</span></span><br><span class="line">        <span class="keyword">if</span> (node <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (self.__head <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 头结点插入</span></span><br><span class="line">        <span class="keyword">if</span> node == self.__head:</span><br><span class="line">            self.insert_to_head(value)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        new_node = Node(value)</span><br><span class="line">        pos = self.__head</span><br><span class="line">        <span class="comment"># 注意：判断node是否存在链表中</span></span><br><span class="line">        not_found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> pos.<span class="built_in">next</span> != node:</span><br><span class="line">            <span class="keyword">if</span> pos.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                not_found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            pos = pos.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> not_found:</span><br><span class="line">            pos.<span class="built_in">next</span> = new_node</span><br><span class="line">            new_node.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_by_node</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            在链表中删除指定Node的节点</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 空链表 什么都不做</span></span><br><span class="line">        <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 删除头结点 头结点后移</span></span><br><span class="line">        <span class="keyword">if</span> node == self.__head:</span><br><span class="line">            self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        pos = self.__head</span><br><span class="line">        not_found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> pos.<span class="built_in">next</span> != node:</span><br><span class="line">            <span class="keyword">if</span> pos.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                not_found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            pos = pos.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> not_found:</span><br><span class="line">            pos.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_by_value</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            在链表中删除指定存储数据的Node节点</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.__head.data == value:</span><br><span class="line">            self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里用到了pre结点 因为删除指定value结点时候需要用到前一个结点</span></span><br><span class="line">        pre = self.__head</span><br><span class="line">        node = self.__head.<span class="built_in">next</span></span><br><span class="line">        not_found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> node.data != value:</span><br><span class="line">            <span class="keyword">if</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                not_found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            pre = node</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> not_found:</span><br><span class="line">            pre.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_last_n_node</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            删除链表中倒数第N个节点</span></span><br><span class="line"><span class="string">            主要思路：</span></span><br><span class="line"><span class="string">                设置快、慢两个指针，快指针先行，慢指针不动；当快指针走了N步时，快慢指针同时向链表尾部移动，</span></span><br><span class="line"><span class="string">                当快指针到达链表尾部时，慢指针指向的就是链表倒数第N个结点(脑子绕不过弯来时，画画图就明白了)</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            ** 单链表删除结点的时候，一定要注意保存被删除结点的前驱结点</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast = self.__head</span><br><span class="line">        slow = self.__head</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> step &lt;= n:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        tmp = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            tmp = slow</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        tmp.<span class="built_in">next</span> = slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_mid_node</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            查找链表中的中间节点</span></span><br><span class="line"><span class="string">            主要思想：</span></span><br><span class="line"><span class="string">                设置快慢指针，快指针每次跨两步，满指针每次跨一步，则当快指针到达链表尾部的时候，慢指针指向链表的中间结点</span></span><br><span class="line"><span class="string">                同理 脑子绕不过弯时，画画图就明白了</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast = self.__head</span><br><span class="line">        slow = self.__head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单链表个数局限为奇数</span></span><br><span class="line">        <span class="comment"># while (fast.next is not None):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单链表个数为奇数或者偶数可以</span></span><br><span class="line">        <span class="keyword">while</span> (fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_node</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            创建一个存储value值的Node节点</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> Node(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_all</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            打印当前链表所有节点数据</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        node = self.__head</span><br><span class="line">        <span class="keyword">while</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(node.data, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 打印最后一个结点</span></span><br><span class="line">        <span class="built_in">print</span>(node.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversed_self</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            翻转链表</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pre = self.__head</span><br><span class="line">        node = self.__head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 结束条件 pre为链表最后一个结点 node为None</span></span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            pre, node = self.__reversed_with_two_node(pre, node)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 修改尾结点和头结点</span></span><br><span class="line">        self.__head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.__head = pre</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed_with_two_node</span>(<span class="params">self, pre, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            翻转相邻两个结点</span></span><br><span class="line"><span class="string">            思路：利用一个中间结点tmp</span></span><br><span class="line"><span class="string">        :return: node, node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 保存node的下一个结点</span></span><br><span class="line">        tmp = node.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 修改node指针</span></span><br><span class="line">        node.<span class="built_in">next</span> = pre</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这两行的意思应该是后移结点</span></span><br><span class="line">        pre = node</span><br><span class="line">        node = tmp</span><br><span class="line">        <span class="keyword">return</span> pre, node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_ring</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            检测是否有环</span></span><br><span class="line"><span class="string">            主要思想：</span></span><br><span class="line"><span class="string">                设置快、慢两个指针，快指针每次跨两步、慢指针每次跨一步，</span></span><br><span class="line"><span class="string">                如果快指针没有与慢指针相遇而是顺利到达链表尾部，说明没有环，反之存在环</span></span><br><span class="line"><span class="string">                自己画画图看看 就明白了</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: True or False</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast = self.__head</span><br><span class="line">        slow = self.__head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当链表为空或者只有一个结点时，直接返回False</span></span><br><span class="line">        <span class="keyword">while</span> (fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_head</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            根据给的结点，翻转之后的结点</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        reverse_head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            next_node = head.<span class="built_in">next</span></span><br><span class="line">            head.<span class="built_in">next</span> = reverse_head</span><br><span class="line">            reverse_head = head</span><br><span class="line">            head = next_node</span><br><span class="line">        <span class="keyword">return</span> reverse_head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            判断是否是回文串</span></span><br><span class="line"><span class="string">            主要思路：快、慢两个指针，快指针每次前进两步、慢指针每次前进一步。当快指针到达链表尾部时，慢指针到达链表中间节点，翻转慢指针到链表尾部的这部分结										点，然后依次对比链表头部和翻转后的部分链表数据是否相同</span></span><br><span class="line"><span class="string">        :return: True or False</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow = self.__head</span><br><span class="line">        fast = self.__head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        head_a = self.__head</span><br><span class="line">        head_b = self.reverse_head(slow)</span><br><span class="line"></span><br><span class="line">        is_palin = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> head_a <span class="keyword">and</span> head_b:</span><br><span class="line">            <span class="keyword">if</span> head_a.data == head_b.data:</span><br><span class="line">                head_a = head_a.<span class="built_in">next</span></span><br><span class="line">                head_b = head_b.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                is_palin = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> is_palin</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>写链表代码时有几点感受：</p>
<ol type="1">
<li>在删除链表结点的时候一定要注意利用中间变量保存前驱结点</li>
<li>快慢指针法在链表中有着广泛的应用，比如说查找中间结点、检测链表是否包含环、判断是否为回文串、删除链表倒数第N个结点等等。</li>
<li>多写多练</li>
</ol>
<p>参考链接：</p>
<ol type="1">
<li><a href="https://github.com/wangzheng0822/algo">数据结构与算法之美相关代码</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表(下)</title>
    <url>/2021/09/17/%E9%93%BE%E8%A1%A8-%E4%B8%8B/</url>
    <content><![CDATA[<p>链表这块知识理解起来简单，代码实现起来，容易出错，谁写谁知道，所以就有了链表(下)。</p>
<span id="more"></span>
<h2 id="写链表代码的技巧">写链表代码的技巧</h2>
<h3 id="理解指针或引用的含义">理解指针或引用的含义</h3>
<p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针里存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p>
<p>指针，英文定义，<code>A pointer is a variable whose value is the address of another variable.</code></p>
<h3 id="警惕指针丢失和内存泄漏">警惕指针丢失和内存泄漏</h3>
<p>比如，在<code>a</code>、<code>b</code>两个结点之间插入一个结点<code>c</code>，一定是先执行<code>c-&gt;next=a-&gt;next</code>，先把结点<code>c</code>指向结点<code>b</code>，然后再将结点<code>a</code>指向结点<code>c</code>，即<code>a-&gt;next=c</code>。如果顺序颠倒了，就会造成结点<code>b</code>的丢失，链表分成了两半，进而造成内存泄漏。因此，<strong>在插入结点时，一定要注意操作的顺序</strong>。</p>
<p><strong>删除链表结点时，也一定要记得手动释放内存空间</strong>，否则也会出现内存泄漏的情况。当然，对于像<code>Java</code>这种虚拟机自动管理内存的编程语言来说，就不需要考虑那么多了。</p>
<h3 id="利用哨兵简化实现难度">利用哨兵简化实现难度</h3>
<p>非哨兵模式下链表的插入，比如在<code>p</code>结点后插入一个新结点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常情况</span></span><br><span class="line">new_node.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">p.<span class="built_in">next</span> = new_node</span><br><span class="line"><span class="comment"># 边界情况，比如向空链表中插入第一个结点</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">None</span>)&#123;head = new_node&#125;</span><br></pre></td></tr></table></figure>
<p>非哨兵模式下链表的删除，比如删除结点<code>p</code>的后继结点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常情况</span></span><br><span class="line">p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"><span class="comment"># 边界情况，比如删除最后一个结点</span></span><br><span class="line">p.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p><strong>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。</strong></p>
<p>为了解决边界问题，引入哨兵结点。</p>
<p>哨兵结点，结点本身不存储数据，指定链表头结点，称为新的头结点，如图所示，</p>
<p><img src="sentinel.webp" /></p>
<p>带有哨兵结点的链表叫<strong>带头链表</strong>；没有哨兵结点的链表叫做<strong>不带头链表</strong>。</p>
<p>因为哨兵结点一直存在，所以插入第一个节点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑。</p>
<p>不信的话，自己画画图，理解一下代码，发现确实是真的耶</p>
<h3 id="重点留意边界条件处理">重点留意边界条件处理</h3>
<p>检查链表代码是否正确的边界条件有这样几个：</p>
<ul>
<li>如果链表为空时，代码是否能正常工作</li>
<li>如果链表只包含一个结点时，代码是否能正常工作</li>
<li>如果链表只包含两个结点时，代码是否能正常工作</li>
<li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作</li>
</ul>
<h3 id="举例画图辅助思考">举例画图，辅助思考</h3>
<p>举例法和画图法</p>
<h3 id="多写多练没有捷径">多写多练，没有捷径</h3>
<p>5个常见的链表操作</p>
<ul>
<li>单链表反转</li>
<li>链表中环的检测</li>
<li>两个有序的链表合并</li>
<li>删除链表倒数第n个结点</li>
<li>求链表的中间结点</li>
</ul>
<p>其实除了两个有序的链表合并，其余的在链表上(上)都写过了，总结起来就是1.快慢指针2.反转相邻的结点。上节课后思考判断回文串这一道题目就把这两个知识点都考查到了，简直是妙啊！</p>
<h2 id="课后思考">课后思考</h2>
<p>哨兵模式在其他场景上的应用。</p>
<p>暂时没想到，后续用到了再来补充吧=.=</p>
<h2 id="合并两个有序链表">合并两个有序链表</h2>
<h3 id="遍历实现">遍历实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sorted_list</span>(<span class="params">l1: Node, l2: Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        合并两个有序链表</span></span><br><span class="line"><span class="string">        时间复杂度O(m)+O(n)</span></span><br><span class="line"><span class="string">    :param l1: 链表1头结点</span></span><br><span class="line"><span class="string">    :param l2: 链表2头结点</span></span><br><span class="line"><span class="string">    :return: 合并后链表的头结点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    node = Node(data=-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 需要一个变量保存头结点</span></span><br><span class="line">    head = node</span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.data &lt;= l2.data:</span><br><span class="line">            node.<span class="built_in">next</span> = l1</span><br><span class="line">            <span class="comment"># 后移链表1结点</span></span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = l2</span><br><span class="line">            <span class="comment"># 后移链表2结点</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        node = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并 未合并完的链表</span></span><br><span class="line">    node.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">    <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = SingleLinkedList()</span><br><span class="line"></span><br><span class="line">    s.insert_to_head(<span class="number">5</span>)</span><br><span class="line">    s.insert_to_head(<span class="number">3</span>)</span><br><span class="line">    s.insert_to_head(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    p = SingleLinkedList()</span><br><span class="line">    p.insert_to_head(<span class="number">6</span>)</span><br><span class="line">    p.insert_to_head(<span class="number">5</span>)</span><br><span class="line">    p.insert_to_head(<span class="number">4</span>)</span><br><span class="line">    p.insert_to_head(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    q = merge_sorted_list(s.get_head_node(), p.get_head_node())</span><br></pre></td></tr></table></figure>
<h3 id="递归实现">递归实现</h3>
<p>代码先放到这，等学完递归在回过头来看。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sorted_list2</span>(<span class="params">l1: Node, l2: Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        合并两个有序链表</span></span><br><span class="line"><span class="string">        主要思路：</span></span><br><span class="line"><span class="string">        	list1[0] + merge(list1[1], list2[0]) 当list1[0]&lt;list2[0]</span></span><br><span class="line"><span class="string">          list2[0] + merge(list1[0], list2[1]) otherwise</span></span><br><span class="line"><span class="string">    :param l1: 链表1头结点</span></span><br><span class="line"><span class="string">    :param l2: 链表2头结点</span></span><br><span class="line"><span class="string">    :return: 合并后链表的头结点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l2:</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1.data &lt;= l2.data:</span><br><span class="line">        l1.<span class="built_in">next</span> = merge_sorted_list(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l2.<span class="built_in">next</span> = merge_sorted_list(l1, l2.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>
<h2 id="lru缓存算法">LRU缓存算法</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.key = x</span><br><span class="line">        self.value = y</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cap = capacity</span><br><span class="line">        <span class="comment"># 存储key和node</span></span><br><span class="line">        self.hkeys = &#123;&#125;</span><br><span class="line">        <span class="comment"># 哨兵结点 避免考虑边界问题</span></span><br><span class="line">        self.top = Node(<span class="literal">None</span>, -<span class="number">1</span>)</span><br><span class="line">        self.tail = Node(<span class="literal">None</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.top.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.top</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hkeys.keys():</span><br><span class="line">            <span class="comment"># 1.获取结点</span></span><br><span class="line">            cur = self.hkeys[key]</span><br><span class="line">            <span class="comment"># 2.从当前位置拿出</span></span><br><span class="line">            cur.prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span>.prev = cur.prev</span><br><span class="line">            <span class="comment"># 3.放到链表头部</span></span><br><span class="line">            <span class="comment"># 3.1 保存top后面的结点</span></span><br><span class="line">            tmp = self.top.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 3.2 top和cur绑定</span></span><br><span class="line">            self.top.<span class="built_in">next</span> = cur</span><br><span class="line">            cur.prev = self.top</span><br><span class="line">            <span class="comment"># 3.3 cur和tmp绑定</span></span><br><span class="line">            cur.<span class="built_in">next</span> = tmp</span><br><span class="line">            tmp.prev = cur</span><br><span class="line">            <span class="keyword">return</span> self.hkeys[key].value</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hkeys.keys():</span><br><span class="line">            <span class="comment"># 1.获取结点</span></span><br><span class="line">            cur = self.hkeys[key]</span><br><span class="line">            <span class="comment"># 修改value值</span></span><br><span class="line">            cur.value = value</span><br><span class="line">            <span class="comment"># 2.跳出原位置</span></span><br><span class="line">            cur.prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span>.prev = cur.prev</span><br><span class="line">            <span class="comment"># 3.将cur放到头结点</span></span><br><span class="line">            top_node = self.top.<span class="built_in">next</span></span><br><span class="line">            self.top.<span class="built_in">next</span> = cur</span><br><span class="line">            cur.prev = self.top</span><br><span class="line">            cur.<span class="built_in">next</span> = top_node</span><br><span class="line">            top_node.prev = cur</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.hkeys.keys()) &gt; self.cap:</span><br><span class="line">                <span class="comment"># 从哈希表删除key</span></span><br><span class="line">                self.hkeys.pop(self.tail.prev.key)</span><br><span class="line">                <span class="comment"># 去掉了后继指针</span></span><br><span class="line">                self.tail.prev.prev.<span class="built_in">next</span> = self.tail</span><br><span class="line">                <span class="comment"># 修改尾结点前驱指针，self.tail.prev.prev有点懵的</span></span><br><span class="line">                self.tail.prev = self.tail.prev.prev</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 新增结点</span></span><br><span class="line">            cur = Node(key, value)</span><br><span class="line">            self.hkeys[key] = cur</span><br><span class="line">            <span class="comment"># 最近用过的放到链表头部</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                我第一次写的</span></span><br><span class="line"><span class="string">                cur.next = self.top.next</span></span><br><span class="line"><span class="string">                self.top.prev = cur</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">                self.top.next = cur</span></span><br><span class="line"><span class="string">                cur.prev = self.top</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># 利用tmp保留top下一个结点</span></span><br><span class="line">            tmp = self.top.<span class="built_in">next</span>  </span><br><span class="line">            cur.<span class="built_in">next</span> = tmp</span><br><span class="line">            tmp.prev = cur</span><br><span class="line"></span><br><span class="line">            self.top.<span class="built_in">next</span> = cur</span><br><span class="line">            cur.prev = self.top</span><br></pre></td></tr></table></figure>
<h3 id="感受">感受</h3>
<ol type="1">
<li><p>写起来好像也没想象中那么难，可能是因为用到哨兵结点，不需要考虑边界问题。</p></li>
<li><p>主要操作包括：结点从当前位置取出、头部插入结点。</p></li>
<li><p>操作之间不需要考虑先后顺序，比如结点跳出原位置，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 结点跳出原位置</span></span><br><span class="line">cur.<span class="built_in">next</span>.prev = cur.prev</span><br><span class="line">cur.prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链表头部插入结点</span></span><br><span class="line">tmp = self.top.<span class="built_in">next</span></span><br><span class="line">cur.<span class="built_in">next</span> = tmp</span><br><span class="line">tmp.prev = cur</span><br><span class="line"></span><br><span class="line">self.top.<span class="built_in">next</span> = cur</span><br><span class="line">cur.prev = self.top</span><br></pre></td></tr></table></figure>
<p>于是，为了验证这个观点，写一个简单的双向链表<code>demo</code>验证一下，无论怎么更换<code>insert_node_from_head()</code>方法中后四行代码的顺序，结果都是一样的。如果有不对的地方，欢迎指教哈=。=</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoWayLoop</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = Node(value=-<span class="number">1</span>)</span><br><span class="line">        self.tail = Node(value=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.top.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.top</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_node_from_head</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value=value)</span><br><span class="line"></span><br><span class="line">        tmp = self.top.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        tmp.prev = node</span><br><span class="line">        node.prev = self.top</span><br><span class="line">        self.top.<span class="built_in">next</span> = node</span><br><span class="line">        node.<span class="built_in">next</span> = tmp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_node</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            暂时没想好怎么写</span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.top.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_all</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node.<span class="built_in">next</span>:</span><br><span class="line">            <span class="built_in">print</span>(node.value)</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = TwoWayLoop()</span><br><span class="line"></span><br><span class="line">    t.insert_node_from_head(<span class="number">4</span>)</span><br><span class="line">    t.insert_node_from_head(<span class="number">3</span>)</span><br><span class="line">    t.insert_node_from_head(<span class="number">2</span>)</span><br><span class="line">    t.insert_node_from_head(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    t.print_all()  <span class="comment"># 1-&gt;2-&gt;3-&gt;4</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="附获取类对象的私有属性">附：获取类对象的私有属性</h2>
<p>在合并两个有序链表中，需要获取链表的头结点。上篇文章代码中，单链表的<code>SingleLinkedList</code>中的头结点初始化时定义为私有属性<code>self.__head=None</code>，如果直接通过实例对象获取<code>__head</code>会抛出<code>AttributeError</code>异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__head = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  s = SingleLinkedList()</span><br><span class="line">  s.insert_to_head(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(s.__head)  <span class="comment"># AttributeError: &#x27;SingleLinkedList&#x27; object has no attribute &#x27;__head&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="正确的打开方式">正确的打开方式</h3>
<ol type="1">
<li>通过定义一个方法获取私有属性</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__head = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_head_node</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.__head</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  s = SingleLinkedList()</span><br><span class="line">  s.insert_to_head(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(s.get_head_node().data)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>通过<code>property</code>将方法转化为属性</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__head = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_head_node</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.__head</span><br><span class="line"></span><br><span class="line">  head = <span class="built_in">property</span>(get_head_node)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  s = SingleLinkedList()</span><br><span class="line">  s.insert_to_head(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(s.head.data)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>通过<code>property</code>装饰器</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__head = <span class="literal">None</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span>(<span class="params">self</span>):</span></span><br><span class="line">  	<span class="keyword">return</span> self.__head</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  s = SingleLinkedList()</span><br><span class="line">  s.insert_to_head(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(s.head.data)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<p>参考链接：</p>
<ol type="1">
<li><a href="https://zhuanlan.zhihu.com/p/53469919">python变量——单下划线和双下划线</a></li>
<li><a href="https://www.runoob.com/python/python-func-property.html">Python property() 函数</a></li>
<li><a href="https://blog.csdn.net/z_feng12489/article/details/106105227">合并两个有序链表（python）</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2021/09/24/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>今天来学习队列。</p>
<span id="more"></span>
<h2 id="如何理解队列">如何理解“队列”</h2>
<p>先进者先出，就是典型的“队列”。基本操作包括：入队和出队。</p>
<p>队列跟栈一样，也是一种操作受限的线性表数据结构。</p>
<p>队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列<code>Disruptor</code>、<code>Linux</code>环形缓存，都用到了循环并发队列；<code>Java concurrent</code>并发包利用<code>ArrayBlockingQueue</code>来实现公平锁等。</p>
<h2 id="顺序队列和链式队列">顺序队列和链式队列</h2>
<p>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫做顺序栈，用链表实现的栈叫做链式栈。同样，用数组实现的队列叫做<strong>顺序队列</strong>，用链表实现的队列叫做<strong>链式队列</strong>。</p>
<h3 id="顺序队列实现">顺序队列实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.items = []</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.head = <span class="number">0</span></span><br><span class="line">        self.tail = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, item: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            入队</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.tail == self.capacity:</span><br><span class="line">            <span class="comment"># 说明队列已满</span></span><br><span class="line">            <span class="keyword">if</span> self.head == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># self.tail指向数据下一个index</span></span><br><span class="line">            <span class="comment"># self.head=2 self.tail=7 执行5次数据搬移操作</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.tail - self.head):</span><br><span class="line">                <span class="comment"># 数据搬移操作</span></span><br><span class="line">                self.items[i] = self.items[self.head + i]</span><br><span class="line">            <span class="comment"># 修改队首 队尾</span></span><br><span class="line">            self.tail = self.tail - self.head</span><br><span class="line">            self.head = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.items.insert(self.tail, item)</span><br><span class="line">        self.tail += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            出队</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 队列为空</span></span><br><span class="line">        <span class="keyword">if</span> self.tail == self.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        item = self.items[self.head]</span><br><span class="line">        self.head += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> self.items[self.head: self.tail])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    q = ArrayQueue(<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">8</span>):</span><br><span class="line">        q.enqueue(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(q)</span><br><span class="line">    <span class="comment"># self.head=0 self.tail=7</span></span><br><span class="line"></span><br><span class="line">    q.dequeue()</span><br><span class="line">    q.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(q)</span><br><span class="line">    <span class="comment"># self.head=2 self.tail=7</span></span><br><span class="line"></span><br><span class="line">    q.enqueue(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    q.enqueue(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(q)</span><br></pre></td></tr></table></figure>
<h3 id="链式队列实现">链式队列实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.tail:</span><br><span class="line">            self.tail.<span class="built_in">next</span> = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.head = node</span><br><span class="line">        self.tail = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.head:</span><br><span class="line">            item = self.head.data</span><br><span class="line">            <span class="comment"># 后移head</span></span><br><span class="line">            self.head = self.head.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 只有一个元素时</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">                self.tail = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        values = []</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            values.append(current.data)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;-&gt;&#x27;</span>.join([value <span class="keyword">for</span> value <span class="keyword">in</span> values])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lq = LinkedQueue()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        lq.enqueue(<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(lq)</span><br><span class="line"></span><br><span class="line">    lq.dequeue()</span><br><span class="line">    lq.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(lq)</span><br><span class="line"></span><br><span class="line">    lq.enqueue(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    lq.enqueue(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(lq)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="感受">感受</h3>
<p>多画图来分析</p>
<h2 id="循环队列">循环队列</h2>
<p><strong>确定好队空和队满的判定条件。</strong></p>
<p>用数组实现的非循环队列中，队满的判断条件是<code>tail == n</code>，队空的判断条件是<code>head == tail</code></p>
<p>用数组实现的循环队列中，队空的判断条件是<code>head == tail</code>，<strong>队满的判断条件是<code>(tail+1)%n=head</code></strong></p>
<h3 id="示例代码">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        self.items = []</span><br><span class="line">        <span class="comment"># 循环队列会浪费一个数组的存储空间</span></span><br><span class="line">        self.capacity = capacity + <span class="number">1</span></span><br><span class="line">        self.head = <span class="number">0</span></span><br><span class="line">        self.tail = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (self.tail + <span class="number">1</span>) % self.capacity == self.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line">        self.tail = (self.tail + <span class="number">1</span>) % self.capacity</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.tail == self.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        value = self.items[self.head]</span><br><span class="line">        self.head = (self.head+<span class="number">1</span>) % self.capacity</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.tail &gt;= self.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> self.items[self.head: self.tail])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> chain(self.items[self.head:], self.items[:self.tail]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = CircularQueue(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        q.enqueue(<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 0 1 2 3 4</span></span><br><span class="line">    q.dequeue()</span><br><span class="line">    q.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 2 3 4</span></span><br><span class="line">    q.enqueue(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 2 3 4 5</span></span><br><span class="line">    q.enqueue(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 2 3 4 5 5 0</span></span><br></pre></td></tr></table></figure>
<p>这是<code>https://github.com/wangzheng0822/algo/blob/master/python/09_queue/circular_queue.py</code>里面的代码，我在最后又加了一次入队<code>enqueue(str(5))</code>，发现结果不是自己预料的那样，输出<code>2 3 4 5 5</code>，而是输出了<code>2 3 4 5 5 0</code>。</p>
<p>经过画图以及调试分析，发现直接原因是<code>__repr__</code>里面当<code>self.tail &lt; self.head</code>时输出对象的问题。</p>
<p>根本原因是在初始化的时候，<code>self.items = []</code>以及<code>enqueue()</code>中<code>self.items.append(item)</code>。</p>
<h3 id="正确代码">正确代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        self.capacity = capacity + <span class="number">1</span></span><br><span class="line">				<span class="comment"># 初始化固定长度的列表</span></span><br><span class="line">        self.items = [<span class="literal">None</span>] * self.capacity</span><br><span class="line">        self.head = <span class="number">0</span></span><br><span class="line">        self.tail = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (self.tail + <span class="number">1</span>) % self.capacity == self.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        self.items[self.tail] = item</span><br><span class="line">        self.tail = (self.tail + <span class="number">1</span>) % self.capacity</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.tail == self.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        value = self.items[self.head]</span><br><span class="line">        self.head = (self.head + <span class="number">1</span>) % self.capacity</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.tail &gt;= self.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> self.items[self.head: self.tail])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> chain(self.items[self.head:], self.items[: self.tail]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = CircularQueue(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        q.enqueue(<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 0 1 2 3 4</span></span><br><span class="line">    q.dequeue()</span><br><span class="line">    q.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 2 3 4</span></span><br><span class="line">    q.enqueue(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 2 3 4 5</span></span><br><span class="line">    q.enqueue(<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 2 3 4 5 6</span></span><br><span class="line">    q.dequeue()  <span class="comment"># 3 4 5 6</span></span><br><span class="line">    q.enqueue(<span class="built_in">str</span>(<span class="number">7</span>))</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 3 4 5 6 7</span></span><br></pre></td></tr></table></figure>
<h2 id="阻塞队列和并发队列">阻塞队列和并发队列</h2>
<h3 id="阻塞队列">阻塞队列</h3>
<p>阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>
<p>通过阻塞队列，可以实现一个“生产者-消费者模型”</p>
<h3 id="并发队列">并发队列</h3>
<p>线程安全的队列称为并发队列。最简单的实现方式是直接在<code>enqueue()</code>、<code>dequeue()</code>方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用<code>CAS</code>原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的？</p>
<ol type="1">
<li>非阻塞的处理方式，直接拒绝任务请求。</li>
<li>阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。
<ul>
<li>基于链表的实现方式，可以实现一个支持无限排队的无界队列，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</li>
<li>基于数组实现的有界队列，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源，发挥最大性能。</li>
</ul></li>
</ol>
<p>实际上，对于大部分资源有限的场景，当没有空闲资源时，基本都可以通过“队列”这种数据结构来实现请求排队。</p>
<h2 id="课后思考">课后思考</h2>
<ol type="1">
<li><p>还有哪些类似的池结构或者场景中会用到队列的排队请求？</p>
<p><code>redis</code>连接池；<code>kafka</code>、<code>RabbitMQ</code>等消息队列</p></li>
<li><p>如何实现无锁并发队列？</p>
<p>可以使用<code>CAS</code>+数组的方式来实现</p></li>
</ol>
<p>参考链接：</p>
<ol type="1">
<li><a href="https://www.jianshu.com/p/bae9e0b0a91c">Python实现循环队列（基于list）</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>队列</tag>
      </tags>
  </entry>
</search>
