<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>adb常用命令</title>
    <url>/2021/10/09/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>在安卓逆向过程中，经常会用到<code>adb</code>命令，本篇将记录一些<code>adb</code>命令，但自己又记不住的。</p>
<span id="more"></span>
<ol type="1">
<li><p>查看顶层的<code>activity</code>，这个命令我经常用来查看<code>App</code>包名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity top | grep ACTIVITY</span><br></pre></td></tr></table></figure></li>
<li><p>截图。将图片保存到<code>/sdcard</code>路径下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/screen.png</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>安卓逆向</category>
      </categories>
      <tags>
        <tag>adb命令</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找(上)</title>
    <url>/2021/10/20/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%B8%8A/</url>
    <content><![CDATA[<p>今天学习二分查找。</p>
<span id="more"></span>
<h2 id="定义">定义</h2>
<p>二分查找针对的是一个<strong>有序的数据集合</strong>，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。</p>
<h2 id="时间复杂度">时间复杂度</h2>
<p>假设数据大小是<code>n</code>，每次查找后数据都会缩小为原来的一半，也就是会除以2。最坏情况下，直到查找区间被缩小为空，才停止。被查找区间的大小变化：</p>
<p><span class="math display">\[
n, \frac{n}{2}, \frac{n}{4}, \frac{n}{8},...\frac{n}{2^k}...
\]</span> 其中， <span class="math display">\[
当\frac{n}{2^k}=1时，
\]</span> <code>k</code>的值就是缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了<code>k</code>次区间缩小操作，时间复杂度就是<span class="math inline">\(O(k)\)</span>。通过<span class="math inline">\(\frac{n}{2^k}=1\)</span>，得到<span class="math inline">\(k=log_2n\)</span>，所以时间复杂度就是<span class="math inline">\(O(logn)\)</span>。</p>
<p>常量级时间复杂度的算法有时候可能还没有<span class="math inline">\(O(logn)\)</span>的算法执行效率高。比如，<span class="math inline">\(O(1)\)</span>有可能表示的是一个非常大的常量值，比如<span class="math inline">\(O(1000)\)</span>，<span class="math inline">\(O(10000)\)</span>。而<code>logn</code>即使<code>n</code>非常非常大，对应的<code>logn</code>也很小。比如，<code>n</code>等于2的32次方，大约是42亿，也就是说，如果在42亿个数据中用二分查找一个数据，最多需要比较32次。</p>
<h2 id="实现">实现</h2>
<h3 id="非递归">非递归</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        <span class="comment"># mid = low + ((high - low) &gt;&gt; 1)</span></span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt;= target:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    <span class="built_in">print</span>(binary_search(nums=a, target=<span class="number">2</span>))  <span class="comment"># 1</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search(nums=a, target=<span class="number">3</span>))  <span class="comment"># 2</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search(nums=a, target=<span class="number">11</span>))  <span class="comment"># -1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="递归">递归</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search_by_recursion</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line"></span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> binary_search(nums[mid+<span class="number">1</span>:], target)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> binary_search(nums[:mid-<span class="number">1</span>], target)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line">    <span class="built_in">print</span>(binary_search_by_recursion(nums=a, target=<span class="number">2</span>))  <span class="comment"># 1</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search_by_recursion(nums=a, target=<span class="number">3</span>))  <span class="comment"># 3</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search_by_recursion(nums=a, target=<span class="number">10</span>))  <span class="comment"># -1</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="易错点">易错点</h3>
<ol type="1">
<li><p>循环退出条件</p>
<p>注意是<code>low&lt;=high</code>，而不是<code>low&lt;high</code>。当<code>low=high</code>时，如果此时刚好<code>a[low]=a[high]=target</code>，加上终止条件<code>low&lt;high</code>退出循环，导致查找失败。</p></li>
<li><p><code>mid</code>的取值</p>
<p>实际上，<code>mid=(low+high)//2</code>这种写法是有问题的。因为如果<code>low</code>和<code>high</code>比较大的话，两者之和就有可能溢出。改进的方法是将<code>mid</code>的计算方式写成<code>low+(high-low)//2</code>。更进一步，如果要将性能优化到极致的话，可以将除以2操作转化成位运算<code>low+(high-low)&gt;&gt;1</code>。因为相比除法运算来说，计算机处理位运算要快得多。</p>
<p>为什么右移一位相当于除以2，左移一位相当于乘以2？以十进制数举例。如136，左移一位后，空出的位置用0填补，左移一位相当于把小数点右移一位，就变成了1360，相当于<code>136*10</code>；同理，136右移一位后，移出的位舍去，就变成了13，相当于136/10。因此，十进制左移一位相当于乘以10，右移一位相当于除以10。对于二进制的移位操作同样适用。</p></li>
<li><p><code>low</code>和<code>high</code>的更新</p>
<p><code>low=mid+1</code>，<code>high=mid-1</code>。注意这里的<code>+1</code>和<code>-1</code>，如果直接写成<code>low=mid</code>或者<code>high=mid</code>，就可能会发生死循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            low = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    <span class="built_in">print</span>(binary_search(nums=a, target=<span class="number">3</span>))  <span class="comment"># 出现死循环</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="局限性">局限性</h2>
<ol type="1">
<li><p>二分查找依赖的是顺序表结构，简单点说就是数组。主要原因是二分查找算法需要按照下标随机访问元素。二分查找只能用在数据是通过顺序表来存储的数据结构上。</p></li>
<li><p>二分查找针对的是有序数据。二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景。针对动态变化的数据集合，二分查找将不再使用。</p></li>
<li><p>数据量太小不适合二分查找。</p>
<p>如果要处理的数据量很小，完全没必要用二分查找，顺序遍历就足够了。</p>
<p>如果数据之间的比较操作非常耗时，不管数据量大小，都推荐使用二分查找。比如，数组中存储的都是长度超过300的字符串，如此长的两个字符串之间比对大小，就会非常耗时。需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，此时二分查找就比顺序遍历更有优势。</p></li>
<li><p>数据量太大也不适合二分查找。二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求<strong>内存空间连续</strong>，对内存的要求比较苛刻。</p></li>
</ol>
<h2 id="解答开篇">解答开篇</h2>
<p>假设我们有1000w个整数数据，每个数据占8个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这1000w数据中？希望这个功能不要占用太多的内存空间，最多不超过100MB，该怎么做？</p>
<p>内存限制是100MB，每个数据大小是8字节，最简单的办法就是将数据存储在数组中，内存占用为<code>1000w*8/1024/1024=76.3MB</code>，符合内存的限制。可以先对这1000w数据从小到大排序，然后再利用二分查找算法，就可以快速地查找想要的数据了。</p>
<p>虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是，不管是散列表还是二叉树，都会需要比较多的额外的内存空间。二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式，所以刚好能在限定的内存大小下解决这个问题。</p>
<h2 id="课后思考">课后思考</h2>
<ol type="1">
<li><p>如何编程实现“求一个数的平方根”？要求精确到小数点后6位。参考LeetCode答案：<a href="https://leetcode-cn.com/problems/sqrtx/solution/python-kai-gen-hao-bao-liu-xiao-shu-dian-sehr/">Python 开根号 保留小数点后几位</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search_sqrt</span>(<span class="params">x, k</span>):</span></span><br><span class="line">    low, high = <span class="number">0</span>, x</span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + (high-low) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(mid * mid - x) &lt; <span class="number">0.1</span> ** k:</span><br><span class="line">            <span class="comment"># 在误差范围内 保留指定位数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">round</span>(mid, k)</span><br><span class="line">        <span class="keyword">elif</span> mid * mid &gt; x:</span><br><span class="line">            high = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    result = binary_search_sqrt(<span class="number">2</span>, <span class="number">6</span>)  <span class="comment"># 1.414214</span></span><br><span class="line">    result = binary_search_sqrt(<span class="number">4</span>, <span class="number">6</span>)  <span class="comment"># 2.0</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li>
<li><p>如果数据使用链表存储，二分查找的时间复杂就会变成很高，那查找的时间复杂度究竟是多少呢？</p>
<p>来自置顶评论的答案：假设链表长度为<code>n</code>，二分查找每次都要找到中间点（计算中忽略奇偶数差异）：</p>
<p>第一次查找中间点，需要移动指针<code>n/2</code>次，</p>
<p>第二次查找中间点，需要移动指针<code>n/4</code>次，</p>
<p>第三次查找中间点，需要移动指针<code>n/8</code>次，</p>
<p>...</p>
<p>以此类推，直到1次为止。</p>
<p>总共移动指针次数，根据等比数列求和公式： <span class="math display">\[
S_n = \frac{a_1*(1-q^n)}{1-q}=\frac{a_nq-a_1}{q-1}=\frac{1*\frac{1}{2}-\frac{n}{2}}{\frac{1}{2}-1}=n-1
\]</span> 所以，时间复杂度是<span class="math inline">\(O(n)\)</span>。</p></li>
</ol>
<p>参考链接：</p>
<ol type="1">
<li><a href="https://zhidao.baidu.com/question/90801248.html">汇编中移位，为什么左移一位相当于乘以2</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找(下)</title>
    <url>/2021/10/22/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%B8%8B/</url>
    <content><![CDATA[<p>接着学一下二分查找（下）。</p>
<span id="more"></span>
<h2 id="典型的二分查找问题">典型的二分查找问题</h2>
<h3 id="查找第一个值等于给定值的元素">查找第一个值等于给定值的元素</h3>
<p>有序数据集合中存在重复的数据，如何找到第一个值等于给定值的数据？假设数据是从小到大排列为前提。</p>
<p>第一种方法，比较容易理解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search_left</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果是首元素或者前一个元素不为target</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> nums[mid-<span class="number">1</span>] != target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    <span class="built_in">print</span>(binary_search_left(nums=a, target=<span class="number">2</span>))  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<p>第二种方法，比较简洁，但是不太容易理解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search_left</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line"></span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> low &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[low] == target:</span><br><span class="line">        <span class="keyword">return</span> low</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这段代码中有两个地方比较难理解，第一个是<code>if num[mid] &gt;= target: high = mid-1</code>，文章中有段评论写的比较好，可以帮助理解。当<code>mid</code>等于<code>value</code>时，高位还会往左移去找第一个，那么势必会带来的问题是即使找到了第一个值为<code>value</code>的元素，高位还是会往左移动，但下一次判断的时候数组中已经没有值为<code>value</code>的值了，这时候代码会继续循环一直到低位加一后大于高位，这时候代码会跳出循环，而此时的低位正好是高位上一个经过的值为<code>value</code>的第一个元素。举例，假如有序数据集合为<code>[1, 1, 1, 2, 2, 6, 9, 10]</code>，然后<code>debug</code>来分析，会一目了然。第二个是<code>low &lt; len(nums)</code>，因为返回值是返回符合指定值的<code>low</code>，所以要判断一下数组是否越界。那什么情况下会数组越界呢？末尾文章评论中提到一种特殊情况，如果给定的值大于任何一个数组元素，<code>low</code>就会等于<code>len(nums)</code>，会导致数组越界。</p>
<h3 id="查找最后一个值等于给定值的元素">查找最后一个值等于给定值的元素</h3>
<p>有序数据集合中存在重复的数据，如何找到最后一个值等于给定值的数据？假设数据是从小到大排列为前提。</p>
<p>仿照上一题的第一种解法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search_right</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line"></span><br><span class="line">        mid = low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果是末尾元素或者下一个元素不为target</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="built_in">len</span>(nums) - <span class="number">1</span> <span class="keyword">or</span> nums[mid+<span class="number">1</span>] != target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    <span class="built_in">print</span>(binary_search_right(nums=a, target=<span class="number">2</span>))  <span class="comment"># 4</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search_right(nums=a, target=<span class="number">1</span>))  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<h3 id="查找第一个大于等于给定值的元素">查找第一个大于等于给定值的元素</h3>
<p>在有序数组中，查找第一个大于等于给定值的元素。比如，数组中存储的这样的一个序列，<code>3, 4, 6, 7, 10</code>。如果查找第一个大于等于5的元素，那就是6。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search_left_no_less</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line"></span><br><span class="line">        mid = low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">            <span class="comment"># 如果是首元素或者前一个元素小于target</span></span><br><span class="line">            <span class="comment"># 注意边界条件mid==0</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid-<span class="number">1</span>] &lt; target <span class="keyword">or</span> mid == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    <span class="built_in">print</span>(binary_search_left_no_less(nums=a, target=<span class="number">1</span>))  <span class="comment"># 0</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search_left_no_less(nums=a, target=<span class="number">2</span>))  <span class="comment"># 3</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search_left_no_less(nums=a, target=<span class="number">5</span>))  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<h3 id="查找最后一个小于等于给定值的元素">查找最后一个小于等于给定值的元素</h3>
<p>查找最后一个小于等于给定值的元素。比如，数组中存储了这样一组数据：<code>3, 5, 6, 8, 9, 10</code>。最后一个小于等于7的元素就是6。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search_right_no_less</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">            <span class="comment"># 如果是末尾元素或者下一个元素大于target</span></span><br><span class="line">            <span class="keyword">if</span> mid == (<span class="built_in">len</span>(nums)-<span class="number">1</span>) <span class="keyword">or</span> nums[mid+<span class="number">1</span>] &gt; target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    <span class="built_in">print</span>(binary_search_right_no_less(nums=a, target=<span class="number">1</span>))  <span class="comment"># 2</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search_right_no_less(nums=a, target=<span class="number">4</span>))  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>
<h2 id="解答开篇">解答开篇</h2>
<p>如何快速定位出一个IP地址的归属地？这里我反复读了好几遍，没有理解文章的含义。</p>
<p>文章主要是通过这个问题引出第四种变形问题“在有序数组中，查找最后一个小于等于给定值的元素”。</p>
<h2 id="内容小结">内容小结</h2>
<p>二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。</p>
<p>除了前面涉及到的这四道题目，二分查找的变形问题其实还可以有很多，比如“查找第一个小于等于给定值的元素”，“查找最后一个大于等于给定值的元素”。相比二分查找问题，二分查找变形问题的关键在于，<code>low</code>和<code>high</code>的更新。</p>
<h2 id="课后思考">课后思考</h2>
<p>如果有序数组是一个循环有序数组，比如<code>4, 5, 6, 1, 2, 3</code>。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法？</p>
<h3 id="第一种方法">第一种方法</h3>
<ol type="1">
<li><p>找到分界下标，分成两个有序数组。</p></li>
<li><p>判断目标值在哪个有序数据范围内，做二分查找。</p></li>
</ol>
<p>时间复杂度<span class="math inline">\(O(n)\)</span></p>
<h3 id="第二种方法">第二种方法</h3>
<ol type="1">
<li><p>找到最大值的下标<code>x</code>；</p></li>
<li><p>所有元素下标<code>+x</code>偏移，超过数组范围值的取模；</p></li>
<li><p>利用偏移后的下标做二分查找；</p></li>
<li><p>如果找到目标下标，再做<code>-x</code>操作，就是目标值实际下标。</p></li>
</ol>
<p>时间复杂度<span class="math inline">\(O(n)\)</span></p>
<h3 id="第三种方法">第三种方法</h3>
<p>以数组中间点分区，会将数组分成一个有序数组和一个循环有序数组。</p>
<ul>
<li><p>如果首元素小于<code>mid</code>，说明前半部分是有序的，后半部分是循环有序数组。</p></li>
<li><p>如果首元素大于<code>mid</code>，说明前半部分是循环有序数组，后半部分是有序的。</p></li>
</ul>
<p>如果目标元素在有序数组范围中，使用二分查找。</p>
<p>如果目标元素在循环有序数组中，递归以上操作，直到目标元素出现在有序数组范围中。</p>
<p>这种方式相当于两次二分查找，时间复杂度为<span class="math inline">\(O(logn)\)</span></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希算法(上)</title>
    <url>/2021/11/05/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-%E4%B8%8A/</url>
    <content><![CDATA[<p>今天来学一下哈希算法（上）。本篇文章的主要内容是如何用哈希算法解决问题。</p>
<span id="more"></span>
<h2 id="哈希算法">哈希算法</h2>
<p>任意长度的二进制值串映射为固定长度的二进制串，这个映射规则就是哈希算法。</p>
<p>哈希算法需要满足的几点要求：</p>
<ul>
<li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）</li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也不大相同</li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小</li>
<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值</li>
</ul>
<h2 id="应用">应用</h2>
<h3 id="安全加密">安全加密</h3>
<p>最常用于加密的哈希算法是<code>MD5</code>（MD5 Message-Digest Algorithm，MD5消息摘要算法）和<code>SHA</code>（Secure Hash Algorithm，安全散列算法）。其次还有<code>DES</code>（Data Encryption Standard，数据加密标准）、<code>AES</code>（Advanced Encryption Standard，高级加密标准）。</p>
<p>哈希算法产生的哈希值的长度是固定且有限的。比如<code>MD5</code>哈希值是固定的128位二进制串，最多能表示<code>2^128</code>个数据。基于<strong>鸽巢原理</strong>，如果对<code>2^128+1</code>个数据求哈希值，就必然会存在哈希值相同的情况。一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。</p>
<p>即使哈希算法存在冲突，但是在有限的时间和资源下，哈希算法还是很难被破解的。</p>
<h3 id="唯一标识">唯一标识</h3>
<p>举例说明，如果要在海量的图库中，搜索一张图是否存在，不能单纯地用图片的元信息（比如图片名称）来对比，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。那该如何搜索呢？</p>
<p>可以给每个图片取一个唯一标识，或者说信息摘要。比如，可以从图片的二进制串开头取100个字节，从中间取100个字节，从最后再取100个字节，然后将这300个字节放到一块，通过哈希算法（比如MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中。</p>
<p>还可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是否在图库中的时候，先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。</p>
<h3 id="数据校验">数据校验</h3>
<p>BT协议校验中的一种思路，通过哈希算法，对100个文件块分别取哈希值，并且保存在种子文件中。所以，当文件块下载完成之后，可以通过相同的哈希算法，对下载好的文件逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p>
<p>这主要是利用哈希算法第二个特性，即对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也不大相同。</p>
<h3 id="散列函数">散列函数</h3>
<p>散列函数也是哈希算法的一种应用。相对哈希算法的其他应用，散列函数对于散列算法冲突的要求低很多。不仅如此，散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值是否能平均分布。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>如何存储用户密码这么重要的数据？</p>
<ol type="1">
<li>通过哈希算法，对用户密码进行加密之后再存储，不过最好选择相对安全的算法，比如<code>SHA</code>等。</li>
<li>针对字典攻击，可以引入一个盐，跟用户的密码组合在一起，增加密码的复杂度。拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度。</li>
</ol>
<p>安全和攻击是一种博弈关系，不存在绝对的安全，所有的安全措施，只是增加攻击的成本而已。</p>
<h2 id="课后思考">课后思考</h2>
<p>区块链使用的是哪种哈希算法，是为了解决什么问题而使用的呢？</p>
<p>来自评论区的答案，<code>区块链是一块块区块组成的，每个区块分为两部分，区块头和区块体。区块头保存着（自己区块体和上一个区块头）的哈希值。因为这种链式关系和哈希值的唯一性，只要区块链上任意一个区块被修改过，后面区块保存的哈希值就不对了。区块链使用的是SHA256哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。</code></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>哈希算法</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希算法(下)</title>
    <url>/2021/11/09/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-%E4%B8%8B/</url>
    <content><![CDATA[<p>今天学习哈希算法（下）。本篇文章的主要内容是哈希算法如何解决分布式问题。</p>
<span id="more"></span>
<h2 id="应用">应用</h2>
<h3 id="负载均衡">负载均衡</h3>
<p>负载均衡算法有很多，比如轮询、随机、加权轮询等。那如何才能实现一个会话粘滞（session sticky）的负载均衡算法呢？也就是说，需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。</p>
<p>最直接的方法就是，维护一张映射关系表，这张表的内容是客户端IP地址或者会话ID与服务器编号的映射关系。客户端发出的每次请求，都要在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。这种方法简单直观，但也有几个弊端：</p>
<ul>
<li>如果客户端很多，映射表可能会很大，比较浪费内存空间；</li>
<li>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大。</li>
</ul>
<p>如果借住哈希算法，这些问题都可以非常完美地解决。<strong>可以通过哈希算法，对客户端IP地址或者会话ID计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。</strong></p>
<h3 id="数据分片">数据分片</h3>
<h4 id="如何统计搜索关键词出现的次数">如何统计“搜索关键词”出现的次数</h4>
<p>假如有1T的日志文件，这里面记录了用户的搜索关键词，想要快速统计出每个关键词被搜索的次数，该怎么做？</p>
<p>这个问题有两个难点，第一个是搜索日志很大，没办法放到一台机器的内存中。第二个难点是，如果只用一台机器来处理这么巨大的数据，处理时间会很长。</p>
<p>可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。具体思路：为了提高处理的速度，用n台机器并行处理。从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟n取模，最终得到的值，就是应该被分配到的机器编号。</p>
<p>这样，哈希值相同的搜索关键词就被分配到了同一台机器上。同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</p>
<p>这个处理过程也是<code>MapReduce</code>的基本设计思想。</p>
<h4 id="如何快速判断图片是否在图库中">如何快速判断图片是否在图库中</h4>
<p>假设图库有1亿张图片，如何快速判断图片是否在图库中？</p>
<p>同样可以对数据进行分片，然后采用多机处理。每次从图库中读取一个图片，计算唯一标识，然后与机器个数n求余取模，得到的值就是对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。当要判断一个图片是否在图库中的时候， 通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数n求余取模。假设得到的值是k，那就去编号k的机器构建的散列表中查找。</p>
<p>实际上，针对海量数据的处理问题，都可以采用多机分布式处理。借住这种分片的思路，可以突破单机内存、CPU资源的限制。</p>
<h3 id="分布式存储">分布式存储</h3>
<p>为了提高数据的读取、写入能力，一般都采用分布式的方式来存储数据，比如分布式缓存。如果有海量的数据需要缓存，需要将数据分布在多台机器上。可以借用数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。但是，如果数据增多，原来的机器个数n已经无法承受了，就需要扩容。这时麻烦就来了，并不是简单地加个机器就可以了。因为机器个数的增加，按照之前的计算方法，会导致数据分到与之前不同的机器上。</p>
<p>因此，需要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生雪崩效应，压垮数据库。</p>
<p>所以，就需要一种方法，使得在新加入一个机器后，并不需要做大量的数据搬移。这时候，一致性哈希算法就要登场了。假设有k个机器，数据的哈希值的范围是[0, MAX]。将整个范围划分成m个小区间（m远大于k），每个机器负责m/k个小区间。当有新机器加入的时候，就将某几个小区间的数据（每个机器负责m/(k+1)个小区间），从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>
<p>关于一致性哈希算法，有篇文章写的很好：<a href="https://www.zsythink.net/archives/1182">白话解析：一致性哈希算法 consistent hashing</a>，通俗易懂。</p>
<h2 id="解答开篇-内容小结">解答开篇 &amp; 内容小结</h2>
<p>主要是三种哈希算法在分布式系统中的应用，分别是：负载均衡、数据分片、分布式存储。</p>
<p>在负载均衡应用中，利用哈希算法替代映射表，可以实现一个会话粘滞的负载均衡策略。在数据分片应用中，通过哈希算法对处理的海量数据进行分片，多机分布式处理，可以突破单机资源的限制。在分布式存储应用中，利用一致性哈希算法，可以解决缓存等分布式系统的扩容、缩容导致数据大量搬移的难题。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>哈希算法</tag>
      </tags>
  </entry>
  <entry>
    <title>原码、反码和补码</title>
    <url>/2022/04/08/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81/</url>
    <content><![CDATA[<p>本篇文章主要学习记录原码、反码以及补码的相关知识。</p>
<span id="more"></span>
<h2 id="原码">原码</h2>
<p>计算机为了表示负数，在二进制数值前面增加一位符号位（即最高位为符号位）：正数该位为0，负数该位为1，其余位表示数值的大小。</p>
<p>比如，10的二进制原码表示为<code>0 1010</code>，-10的二进制原码表示为<code>1 1010</code>。</p>
<p>这种编码方式被称之为原码，<strong>原码的优点比较明显，就是简单直观，容易被人理解</strong>。</p>
<h3 id="存在的问题">存在的问题</h3>
<p>当正数+正数时，比如5+2，即<code>0 0101 + 0 0010 = 0 0111</code>，原码<code>0 0111</code>表示十进制中的7，即5+2=7。此时没有任何问题。</p>
<p>当正数+负数时，比如5+(-2)，即<code>0 0101 + 1 0010 = 1 0111</code>，原码<code>1 0111</code>表示十进制中的-7，即5+(-2)=-7，显然是不正确的。</p>
<p>原码这种编码方式仅支持正数+正数（即加法操作），而对于正数+负数（即减法操作）这种情况，显然不支持。</p>
<h2 id="反码">反码</h2>
<p>反码是基于原码计算得来，表示方式是：正数的反码是其本身。负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</p>
<p>举例说明，10的二进制反码表示为<code>0 1010</code>，-10的二进制反码表示为<code>1 0101</code>。</p>
<p>反码计算的规则：</p>
<ol type="1">
<li>反码运算时，其符号位与数值一起参加运算。</li>
<li><strong>反码的符号位相加后，如果有进位出现，则要把它送回最低位去相加（循环进位）。</strong></li>
<li>用反码运算，其运算结果亦为反码。在转换为真值时，若符号位为0，数位不变；若符号位为1，应将结果各个位取反才是其真值。</li>
</ol>
<p>比如5+(-2)，反码表示为<code>0 0101 + 1 1101 = 0 0011</code>，即5+(-2)=3。</p>
<p>再看一个(-5)+2，反码表示为<code>1 1010 + 0 0010 = 1 1100</code>，反码<code>1 1100</code>对应原码<code>1 0011</code>，其结果为-3。</p>
<h3 id="存在的问题-1">存在的问题</h3>
<p>当5+(-5)时，即<code>0 0101 + 1 1010 = 1 1111</code>，反码<code>1 1111</code>对应原码<code>1 0000</code>，其真值为-0。尽管+0和-0是一样的，但是0带符号是没有意义的。</p>
<p>反码虽然解决了减法的问题，但是却没有解决0的符号问题。</p>
<h2 id="补码">补码</h2>
<p>补码是在原码和反码的基础上衍生出来的，补码的表示方法是：正数的补码就是其本身。负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1（即在反码的基础上+1）。</p>
<p>补码计算的规则：</p>
<ol type="1">
<li>补码运算时，其符号位与数值一起参加运算。</li>
<li><strong>补码的符号位相加后，如果有进位出现，则进位被舍弃。</strong></li>
<li>用补码运算，其运算结果亦为补码。在转换成原码时，如果是正数，其补码就是原码；如果是负数，该补码的补码就是其原码。</li>
</ol>
<p>先来看一下5+(-5)，即<code>0 0101 +  1 1011 =  0 0000</code>。补码<code>0 0000</code>对应十进制为0。没有问题。</p>
<p>再来看一下5+(-6)，即<code>0 0101 + 1 1010 = 1 1111</code>。补码<code>1 1111</code>对应原码<code>1 0001</code>，即5+(-6)=-1。也没有问题。</p>
<p>有了补码，0的表达方式就唯一了，如果是8位的话，那么就是固定的<code>0000 0000</code>。同时，补码的取值范围也从原码和反码的<code>[-127, 127]</code>（即<code>[11111111, 01111111]</code>变成了<code>[-128, 127]</code>，其中补码<code>1000 0000</code>来表示-128。</p>
<h2 id="总结">总结</h2>
<ol type="1">
<li><p>正数的反码是其本身，负数的反码是在原码的基础上，除符号位外，其余位取反。</p></li>
<li><p>正数的补码是其本身，负数的补码是在原码的基础上，除符号位外，其余位取反，然后+1（即在反码的基础上+1）。</p></li>
<li><p>负数的补码的补码是其原码。</p></li>
</ol>
<p>参考文章：</p>
<ol type="1">
<li><a href="https://mp.weixin.qq.com/s/WSAZlbuDbyriXwB6LGA4uw">漫话：为什么计算机用补码存储数据？</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>排序(上)</title>
    <url>/2021/09/29/%E6%8E%92%E5%BA%8F-%E4%B8%8A/</url>
    <content><![CDATA[<p>今天来学习排序(上)。排序非常重要。</p>
<span id="more"></span>
<h2 id="如何分析一个排序算法">如何分析一个“排序算法”</h2>
<p>除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。</p>
<p>要从以下几个方面来分析一个排序算法。</p>
<h3 id="排序算法的执行效率">排序算法的执行效率</h3>
<ol type="1">
<li><p>最好情况、最坏情况、平均情况时间复杂度</p>
<p>除了能说出最好情况、最坏情况、平均情况下的时间复杂度外，还要能说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。</p>
<p>有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。</p></li>
<li><p>时间复杂度的系数、常数、低阶</p>
<p>时间复杂度反映的是数据规模n很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但在实际开发中，我们排序的可能是10个、100个、1000个这个规模很小的数据。所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</p></li>
<li><p>比较次数和交换(或移动)次数</p>
<p>基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换和移动。所以，在分析排序算法的执行效率的时候，应该把比较次数和交换(或移动)次数也考虑进去。</p></li>
</ol>
<h3 id="排序算法的内存消耗">排序算法的内存消耗</h3>
<p>算法的内存消耗可以通过空间复杂度来衡量。</p>
<p>原地排序，就是特指空间复杂度为<code>O(1)</code>的排序算法。</p>
<h3 id="排序算法的稳定性">排序算法的稳定性</h3>
<p>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，还有一个重要的度量指标，<strong>稳定性</strong>。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<p>如果相等元素之间原有的先后顺序不变，称之为<strong>稳定的排序算法</strong>，反之称为<strong>不稳定的排序算法</strong>。</p>
<p>为什么考察排序算法的稳定性呢？在真正的软件开发中，要排序的往往不是单纯的数字，而是一组对象，我们需要按照对象的某个<code>key</code>来排序。</p>
<h4 id="举例说明">举例说明</h4>
<p>现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果现在有10w条订单数据，希望按照金额从小到大对订单数据排序。对于订单金额相同的订单，希望按照下单时间从早到晚有序。对于这样一个排序需求，怎么做？</p>
<ol type="1">
<li>方法一，先按照金额对订单数据进行排序，然后，在遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。(理解起来简单，实现起来复杂)</li>
<li>方法二，先按照下单时间给订单排序。排序完成之后，再用稳定排序算法，按照订单金额重新排序。两边排序之后，得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。因为，<strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。</strong></li>
</ol>
<p>算法稳定性的用处，多次排序中，下一次排序需要依赖上一次排序的稳定结果。(妙啊)</p>
<h2 id="冒泡排序">冒泡排序</h2>
<h3 id="思路">思路</h3>
<p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成n个数据的排序工作。</p>
<h3 id="代码">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">a: <span class="built_in">list</span></span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="comment"># n次循环</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 注意点1: 这里j没有必要循环n次,因为倒数i个是有序的</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>-i):</span><br><span class="line">            <span class="keyword">if</span> a[j] &gt; a[j+<span class="number">1</span>]:</span><br><span class="line">                a[j], a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>], a[j]</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 注意点2: 当没有数据交换时，结束排序操作</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    aa = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="built_in">print</span>(bubble_sort(aa))</span><br></pre></td></tr></table></figure>
<h3 id="特点">特点</h3>
<ol type="1">
<li>原地排序，空间复杂度为<code>O(1)</code></li>
<li>稳定的排序算法</li>
<li>最好情况、最坏情况时间复杂度分别为<code>O(n)</code>、<code>O(n^2)</code></li>
</ol>
<h3 id="平均时间复杂度分析">平均时间复杂度分析</h3>
<p>利用“有序度”和“满序度”来分析平均时间复杂度。</p>
<p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。数学表达式：<code>有序元素对：a[i] &lt;= a[j], 如果i &lt; j</code>。其中完全有序的数组的有序度叫做<strong>满有序度</strong>。</p>
<p><strong>逆序度</strong>是数组中具有逆序关系的元素对的个数。数学表达式：<code>逆序元素对：a[i] &gt; a[j], 如果i &lt; j</code>。</p>
<p><strong>逆序度 = 满有序度 - 有序度</strong></p>
<p>举例：数组的初始状态是<code>4 5 6 3 2 1</code>，其中有序元素对有3个，分别是<code>(4, 5)</code>，<code>(4, 6)</code>，<code>(5, 6)</code>；逆序元素对有<code>(4, 3)</code>，<code>(4, 2)</code>，<code>(4, 1)</code>，<code>(5, 3)</code>，<code>(5, 2)</code>，<code>(5, 1)</code>，<code>(6, 3)</code>，<code>(6, 2)</code>，<code>(6, 1)</code>，<code>(3, 2)</code>，<code>(3, 1)</code>，<code>(2, 1)</code>共12个。</p>
<p><code>n</code>个元素的满有序度个数等于<code>n-1</code>个元素等差数列为1的求和公式，即<code>(n-1+1)*(n-1)/2=15</code>。</p>
<p>评论区有提到<code>C(n, m)</code>，自己也有印象，然后百度了一下，时间一长，都还给高中数学老师了。。。</p>
<blockquote>
<p>组合数公式是指从n个不同元素中，任取m(m&lt;=n)个元素并为一组，叫做从n个不同元素中取出m个元素的一个组合；从n个不同元素中取出m(m&lt;=n)个元素的所有组合的个数，叫做n个不同元素中取出m个元素的组合数。用符号C(n, m)表示。</p>
</blockquote>
<p>冒泡排序包含两个操作原子，<strong>比较</strong>和<strong>交换</strong>，其中交换次数等于逆有序度。</p>
<p>对于包含n个数据的数组进行冒泡排序，最坏情况下，初始状态的有序度0，所以要进行<code>n*(n-1)/2</code>次交换；最好情况下，初始状态的有序度为<code>n*(n-1)/2</code>，不需要进行交换。取一个中间值<code>n*(n-1)/4</code>来表示初始有序度既不是很高也不是很低的平均情况。</p>
<p>平均情况下，需要<code>n*(n-1)/4</code>次交换操作，比较操作比交换操作多，而复杂度的上限是<code>O(n^2)</code>，所以平均情况下的时间复杂度就是<code>O(n^2)</code></p>
<h2 id="插入排序">插入排序</h2>
<h3 id="思路-1">思路</h3>
<p>插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中的元素为空，算法结束。上图，(<a href="https://www.runoob.com/w3cnote/insertion-sort.html">菜鸟教程-插入排序</a>)</p>
<p><img src="insertion_sort.gif" /></p>
<h3 id="代码-1">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">a: <span class="built_in">list</span></span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        value = a[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> a[j] &gt; value:</span><br><span class="line">          	<span class="comment"># 向后移动数据</span></span><br><span class="line">            a[j+<span class="number">1</span>] = a[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        a[j+<span class="number">1</span>] = value</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<p>这个很难理解啊。调试了很久。。</p>
<h3 id="特点-1">特点</h3>
<ol type="1">
<li>原地排序，空间复杂度为<code>O(1)</code></li>
<li>稳定的排序算法。如果代码<code>a[j] &gt; value</code>修改为<code>a[j] &gt;= value</code>，则为不稳定的排序算法。</li>
<li>最好情况下时间复杂度为<code>O(n)</code>，此时不需要走<code>while</code>循环，只需要遍历<code>n</code>次；最坏情况下时间复杂度为<code>O(n^2)</code>，每次都需要走<code>while</code>循环，移动数据；平均情况时间复杂度为<code>O(n^2)</code>，数组那节提到数组插入的平均时间复杂度为<code>O(n)</code>，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行<code>n</code>次操作。</li>
</ol>
<h2 id="选择排序">选择排序</h2>
<h3 id="思路-2">思路</h3>
<p>选择排序和插入排序类似，也分为已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。一开始没理解，上图就一目了然了。</p>
<p><img src="select_sort.webp" /></p>
<h3 id="代码-2">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">a: <span class="built_in">list</span></span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        min_index = i</span><br><span class="line">        min_value = a[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            <span class="comment"># 找到最小值位置</span></span><br><span class="line">            <span class="keyword">if</span> a[j] &lt; min_value:</span><br><span class="line">                min_value = a[j]</span><br><span class="line">                min_index = j</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 交换位置</span></span><br><span class="line">        a[i], a[min_index] = a[min_index], a[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<h3 id="特点-2">特点</h3>
<ol type="1">
<li>原地排序，空间复杂度为<code>O(1)</code></li>
<li>最好情况、最坏情况、平均情况时间复杂度均为<code>O(n^2)</code>。因为每次都需要从未排序区间找到最小值，而最小值只能通过全部比较一次得到。比较次数为：<code>(n-1)+...+1=n*(n-1)/2</code>次</li>
<li>不稳定的排序算法。选择排序每次都要找到剩余未排序元素中的最小值，并<strong>和前面的元素交换位置</strong>，这样破坏了稳定性。</li>
</ol>
<h2 id="希尔排序">希尔排序</h2>
<h3 id="思路-3">思路</h3>
<p>先将整个待排序的记录序列分割成若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h3 id="代码-3">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">a: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    gap = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (gap &lt; <span class="built_in">len</span>(a) / <span class="number">3</span>):</span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, <span class="built_in">len</span>(a)):</span><br><span class="line">            temp = a[i]</span><br><span class="line">            j = i - gap</span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> a[j] &gt; temp:</span><br><span class="line">                a[j + gap] = a[j]</span><br><span class="line">                j -= gap</span><br><span class="line">            a[j + gap] = temp</span><br><span class="line">        gap = math.floor(gap / <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<p>代码看的有点晕，看动图也比较晕，<a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">比较排序算法-动图演示</a>，先放到这吧，慢慢理解...</p>
<h3 id="特点-3">特点</h3>
<ol type="1">
<li>原地排序，空间复杂度为<code>O(1)</code></li>
<li>不稳定的排序算法。</li>
<li>时间复杂度<code>O(n^(1.3-2))</code></li>
</ol>
<h2 id="解答开篇">解答开篇</h2>
<p>为什么冒泡排序和插入排序的时间复杂度都是<code>O(n^2)</code>，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？</p>
<p>冒泡排序和插入排序数据移动次数都是一样的，都等于数据的逆序度。但是在交换数据上，冒泡排序比插入排序更复杂一些，冒泡排序需要3个赋值操作，插入排序只需要1个。<code>Java</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序中数据的交换操作</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123;  <span class="comment">// 交换</span></span><br><span class="line">	<span class="keyword">int</span> tmp = a[j];</span><br><span class="line">	a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">	a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">	flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序中数据的移动操作</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j]  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把执行一个赋值语句的时间粗略地计为单位时间，然后分别用冒泡排序和插入排序对同一个逆序度是<code>K</code>的数组进行排序，用冒泡排序，需要<code>K</code>次交换操作，每次需要3个赋值语句，所以交换操作总耗时就是<code>3*K</code>单位时间。而插入排序中数据移动操作只需要<code>K</code>个单位时间。以上是分析<code>Java</code>代码的分析。</p>
<h3 id="性能测试">性能测试</h3>
<p>接下来和文章中类似的，用<code>Python</code>写一个性能对比测试程序，随机生成1000个数组，每个数组包含200个数据，然后分别用冒泡排序和插入排序来排序，来看看耗时。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bb = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    aa = [random.randint(<span class="number">100</span>, <span class="number">1000</span>) <span class="keyword">for</span> each <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>)]</span><br><span class="line">    bb.append(aa)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> bb:</span><br><span class="line">    insertion_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;insertion_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))  <span class="comment"># insertion_sort: 1.467289686203003</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> bb:</span><br><span class="line">    bubble_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bubble_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))  <span class="comment"># bubble_sort: 0.015933990478515625</span></span><br></pre></td></tr></table></figure>
<p>咦，怎么插入排序比冒泡排序耗时还要长？反过来试试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bb = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    aa = [random.randint(<span class="number">100</span>, <span class="number">1000</span>) <span class="keyword">for</span> each <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>)]</span><br><span class="line">    bb.append(aa)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> bb:</span><br><span class="line">    bubble_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bubble_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))  <span class="comment"># bubble_sort: 2.7117371559143066</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> bb:</span><br><span class="line">    insertion_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;insertion_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))  <span class="comment"># insertion_sort: 0.029211997985839844</span></span><br></pre></td></tr></table></figure>
<p>咦，怎么回事，仔细一想，哦，原来执行一次排序后，列表<code>bb</code>中的每个元素都已经有序了。好吧，再来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bb = []</span><br><span class="line">dd = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    aa = [random.randint(<span class="number">100</span>, <span class="number">1000</span>) <span class="keyword">for</span> each <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>)]</span><br><span class="line">    bb.append(aa)</span><br><span class="line">    dd.append(aa)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> bb:</span><br><span class="line">    bubble_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bubble_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))  <span class="comment"># bubble_sort: 2.657896041870117</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> dd:</span><br><span class="line">    insertion_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;insertion_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))  <span class="comment"># insertion_sort: 0.029906749725341797</span></span><br></pre></td></tr></table></figure>
<p>咦，和上次的执行结果基本一致，这是怎么回事？原来执行过一次排序后，列表<code>bb</code>和列表<code>dd</code>中的每个元素都是有序的。这主要是因为列表是可变对象，经过第一次排序后，列表<code>bb</code>中的元素是有序的，而列表<code>dd</code>中的元素和列表<code>bb</code>中存储的是同一批数据，指向同一块内存地址。那用深拷贝试试。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bb = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    aa = [random.randint(<span class="number">100</span>, <span class="number">1000</span>) <span class="keyword">for</span> each <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>)]</span><br><span class="line">    bb.append(aa)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">dd = copy.deepcopy(bb)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> bb:</span><br><span class="line">    insertion_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;insertion_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))  <span class="comment"># insertion_sort: 1.3626751899719238</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> dd:</span><br><span class="line">    bubble_sort(cc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bubble_sort: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time()-start))  <span class="comment"># bubble_sort: 2.683237075805664</span></span><br></pre></td></tr></table></figure>
<p>看起来有点对了，但是和文章中说的3倍关系好像还是有点差异，那么来看看<code>Python</code>中交换两个数<code>a[j], a[j+1] = a[j+1], a[j]</code>的原理吧。参考链接：<a href="https://www.zhihu.com/question/275696055">Python交换两个数</a>。回答中提到，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a, b = b, a</span><br><span class="line"></span><br><span class="line"># 等效于</span><br><span class="line"></span><br><span class="line">c = (b, a)  # 这个c是一个临时的元组</span><br><span class="line"></span><br><span class="line">a = c[0]  # 取出元组中的b</span><br><span class="line">b = c[1]  # 取出元组中的a</span><br></pre></td></tr></table></figure>
<p>从这段代码中来看，是只有两次赋值操作的。和上面性能测试中耗时时间2倍关系是相吻合的。</p>
<p>另外，可以对比一下最好情况下，冒泡排序和插入排序的耗时情况。尽管时间复杂度都是<code>O(n)</code>，但冒泡排序优于插入排序。</p>
<h2 id="课后思考">课后思考</h2>
<p>上面写的几种排序算法，都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那么相应的时间、空间复杂度是多少？</p>
<p>来吧，先把置顶评论放到这吧。前提，是否允许修改链表的节点value值，还是只能改变节点的位置。一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。</p>
<p>个人思考，如果允许修改链表的节点value值，就会和数组有点类似。数组的优势是根据下标随机访问，劣势是搬移数据；链表的优势是插入删除数据，劣势是随机访问。修改链表的节点value值也是赋值操作，跟数组操作一致。如果改变节点位置，比较次数同循环次数一致，交换(或移动)次数同数据逆序度。但是链表交换位置，意味着需要修改指针指向，如果是单链表需要节点的上一个节点的引用，这样就增加了时间复杂度。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序(下)</title>
    <url>/2021/10/15/%E6%8E%92%E5%BA%8F-%E4%B8%8B/</url>
    <content><![CDATA[<p>今天来学习排序(下)。</p>
<span id="more"></span>
<h2 id="归并排序的原理">归并排序的原理</h2>
<p>核心思想：如果要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>
<p>归并排序使用的是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。</p>
<p>分治思想跟递归思想很像。分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>。</p>
<p>自己又陷入思维误区，试图理解整个递归的过程，然后脑子就懵了...</p>
<p>回顾一下写递归代码的技巧，<strong>分析得出递归公式，然后找到终止条件，最后将递推公式翻译成递归代码</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递推公式</span></span><br><span class="line">merge_sort(p...r) = merge(merge_sort(p...q), merge_sort(q+<span class="number">1.</span>..r))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终止条件</span></span><br><span class="line">p &gt;= r 不用再继续分解</span><br></pre></td></tr></table></figure>
<p><strong>通过递归代码来实现归并排序</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">a: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">    _merge_sort(a, <span class="number">0</span>, <span class="built_in">len</span>(a)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_merge_sort</span>(<span class="params">a: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">        _merge_sort(a, low, mid)</span><br><span class="line">        _merge_sort(a, mid+<span class="number">1</span>, high)</span><br><span class="line">        _merge(a, low, mid, high)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_merge</span>(<span class="params">a: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, mid: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        合并两个有序数组</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i, j = low, mid+<span class="number">1</span></span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt;= a[j]:</span><br><span class="line">            tmp.append(a[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(a[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    start = i <span class="keyword">if</span> i &lt;= mid <span class="keyword">else</span> j</span><br><span class="line">    end = mid <span class="keyword">if</span> i &lt;= mid <span class="keyword">else</span> high</span><br><span class="line">    tmp.extend(a[start: end + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    a[low: high+<span class="number">1</span>] = tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line">    merge_sort(t)</span><br><span class="line">    <span class="built_in">print</span>(t)  <span class="comment"># [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>通过递归写出来的代码，总想看看递归的过程是什么样的。用文章中这张图来说明。</p>
<p><img src="merge_sort.webp" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始数组：[11, 8, 3, 9, 7, 1, 2, 5] </span><br><span class="line"></span><br><span class="line">第一次：[8, 11, 3, 9, 7, 1, 2, 5] </span><br><span class="line"></span><br><span class="line">第二次：[8, 11, 3, 9, 7, 1, 2, 5]</span><br><span class="line"></span><br><span class="line">第三次：[3, 8, 9, 11, 7, 1, 2, 5]</span><br><span class="line"></span><br><span class="line">第四次：[3, 8, 9, 11, 1, 7, 2, 5]</span><br><span class="line"></span><br><span class="line">第五次：[3, 8, 9, 11, 1, 7, 2, 5]</span><br><span class="line"></span><br><span class="line">第六次：[3, 8, 9, 11, 1, 2, 5, 7]</span><br><span class="line"></span><br><span class="line">最终结果：[1, 2, 3, 5, 7, 8, 9, 11]</span><br></pre></td></tr></table></figure>
<p>递归真的很难理解呀！</p>
<h2 id="归并排序的性能分析">归并排序的性能分析</h2>
<h3 id="稳定性">稳定性</h3>
<p>归并排序是稳定的排序算法。在<code>_merge()</code>函数合并两个有序子数组的代码中，当<code>a[i] &lt;= a[j]</code>时，<code>tmp.append(a[i])</code>，即不改变值相同元素的先后顺序，所以归并排序是稳定的排序算法。</p>
<h3 id="时间复杂度">时间复杂度</h3>
<p>归并排序的时间复杂度是<code>O(nlogn)</code></p>
<p>归并排序涉及递归，如何分析递归代码的时间复杂度？</p>
<p>如果定义求解问题<code>a</code>的时间是<code>T(a)</code>，求解问题<code>b</code>、<code>c</code>的时间分别是<code>T(b)</code>、<code>T(c)</code>，那么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T(a) = T(b) + T(c) + K</span><br></pre></td></tr></table></figure>
<p>其中<code>K</code>等于将两个子问题<code>b</code>、<code>c</code>的结果合并成问题<code>a</code>的结果所消耗的时间。</p>
<p><strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong></p>
<p>假设对<code>n</code>个元素进行归并排序需要的时间是<code>T(n)</code>，那么分解成两个子数组排序的时间都是<code>T(n/2)</code>，<code>_merge()</code>函数合并两个有序子数组的时间复杂度是<code>O(n)</code>(因为两个有序子数组一共有<code>n</code>个元素)。</p>
<p>所以，套用上面的公式，归并排序的时间复杂度的计算公式就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T(1) = C; n=1时，只需要常量级的执行时间，所以表示为C</span><br><span class="line">T(n) = 2*T(n/2) + n; n&gt;1</span><br></pre></td></tr></table></figure>
<p>进一步分解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T(n) = 2*T(n/2) + n</span><br><span class="line"> = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n  (将n=n/2整体代入)</span><br><span class="line"> = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n</span><br><span class="line"> ...</span><br><span class="line"> = 2^k * T(n/2^k) + k*n</span><br></pre></td></tr></table></figure>
<p>最终得到<code>T(n) = 2^k * T(n/2^k) + k*n</code>，<code>n</code>代表待排序数组的长度，<code>k</code>代表分解次数，当<code>T(n/2^k)=T(1)</code>时，代表分解数组中个数为1，递归到了尽头，也就是<code>n/2^k=1</code>，此时 <span class="math display">\[
k=\log_2n
\]</span> 将<code>k</code>值代入上面的公式，得到 <span class="math display">\[
T(n) = Cn + n\log_2n
\]</span> 用大O标记法来表示的话，<code>T(n)=O(nlogn)</code>，所以归并排序的时间复杂度为<code>O(nlogn)</code></p>
<p>归并排序的执行效率与要排序的原始数组的有序程度无关，其时间复杂度是非常稳定的，不管是最好情况、最坏情况、还是平均情况，时间复杂度都是<code>O(nlogn)</code></p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>归并排序的空间复杂度是<code>O(n)</code>。归并排序的时间复杂度任何情况下都是<code>O(nlogn)</code>，看起来非常优秀，但归并排序不是原地排序算法。</p>
<p>因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。如果继续按照分析递归时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是<code>O(nlogn)</code>。</p>
<p>实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。尽管每次合并操作都需要额外申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过<code>n</code>个数据的大小(只考虑最大临时内存空间就好了)，所以空间复杂度是<code>O(n)</code>。</p>
<h2 id="快速排序的原理">快速排序的原理</h2>
<p>快速排序，简称快排，利用的也是分治思想。</p>
<p>核心思想：</p>
<ol type="1">
<li><p>如果要排序数组中下标从<code>p</code>到<code>r</code>之间的一组数据，我们选择<code>p</code>到<code>r</code>之间的任意一个数据作为<code>pivot</code>(分区点)。</p></li>
<li><p>遍历<code>p</code>到<code>r</code>之间的数据，将小于<code>pivot</code>的放到左边，将大于<code>pivot</code>的放到右边，将<code>pivot</code>放到中间。经过这一步骤之后，数组<code>p</code>到<code>r</code>之间的数据就被分成了三个部分，前面<code>p</code>到<code>q-1</code>之间都是小于<code>pivot</code>的，中间是<code>pivot</code>，后面的<code>q+1</code>到<code>r</code>之间是大于<code>pivot</code>的。如图所示，</p>
<p><img src="quick_sort.webp" /></p></li>
<li><p>根据分治、递归的处理思想，可以用递归排序下标从<code>p</code>到<code>q-1</code>之间的数据和下标从<code>q+1</code>到<code>r</code>之间的数据，直到区间缩小为1，就说明所有的数据都有序了。</p></li>
</ol>
<p>递推公式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递推公式</span></span><br><span class="line">quick_sort(p...r) = quick_sort(p...q-<span class="number">1</span>) + quick_sort(q...r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终止条件</span></span><br><span class="line">p &gt;= r</span><br></pre></td></tr></table></figure>
<p><strong>通过递归代码来实现快速排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">a: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">    _quick_sort(a, <span class="number">0</span>, <span class="built_in">len</span>(a)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_quick_sort</span>(<span class="params">a: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        k = random.randint(low, high)</span><br><span class="line">        <span class="comment"># 把pivot放到首部</span></span><br><span class="line">        a[low], a[k] = a[k], a[low]</span><br><span class="line"></span><br><span class="line">        m = _partition(a, low, high)</span><br><span class="line">        _quick_sort(a, low, m-<span class="number">1</span>)</span><br><span class="line">        _quick_sort(a, m+<span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_partition</span>(<span class="params">a: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>):</span></span><br><span class="line">    pivot, j = a[low], low</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(low+<span class="number">1</span>, high+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt;= pivot:</span><br><span class="line">            j += <span class="number">1</span>  <span class="comment"># 这里j是记录pivot要放的位置</span></span><br><span class="line">            a[i], a[j] = a[j], a[i]</span><br><span class="line"></span><br><span class="line">    a[low], a[j] = a[j], a[low]</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">    quick_sort(t)</span><br><span class="line">    <span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure>
<p>快速排序中有个<code>partition()</code>分区函数，随机选择一个元素作为<code>pivot</code>然后对<code>a[p..r]</code>分区，函数返回<code>pivot</code>的下标。如果不考虑空间消耗，<code>partition</code>分区函数可以写的非常简单。申请两个临时数组<code>X</code>和<code>Y</code>，将小于<code>pivot</code>的元素都拷贝到临时数组<code>X</code>，将大于<code>pivot</code>的元素都拷贝到临时数组<code>Y</code>，最后再将数组<code>X</code>和<code>Y</code>中的元素顺序拷贝到<code>a[p...r]</code>。</p>
<p>但是，如果这样实现的话，快速排序就不是原地排序算法了。如果考虑空间复杂度为<code>O(1)</code>的话，需要用到类似<strong>选择排序</strong>的处理方式，通过游标<code>j</code>把<code>a[low:high]</code>分成两部分。<code>a[low:j-1]</code>的元素都是小于<code>pivot</code>的，称作“已处理区间”，<code>a[j+1:high]</code>是“未处理区间”。每次从未处理区间取一个值，和<code>pivot</code>对比，如果小于<code>pivot</code>，就把它放到已处理区间的尾部。但在数组某个位置插入元素，需要搬移操作，非常耗时。因此，选择交换的处理方式。</p>
<p>实现方式：通过游标<code>i</code>从前往后遍历数组<code>a</code>，如果<code>a[i]</code>的值小于<code>pivot</code>，则<code>j+=1</code>，说明有一个元素小于<code>pivot</code>，直至遍历结束。最后，交换<code>pivot</code>和下标为<code>j</code>的值。这样，下标<code>j</code>左边的值都小于<code>pivot</code>，右边的值都大于<code>pivot</code>，</p>
<h3 id="归并排序vs快速排序">归并排序vs快速排序</h3>
<p><img src="merge_sort_vs_quick_sort.webp" /></p>
<p>归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为<code>O(nlogn)</code>的排序算法，但是非原地排序算法。而快速排序通过原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p>
<h2 id="快速排序的性能分析">快速排序的性能分析</h2>
<h3 id="稳定性-1">稳定性</h3>
<p>快速排序是不稳定的排序算法。我这里根据序列<code>6, 8, 7, 6, 3, 5, 9, 4</code>仿照文章中的分析，也画了张图。</p>
<p><img src="quick_sort_stable.jpg" /></p>
<p>显而易见，当比较<code>3&lt;4</code>时，需要交换下标<code>i</code>和<code>j</code>的值，这样第一个6就跑到了第二个6的后面，因此，快速排序是不稳定的排序算法。想了半天想不明白，画了画图，豁然开朗。</p>
<p>评论里说，涉及到交换操作的排序算法都是不稳定的，这里先记录一下，后续验证一下。</p>
<h3 id="时间复杂度-1">时间复杂度</h3>
<p>快排也是用递归来实现的，对于上面分析归并排序的公式，对于快排同样适用。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那么快排的时间复杂度递推求解公式跟归并排序是相同的。所以快速排序的时间复杂度是<code>O(nlogn)</code>。</p>
<p>但是，公式成立的前提是每次分区操作，选择的<code>pivot</code>都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。</p>
<p>举一个比较极端的例子。如果数组中的数据原来已经是有序的了，比如<code>1, 3, 5, 6, 8</code>。如果每次选择最后一个元素作为<code>pivot</code>，那每次分区得到的两个区间都是不均等的。这种情况下，快排的时间复杂度就从<code>O(nlogn)</code>退化成了<code>O(n^2)</code>。</p>
<p>结论：快速排序在大部分情况下的时间复杂度都可以做到<code>O(nlogn)</code>，只有在极端情况下，才会退化到<code>O(n^2)</code>。</p>
<h3 id="空间复杂度-1">空间复杂度</h3>
<p>快速排序是原地排序算法。主要取决于分区函数的实现。</p>
<h2 id="排序算法对比">排序算法对比</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>冒泡排序</td>
<td><code>O(n^2)</code></td>
<td><code>O(1)</code></td>
<td>稳定</td>
</tr>
<tr class="even">
<td>插入排序</td>
<td><code>O(n^2)</code></td>
<td><code>O(1)</code></td>
<td>稳定</td>
</tr>
<tr class="odd">
<td>选择排序</td>
<td><code>O(n^2)</code></td>
<td><code>O(1)</code></td>
<td>不稳定(涉及交换元素)</td>
</tr>
<tr class="even">
<td>归并排序</td>
<td><code>O(nlogn)</code></td>
<td><code>O(n)</code></td>
<td>稳定</td>
</tr>
<tr class="odd">
<td>快速排序</td>
<td><code>O(nlogn)</code></td>
<td><code>O(1)</code></td>
<td>不稳定(涉及交换元素)</td>
</tr>
</tbody>
</table>
<p>冒泡排序、插入排序、选择排序时间复杂度都为<code>O(n^2)</code>，比较高，适合小规模数据的排序。</p>
<p>归并排序、快速排序时间复杂度都为<code>O(nlogn)</code>，适合大规模的数据排序。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>问题：<code>O(n)</code>时间复杂度内求无序数组中的第<code>K</code>大元素？比如，<code>4, 2, 5, 12, 3</code>这样一组数据，第3大元素就是4</p>
<p>答案：利用分区的思想。我们选择数组区间<code>A[0...n-1]</code>的最后一个元素<code>A[n-1]</code>作为<code>pivot</code>，对数组<code>A[0...n-1]</code>原地分区，这样数组就分成了三部分，<code>A[0...p-1]</code>、<code>A[p]</code>、<code>A[p+1...n-1]</code>。</p>
<p>如果<code>p+1=K</code>，那么<code>A[p]</code>就是要求解的元素（如果要查找第3大元素，那么下标为2的元素就是要查找的值）；如果<code>K&gt;p+1</code>，说明第<code>K</code>大元素出现在<code>A[p+1...n-1]</code>区间，然后递归地在<code>A[p+1...n-1]</code>这个区间查找。反之，就在<code>A[0...p-1]</code>区间查找。</p>
<p>那么为什么时间复杂度是<code>O(n)</code>呢？</p>
<p>第一次分区查找，需要对大小为<code>n</code>的数组执行分区操作，需要遍历<code>n</code>个元素。第二次分区查找，只需要对大小为<code>n/2</code>的数组执行分区操作，需要遍历<code>n/2</code>个元素，依次类推，分区遍历的元素个数分别为：<code>n/2</code>、<code>n/4</code>、<code>n/8</code>、<code>n/16</code>...直到区间缩小为1。</p>
<p>把每次分区遍历的元素个数加起来，就是<code>n+n/2+n/4+n/8+n/16+...+1</code>，这是一个等比数列求和。</p>
<p>等比数列求和公式： <span class="math display">\[
S_n = \frac{a_1*(1-q^n)}{1-q}=\frac{a_1-a_nq}{1-q}=\frac{a_nq-a_1}{q-1},(q\neq1)
\]</span> 即： <span class="math display">\[
S_n = \frac{(1*\frac{1}{2}-n)}{\frac{1}{2}-1}=\frac{1-2n}{1-2}=2n-1
\]</span> 所以上述思路的时间复杂度就为<code>O(n)</code>。</p>
<p>文章中提到一个方法，每次取数组中的最大值，将其移动到数组的最前面，然后在剩下的数组中继续找最大值，以此类推，执行<code>K</code>次，找到的数据不就是第<code>K</code>大元素了吗？</p>
<p>首先，这是选择排序的思路，其次寻找第<code>K</code>大元素的时间复杂度是<code>O(K*n)</code>，并不是<code>O(n)</code>，时间复杂度前面的系数<code>K</code>是比较小的常量时，那么时间复杂度确实是<code>O(n)</code>，但当<code>K</code>等于<code>n/2</code>或是<code>n</code>时，这种最坏情况下的时间复杂度就是<code>O(n^2)</code>。</p>
<h2 id="课后思考">课后思考</h2>
<p>现在有10个接口访问日志文件，每个日志文件大小约300MB，每个文件里的日志都是按照时间戳从小到大排序的。希望将这10个较小的日志文件，合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有1GB，有什么好的解决思路，能“快速”地将这10个日志文件合并吗？</p>
<p>来自置顶评论的答案：每次从各个文件中取一条数据，在内存中根据数据时间戳构建一个最小堆，然后每次把最小值给写入新文件，同时将最小值来自的那个文件再出来一个数据，加入到最小堆中。这个空间复杂度为常数，但没能很好利用1G内存，而且磁盘单个读取比较慢，所以考虑每次读取一批数据，没了再从磁盘中取，时间复杂度还是<code>O(n)</code>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序优化</title>
    <url>/2021/10/18/%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>今天来学一下排序优化。如何实现一个通用的、高性能的排序函数？</p>
<span id="more"></span>
<h2 id="如何选择合适的排序算法">如何选择合适的排序算法</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th>时间复杂度</th>
<th>稳定排序</th>
<th>原地排序</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>冒泡排序</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>是</td>
<td>是</td>
</tr>
<tr class="even">
<td>插入排序</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>是</td>
<td>是</td>
</tr>
<tr class="odd">
<td>选择排序</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>否</td>
<td>是</td>
</tr>
<tr class="even">
<td>快速排序</td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td>否</td>
<td>是</td>
</tr>
<tr class="odd">
<td>归并排序</td>
<td><span class="math inline">\(O(nlogn)\)</span></td>
<td>是</td>
<td>否</td>
</tr>
<tr class="even">
<td>桶排序</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>是</td>
<td>否</td>
</tr>
<tr class="odd">
<td>计数排序</td>
<td><span class="math inline">\(O(n+k)\)</span> k是数据范围</td>
<td>是</td>
<td>否</td>
</tr>
<tr class="even">
<td>基数排序</td>
<td><span class="math inline">\(O(dn)\)</span> d是维度</td>
<td>是</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>这里计数排序和基数排序的时间复杂度为什么是<span class="math inline">\(O(n+k)\)</span>和<span class="math inline">\(O(dn)\)</span>？</p>
<p>线性排序算法的时间复杂度比较低，适用场景比较特殊。如果要写一个通用的排序函数，不能选择线性排序算法。</p>
<p>如果对小规模数据进行排序，可以选择时间复杂度是<span class="math inline">\(O(n^2)\)</span>的算法；如果对大规模数据进行排序，时间复杂度是<span class="math inline">\(O(nlogn)\)</span>的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是<span class="math inline">\(O(nlogn)\)</span>的排序算法来实现排序函数。</p>
<p>时间复杂度是<span class="math inline">\(O(nlogn)\)</span>的排序算法不止一个，除了快速排序和归并排序，还有堆排序。堆排序和快速排序都有比较多的应用。比如<code>Java</code>语言采用堆排序实现排序函数、<code>C</code>语言采用快速排序实现排序函数。</p>
<p>快速排序在最坏情况下的时间复杂度是<span class="math inline">\(O(n^2)\)</span>，而归并排序可以在平均情况、最坏情况下的时间复杂度都是<span class="math inline">\(O(nlogn)\)</span>，但是由于归并排序并不是原地排序算法，空间复杂度是<span class="math inline">\(O(n)\)</span>，因此没有得到广泛应用。</p>
<h2 id="如何优化快速排序">如何优化快速排序</h2>
<p>如果数据本身就是有序或者接近有序的，每次分区点选择最后一个数据，那么快速排序算法时间复杂度就会退化成<span class="math inline">\(O(n^2)\)</span>。这种情况的出现的主要原因是分区点选的不够合理。</p>
<p>最理想的分区点：<strong>被分区点分开的两个分区中，数据的数量差不多。</strong></p>
<h3 id="三数取中法">三数取中法</h3>
<p>从区间的首、尾、中间，分别取出一个数，然后对比大小，取这3个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p>
<h3 id="随机法">随机法</h3>
<p>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能出现每次分区点都选得很差，所以，平均情况下，这样选的分区点是比较好的。时间复杂度退化为<span class="math inline">\(O(n^2)\)</span>的情况，出现的可能性不大。</p>
<p>快速排序是用递归来实现的，递归要警惕堆栈溢出。</p>
<h2 id="举例分析排序函数">举例分析排序函数</h2>
<p><code>C</code>运行库<code>Glibc</code>中的<code>qsort()</code>函数举例说明。</p>
<p><code>qsort()</code>会优先使用归并排序来排序输入数据。因为归并排序的空间复杂度是<span class="math inline">\(O(n)\)</span>，对于小数据量的排序，比如1KB、2KB等，归并排序需要的空间可以忽略。</p>
<p>但<strong>如果数据量太大，比如说100MB，<code>qsort()</code>会改为快速排序算法来排序。</strong><code>qsort()</code>选择分区点的方法就是“三数取中法”。对于递归太深会导致堆栈溢出的问题，<code>qsort()</code>是通过自己实现一个堆上的栈，手动模拟递归实现的。</p>
<p>实际上，<code>qsort()</code>并不仅仅用到了归并排序和快速排序，还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于4时，<code>qsort()</code>就会退化为插入排序，不再继续使用递归来做快速排序。</p>
<p><strong>在小规模数据中，<span class="math inline">\(O(n^2)\)</span>时间复杂度的算法并不一定比<span class="math inline">\(O(nlogn)\)</span>的算法执行时间长。</strong></p>
<p>算法的性能可以通过时间复杂度来分析，但是，这种复杂度分析是比较偏理论的，实际上时间复杂度并不等于代码实际的运行时间。</p>
<p>时间复杂度代表的是一个增长趋势，如果画成增长曲线，会发现<span class="math inline">\(O(n^2)\)</span>比<span class="math inline">\(O(nlogn)\)</span>增长趋势更猛一些，但是，在大<code>O</code>复杂度表示法中，会忽略低阶、系数和常数。也就是说，<span class="math inline">\(O(nlogn)\)</span>在没有省略低阶、系数、常数之前可能是<span class="math inline">\(O(knlogn+c)\)</span>，而且<code>k</code>和<code>c</code>有可能还是一个比较大的数。</p>
<p>对于小规模数据的排序，<span class="math inline">\(O(n^2)\)</span>的排序算法并不一定比<span class="math inline">\(O(nlogn)\)</span>排序算法执行的时间长。对于小数据量的排序，选择比较简单、不需要递归的插入排序算法。</p>
<p>同时，<code>qsort()</code>排序算法中还通过哨兵来简化代码、提高执行效率。</p>
<p>看来，一个优秀的源码是把各种细节做到了极致。不仅仅用到了三种排序算法，还考虑到递归潜在风险，通过手动实现堆来模拟递归以及哨兵模式。真的赞。</p>
<h2 id="课后思考">课后思考</h2>
<p>所熟悉的语言中的排序函数都是用什么排序算法实现的？有哪些优化技巧？</p>
<p><code>Python</code>中列表排序是在<code>CPython</code>中<a href="https://github.com/python/cpython/blob/main/Objects/listobject.c"><code>listobject.c</code></a>来实现的。说明文档：<a href="https://github.com/python/cpython/blob/main/Objects/listsort.txt">listsort.txt</a>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表(上)</title>
    <url>/2021/10/25/%E6%95%A3%E5%88%97%E8%A1%A8-%E4%B8%8A/</url>
    <content><![CDATA[<p>今天来学一下散列表（上）。</p>
<span id="more"></span>
<h2 id="散列思想">散列思想</h2>
<p>散列表的英文是<code>Hash Table</code>，所以也叫做“哈希表”或者“<code>Hash</code>表”。</p>
<p><strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p>
<p>文中举了一个例子来说明散列思想。假如学校有89名选手参加学校运动会。为了方便记录成绩，每个选手胸前都会贴上自己的参赛号码。参赛号码的规则如下，用6位数字来表示，比如051167，其中，前两位05表示年级，中间两位11表示班级，最后两位67代表第67位选手。通过截取参赛编号的最后两位作为数组下标，来存取选手信息数据。当通过参赛编号查询选手信息的时候，取参赛编号的后两位，作为数组下标，来读取数组中的数据。</p>
<p>这就是典型的散列思想。其中，参赛选手的编号叫做<strong>键</strong>或者<strong>关键字</strong>。把参赛编号转化为数组下标的映射方法就叫做<strong>散列函数</strong>（或者“Hash函数”“哈希函数”），例子中的散列函数就是截取参赛编号的最后两位。而散列函数计算得到的值就叫做<strong>散列值</strong>（或“Hash值”“哈希值”），例子中的散列值就是选手信息数据。</p>
<p><img src="hash_table.webp" /></p>
<p>规律：散列表用的就是数组支持下标随机访问，时间复杂度为<span class="math inline">\(O(1)\)</span>的特性。通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当按照键值查询元素时，再用同样的散列函数，将键值转化为数组下标，从对应的数组下标的位置取元素。</p>
<p>那么问题，如果利用散列函数映射的下标，已经被其它值占用了，怎么办？emm...散列冲突。</p>
<h2 id="散列函数">散列函数</h2>
<p>散列函数，顾名思义，是一个函数。可以定义为<code>hash(key)</code>，其中<code>key</code>表示元素的键值，<code>hash(key)</code>的值表示经过散列函数计算得到的散列值。</p>
<p>散列函数设计的基本要求：</p>
<ol type="1">
<li>散列函数计算得到的散列值是一个非负整数。</li>
<li>如果<code>key1=key2</code>，那么<code>hash(key1)==hash(key2)</code>。</li>
<li>如果<code>key1</code><span class="math inline">\(\neq\)</span><code>key2</code>，那么<code>hash(key1)</code><span class="math inline">\(\neq\)</span><code>hash(key2)</code>。</li>
</ol>
<p>真实的情况下，要想找到一个不同的<code>key</code>对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的<code>MD5</code>、<code>SHA</code>、<code>CRC</code>等哈希算法，也无法完全避免这种散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。</p>
<p>所以几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的。所以针对散列冲突问题，需要通过其他途径来解决。</p>
<h2 id="散列冲突">散列冲突</h2>
<h3 id="开放寻址法">开放寻址法</h3>
<p>核心思想：如果出现了散列冲突，就重新探测一个空闲位置，将其插入。</p>
<p>比较经典的探测方法，<strong>线性探测</strong>、<strong>二次探测</strong>、<strong>双重散列</strong>。</p>
<h4 id="线性探测">线性探测</h4>
<p>当往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<p>在散列表中查找元素的过程类似插入过程。通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是要找的元素；否则就顺序往后依次查找。如果<strong>遍历到数组中的空闲位置，还没有找到</strong>，就说明要查找的元素并没有在散列表中。<strong>这里数组中存储的值，不仅存储了目标值，还存储了对应求解<code>hash</code>时的<code>key</code>。</strong></p>
<p>对于使用线性探测法解决冲突的散列表，不能单纯地把要删除的元素设置为空。因为在查找的时候，通过线性探测方法，找到一个空闲位置，就说明查找的元素没有在散列表中，但是，<strong>如果这个空闲位置是后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在</strong>。可以将删除的元素，特殊标记为<code>delted</code>。当线性探测查找的时候，遇到标记为<code>deleted</code>的空间，并不是停下来，而是继续往下探测。</p>
<p>当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，可能需要探测整个散列表，所以最坏情况下的时间复杂度是<span class="math inline">\(O(n)\)</span>。</p>
<h4 id="二次探测">二次探测</h4>
<p>线性探测每次探测的步长是1，那探测的下标序列就是<code>hash(key)+0</code>、<code>hash(key)+1</code>、<code>hash(key)+2</code>...而二次探测的步长就变成了原来的“二次方”，探测的下标序列为<code>hash(key)+0</code>、<code>hash(key)</code>+<span class="math inline">\(1^2\)</span>、<code>hash(key)</code>+<span class="math inline">\(2^2\)</span>...</p>
<h4 id="双重散列">双重散列</h4>
<p>使用一组散列函数<code>hash1(key)</code>、<code>hash2(key)</code>、<code>hash3(key)</code>...先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p>
<p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，尽可能会保证散列表中有一定比例的空闲槽位。通过<strong>装载因子</strong>来表示空位的多少。</p>
<p>装载因子的计算公式是：<code>散列表的装载因子=填入表中的元素/散列表的长度</code>。装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p>
<h3 id="链表法">链表法</h3>
<p>链表法是一种更加常用的散列冲突解决方法，相比开放寻址法，要简单很多。在散列表中，每个“桶”或者“槽”会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中。</p>
<p><img src="hash_conflict.webp" /></p>
<p>当插入的时候，只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中，所以插入的时间复杂度为<span class="math inline">\(O(1)\)</span>。当查找、删除一个元素时，通过散列函数计算出对应的槽，然后遍历链表查找或者删除。时间复杂度跟链表的长度<code>k</code>成正比，即<span class="math inline">\(O(k)\)</span>。对于散列比较均匀的散列函数来说，理论来讲，<code>k=n/m</code>，其中<code>n</code>代表散列中数据的个数，<code>m</code>表示散列表中“槽”的个数。</p>
<h2 id="解答开篇">解答开篇</h2>
<p><code>Word</code>文档中单词拼写检查功能是如何实现的？</p>
<p>常见的英文单词有20万个左右，假设单词的平均长度是10个字母，平均一个单词占用10个字节的内存空间，那20万英文单词大约占2MB的存储空间，对于现代计算机来说，这个大小完全可以放在内存里面。所以可以用散列表来存储整个英文单词词典。</p>
<p>当用户输入某个英文单词时，拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，说明拼写可能有误，给予提示。</p>
<h2 id="课后思考">课后思考</h2>
<ol type="1">
<li><p>假设有10w条<code>URL</code>访问日志，如果按照访问次数给<code>URL</code>排序？</p>
<p>评论区大佬实在是太多了，自己也想到了散列函数中的链表法，但不够全面。</p>
<p>原答案：将10w条访问日志存入散列表，其中<code>key</code>为<code>URL</code>，<code>value</code>初始值为0。当第一条<code>URL</code>存入散列表，再有相同的<code>URL</code>存入会产生散列冲突。此时，再比较<code>key</code>是否相同。如果<code>key</code>相同，则是同一个<code>URL</code>，将相应的<code>value++</code>；如果<code>key</code>不相同，则存入链表下一个位置。可以在外部将最大值<code>K</code>记录下来。插入完成后，就可以取得当前<code>URL</code>的出现次数范围<code>0-K</code>。根据<code>K</code>的大小选取相应的算法。如果<code>K</code>值不大，可以采用桶排序。如果<code>K</code>值很大，可以采用快速排序。</p>
<p>为什么使用散列表进行存储：散列表存储完成以后，已经对<code>URL</code>完成了去重操作，同时拿到了最大次数<code>K</code>，根据<code>K</code>选择合适的排序算法。</p>
<p>时间复杂度分析：10w条<code>URL</code>存入散列表，时间复杂度为<span class="math inline">\(O(n)\)</span>。桶排序，时间复杂度为<span class="math inline">\(O(n)\)</span>。快速排序，时间复杂度<span class="math inline">\(O(nlogn)\)</span>。</p></li>
<li><p>有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？</p>
<p>以第一个字符串数组构建散列表，<code>key</code>为字符串，<code>value</code>为出现次数。再遍历第二个字符串数组，以字符串为<code>key</code>在散列表中查找，如果<code>value</code>大于0，则说明存在相同字符串，时间复杂度为<span class="math inline">\(O(n)\)</span>。这个答案是建立在字符串数组中没有重复字符串的情况之上，如果字符串数组本身存在重复字符串，应该比较<code>value</code>值是否发生了改变，如果<code>value</code>发生了改变，则说明存在相同字符串。</p></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表(下)</title>
    <url>/2021/10/27/%E6%95%A3%E5%88%97%E8%A1%A8-%E4%B8%8B/</url>
    <content><![CDATA[<p>接着学散列表（下）。这一节主要介绍散列表和链表是如何组合起来使用的，以及为什么散列表和链表会经常放到一块使用。</p>
<span id="more"></span>
<h2 id="lru缓存淘汰算法">LRU缓存淘汰算法</h2>
<p>回顾如何通过链表实现<code>LRU</code>缓存淘汰算法。首先需要维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够时，需要淘汰一个数据的时候，就直接将链表头部的结点删除（这里按照访问时间从大到小的意思是：头结点是最早访问的，尾结点是最新访问的）。当要缓存某个数据时，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的尾部；如果找到了，就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯用链表实现的<code>LRU</code>缓存淘汰算法的时间复杂度是<span class="math inline">\(O(n)\)</span>。</p>
<p>实际上，一个缓存系统主要包含这几个操作：</p>
<ul>
<li>往缓存里添加一个数据</li>
<li>从缓存里删除一个数据</li>
<li>在缓存里查找一个数据</li>
</ul>
<p>如果将散列表和链表两种数据结构组合使用，可以将时间复杂度都降低到<span class="math inline">\(O(1)\)</span>。</p>
<p><img src="lru.webp" /></p>
<p>这张图通过网友评论，理解了半天，先放原评论，<code>目前第一排第一个是头结点，第一排第二个是尾结点。当要删除结点时，按序从头删即可，当尾结点要添加新节点，或者将已有结点移动到尾结点，只要计算出该节点的散列值，然后放到对应散列行的最后，并和上一个尾结点（即目前的第一排第二个）进行双向连接即可</code>，自己一开始不能理解的是，为什么双向链表是这样连接起来的？其实应该是这样的，（不考虑删除元素，只考虑添加元素）第一次通过散列函数计算添加了第一槽里的第一个元素，然后第二次通过散列函数计算添加了第二槽里第一个元素，第三次通过散列函数计算发现和第二槽里的元素，发生了散列冲突，通过双向链表将两个元素连接起来，依次类推理解。另一位网友评论总结实在是太好了，<code>1)双向链表中的prev和next指针是示意图中的纵向指针，hnext是横向指针。2)hnext维护的是散列表中同一槽位的单链表（即连接hash值相同的结点）3)一个散列表搭档一个双向链表。散列表中同一槽位的结点通过hnext指针连接，也就是同意槽位上的单链表。</code><strong>双向链表维护的是时间线，节点的淘汰和增加就在双向链表中进行。</strong>散列表和链表两种数据结构组合使用既解决了链表查询时间复杂度高的问题，又不需要像数组在空间不足时需要动态扩容。</p>
<h3 id="时间复杂度">时间复杂度</h3>
<p>查找数据。散列表中查找数据的时间复杂度为<span class="math inline">\(O(1)\)</span>（如果装载因子比较大的时候，发生散列冲突。如果链表结点个数少于8时，时间复杂度为<span class="math inline">\(O(1)\)</span>，否则时间复杂度可能为<span class="math inline">\(O(logn)\)</span>）。当找到数据之后，需要把它移动到双向链表的尾部（移动到双向链表的尾部之后，结点在哈希表中的位置并不会改变。<code>hnext</code>指针没有改变，只改变<code>next</code>指针）。</p>
<p>删除数据。首先找到数据所在的结点，然后将结点删除。借住散列表，可以在<span class="math inline">\(O(1)\)</span>时间复杂度里找到要删除的结点。同时，双向链表可以通过前驱指针<span class="math inline">\(O(1)\)</span>时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要<span class="math inline">\(O(1)\)</span>的时间复杂度（这里应该还需要删除拉链中的结点，时间复杂度应该也考虑到）。</p>
<p>添加数据。首先查看这个数据是否已经在缓存中。如果在，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。整个过程涉及的查找操作都可以通过散列表来完成。其他的操作，比如删除头结点，链表尾部插入数据等，都可以在<span class="math inline">\(O(1)\)</span>时间复杂度内完成。</p>
<p>所以，这三个操作的时间复杂度都是<span class="math inline">\(O(1)\)</span>。</p>
<h2 id="redis-有序集合">Redis 有序集合</h2>
<p>在有序集合中，每个成员对象有两个重要的属性，<strong>key</strong>（键值）和<strong>score</strong>（分值）。不仅会通过<code>score</code>来查找数据，还会通过<code>key</code>来查找数据。</p>
<p>举例说明，比如用户积分榜有这样一个功能：可以通过用户的<code>ID</code>来查找积分信息，也可以通过积分区间来查找用户<code>ID</code>或者姓名信息。这里包含<code>ID</code>、姓名和积分的用户信息，就是成员对象，用户<code>ID</code>就是<code>key</code>，积分就是<code>score</code>。</p>
<p>细化一下<code>Redis</code>有序集合的操作：</p>
<ul>
<li>添加一个成员对象</li>
<li>按照键值来删除一个成员对象</li>
<li>按照键值来查找一个成员对象</li>
<li>按照分值区间查找数据，比如查找积分在<code>[100, 356]</code>之间的成员对象</li>
<li>按照分值从小到大排序成员变量</li>
</ul>
<p>如果仅仅按照<strong>分值</strong>将成员对象组织成跳表（要求有序）的结构，那按照键值来删除、查询成员对象就会很慢，解决方法与<code>LRU</code>缓存淘汰算法的解决方法类似。可以按照键值构建一个散列表，这样按照<code>key</code>来删除、查找一个成员对象的时间复杂度就变成了<span class="math inline">\(O(1)\)</span>。</p>
<h2 id="java-linkedhashmap">Java LinkedHashMap</h2>
<p><code>LinkedHashMap</code>也是通过散列表和链表组合在一起的。</p>
<p>它支持按照插入顺序遍历数据，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; m = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">m.put(<span class="number">3</span>, <span class="number">11</span>);</span><br><span class="line">m.put(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">m.put(<span class="number">5</span>, <span class="number">23</span>);</span><br><span class="line">m.put(<span class="number">2</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry e : m.entrySet()) &#123;</span><br><span class="line">  	System.out.println(e.getKey());  <span class="comment">// 3, 1, 5, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还支持按照访问顺序来遍历数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; m = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">10</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">m.put(<span class="number">3</span>, <span class="number">11</span>);</span><br><span class="line">m.put(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">m.put(<span class="number">5</span>, <span class="number">23</span>);</span><br><span class="line">m.put(<span class="number">2</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">m.put(<span class="number">3</span>, <span class="number">26</span>);</span><br><span class="line">m.get(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry e : m.entrySet()) &#123;</span><br><span class="line">  	System.out.println(e.getKey());  <span class="comment">// 1, 2, 3, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实按照访问时间排序的<code>LinkedHashMap</code>本身就是一个支持<code>LRU</code>缓存淘汰策略的缓存系统。</p>
<p><code>LinkedHashMap</code>是通过双向链表和散列表这两种数据结构组合实现的。<code>LinkedHashMap</code>中的“<code>Linked</code>”实际上指的是双向链表，并非只用链表法解决散列冲突。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>为什么散列表和链表经常一块使用？</p>
<p>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就是说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那需要将散列表中的数据拷贝到数据中，然后排序，再遍历。</p>
<p>因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当希望按照顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，将散列表和链表（或者跳表）结合在一起使用。</p>
<h2 id="课后思考">课后思考</h2>
<ol type="1">
<li><p>如果把例子中的双向链表改成单链表，还能否正常工作呢？</p>
<p>删除一个元素时，虽然能<span class="math inline">\(O(1)\)</span>时间复杂度找到目标结点，但是要删除该结点需要拿到前一个结点的指针，遍历到前一个结点时间复杂度会变成<span class="math inline">\(O(n)\)</span>，所以使用双向链表实现比较合适。</p></li>
<li><p>假设猎聘网有10万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。那么问题是如果在内存里存储这10万个猎头的<code>ID</code>和积分信息，让它能够支持这样几个操作：</p>
<ul>
<li>根据猎头的<code>ID</code>快速查找、删除、更新这个猎头的积分信息</li>
<li>查找积分在某个区间的猎头<code>ID</code>列表</li>
<li>查找按照积分从小到大排名在第<code>x</code>位到第<code>y</code>位之间的猎头<code>ID</code>列表</li>
</ul>
<p>这个问题跟<code>Redis</code>有序集合中举的例子很像。1）ID在散列表中所以可以<span class="math inline">\(O(1)\)</span>查找。2）积分以跳表存储，跳表支持区间查询。3）这点根据目前的学习暂时无法实现。</p></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表(中)</title>
    <url>/2021/10/26/%E6%95%A3%E5%88%97%E8%A1%A8-%E4%B8%AD/</url>
    <content><![CDATA[<p>接着来学一下散列表（中）。</p>
<span id="more"></span>
<p>散列表的查询效率并不能笼统地说成是<span class="math inline">\(O(1)\)</span>。它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计地不好，或者装载因子过高，都可能导致散列冲突的概率升高，查询效率下降。</p>
<p>在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果使用的是基于链表的冲突解决办法，那么，散列表就会退化为链表，查询的时间复杂度就会从<span class="math inline">\(O(1)\)</span>急剧退化为<span class="math inline">\(O(n)\)</span>。</p>
<p>如果散列表中有10万个数据，退化后的散列表查询的效率就下降了10万倍。更直接点，如果之前运行100次查询只需要0.1秒，那现在就需要1万秒。这样就有可能因为查询操作消耗大量CPU或者线程资源，导致系统无法响应其他请求，从而达到服务攻击（DoS）的目的。这也是散列表碰撞攻击的基本原理。</p>
<h2 id="如何设计散列函数">如何设计散列函数</h2>
<p>首先，<strong>散列函数的设计不能太复杂</strong>。过于复杂的散列函数，势必会消耗很多计算时间，也间接地影响到散列表的性能。其次，<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突，而且即使出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p>
<p>第一个例子就是学生运动会的例子，通过分析参赛编号的特征，把编号中的后两位做为散列值。类似的散列函数处理手机号码，取手机号的后四位作为散列值。这种设计方法一般叫做“数据分析法”。</p>
<p>散列函数的设计方法还有很多，比如直接寻址法，平方取中法、折叠法、随机数法等。</p>
<h2 id="装载因子过大">装载因子过大</h2>
<p>装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。</p>
<p>对于动态散列表来说，数据集合是频繁变动的，事先无法预估将要加入的数据个数，所以也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。</p>
<p>针对散列表，当装载因子过大时，可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容都申请一个原来散列表大小两倍的空间。如果原来散列表的的装载因子是0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了0.4。</p>
<p>针对数据的扩容，数据搬移比较简单。但是针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以需要通过散列函数重新计算每个数据的存储位置。</p>
<p>插入一个数据，最好情况下，不需要扩容，最好时间复杂度为<span class="math inline">\(O(1)\)</span>。最坏情况下，散列表装载因子过高，启动扩容，需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度为<span class="math inline">\(O(n)\)</span>。通过摊还分析法，均摊情况下，时间复杂度接近最好情况，就是<span class="math inline">\(O(1)\)</span>。</p>
<p>实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果对空间消耗非常敏感，可以在装载因子小于某个值之后，启动动态缩容。反之则不需要。</p>
<p>装载因子阈值设置需要得当。如果太大，会导致冲突过多；如果过小，会导致内存浪费严重。需要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；反之可以增大装载因子的阈值。</p>
<h2 id="如何避免低效扩容">如何避免低效扩容</h2>
<p>大部分情况下，动态扩容的散列表插入一个数据都很快，但是在特殊情况下，当装载因子已经达到阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至无法接受。</p>
<p>这个时候，“一次性”扩容的机制就不合适了。为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成。</p>
<p>当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中。</p>
<p><img src="hash_table.webp" /></p>
<p>对于查询操作，为了兼容新、老散列表中的数据，先从散列表中查找，如果没找到，再去老的散列表中查找。</p>
<p>通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是<span class="math inline">\(O(1)\)</span>。</p>
<h2 id="如何选择冲突解决方法">如何选择冲突解决方法</h2>
<ol type="1">
<li><p>开放寻址法</p>
<p>优点：散列表中的数据都存储在数组中，可以有效地利用CPU缓存加快查询速度。而且，序列化起来比较简单</p>
<p>缺点：删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表来说，冲突的代价更高。</p>
<p>总结：当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是<code>Java</code>中<code>ThreadLocalMap</code>使用开放寻址法解决散列冲突的原因。</p></li>
<li><p>链表法</p>
<p>优点：链表法对内存的利用率比开放寻址法更高。其次，链表法对大装载因子的容忍度更高，只要散列函数的值随机均匀，即便装载因子变成10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比顺序查找还是快很多。</p>
<p>缺点：链表要存储指针，是比较消耗内存的。其次，链表中的结点时零散分布在内存中，是不连续的，对CPU缓存不友好。</p>
<p>总结：基于链表的散列冲突处理方法比较适合存储大对象，大数据量的散列表，而且，比起开放寻址法，更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p></li>
</ol>
<h2 id="工业级散列表举例分析">工业级散列表举例分析</h2>
<p>以<code>Java</code>中的<code>HashMap</code>这样的工业级散列表举例说明。</p>
<h3 id="初始大小">初始大小</h3>
<p><code>HashMap</code>默认的初始大小是16。如果事先直到大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高<code>HashMap</code>的性能。</p>
<h3 id="装载因子和动态扩容">装载因子和动态扩容</h3>
<p>最大装载因子默认是0.75，当<code>HashMap</code>中元素个数超过<code>0.75*capacity</code>（<code>capacity</code>表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p>
<h3 id="散列冲突解决办法">散列冲突解决办法</h3>
<p><code>HashMap</code>底层采用链表法来解决冲突。在<code>JDK1.8</code>版本中，对<code>HashMap</code>做进一步优化，引入了红黑树。当链表长度太长（默认超过8）时，链表就转换为红黑树，可以利用红黑树快速增删改查的特性，提高<code>HashMap</code>的性能。当红黑树结点个数少于8个的时候，又会将红黑树转换为链表。</p>
<p>评论区中有大佬指出，当<code>HashMap</code>中结点少于6时，会由红黑树变成链表，当<code>HashMap</code>中结点数为6时，链表的平均查找<code>6/2=3</code>。当<code>HashMap</code>中结点多于8时，会由链表变成红黑树，红黑树的平均查找为<span class="math inline">\(log_28=3\)</span>，如果继续使用链表，平均查找长度<code>8/2=4</code>，这才有转换为树的必要。还有一个问题就是6和8的选择，6和8之间有一个7可以有效防止链表和红黑树频繁转换。假设一下如果设计成<code>HashMap</code>中数据超过8，由链表转换成红黑树；<code>HashMap</code>中数据少于8，由红黑树转换成链表。若一个<code>HashMap</code>不停地插入、删除，<code>HashMap</code>中的个数不停地在8左右徘徊，就会频繁发生链表转红黑树，红黑树转链表，效率会非常低。</p>
<p>这里自己翻了一下，有三个问题，这里记录一下</p>
<p>1.为什么要转红黑树？</p>
<p>因为查找元素，红黑树的时间复杂度为<span class="math inline">\(O(logn)\)</span>，而链表的时间复杂度是<span class="math inline">\(O(n)\)</span></p>
<p>2.为什么不直接使用红黑树，而是要先使用链表，链表结点大于8后，再转为红黑树？</p>
<p>这个问题，在<code>HashMap</code>源码中的174行注释中写到，<code>Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD)</code>。意思就是因为树节点是链表结点大小的两倍，所以只有在容器中包含足够的结点保证才会使用它。尽管红黑树的查找效率更高，但是在结点数比较小的时候，对于红黑树来说内存的劣势会超过查找等操作的优势，自然使用链表更好。</p>
<p>3.为什么链表结点大于8时转为红黑树，而不是9、10？</p>
<p>这一点也是源码中179行注释中写到，源码的贡献者进行大量实验发现，<code>hash</code>碰撞发生8次的概率已经降低到了<code>0.00000006</code>，再往后调整并没有很大意义。理想情况下，在随机哈希码下，哈希表中结点的频率遵循泊松分布。</p>
<h3 id="散列函数">散列函数</h3>
<p>散列函数的设计并不复杂，追求的是简单高效、分布均匀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode();</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capicity -<span class="number">1</span>); <span class="comment">//capicity表示散列表的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hashCode()</code>返回的是<code>Java</code>对象的<code>hash code</code>。<code>String</code>类型的对象的<code>hashCode()</code>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = <span class="keyword">this</span>.hash;</span><br><span class="line">    <span class="keyword">if</span>(var1 == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span>[] var2 = <span class="keyword">this</span>.value;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; <span class="keyword">this</span>.value.length; ++var3) &#123;</span><br><span class="line">        var1 = <span class="number">31</span> * var1 + var2[var3];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.hash = var1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合评论区的讨论，这里记录一下。</p>
<p>第一步，根据<code>key</code>通过<code>hashCode()</code>得到<code>hash</code>值，具体代码实现<code>int h = key.hashCode();</code></p>
<p>第二步，将得到的<code>hash</code>值映射到数组中的位置，具体代码实现<code>(h ^ (h &gt;&gt;&gt; 16)) &amp; (capacity - 1)</code>。</p>
<p>然后把评论区原答案也放到这里吧。<code>JDK hashMap</code>源码，<code>hash</code>表中数组位置的计算分两步：</p>
<p>1.计算<code>hash</code>值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash(Object key) &#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步有一种说法，叫它扰动函数，为什么要右移16位再与本身异或呢？</p>
<ol type="1">
<li>首先<code>hashCode()</code>返回值<code>int</code>最高是32位，如果直接拿<code>hashCode()</code>返回值作为下标，大概40亿（2的32次幂=4294967296）的映射空间，只要哈希函数映射的比较均匀松散，一般是很难出现碰撞的。问题是一个40亿长度的数组，内存是放不下的。</li>
<li>所以，用自己的高半区和底半区做异或，混合原始哈希码的高位和低位，关键是以此来加大低位的随机性。为后续计算<code>index</code>截取低位，保证低位的随机性。</li>
<li>这样设计保证了对象的<code>hashCode</code>的32位值只要有一位发生改变，整个<code>hash()</code>返回值就会改变，高位的变化会反应到低位里，保证了<code>hash</code>值的随机性。</li>
</ol>
<p>2.在插入或者查找的时候，计算<code>key</code>被映射到桶的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int index = hash(key) &amp; (capacity - 1)</span><br></pre></td></tr></table></figure>
<p><code>hash()</code>扰动函数计算的值和<code>hash</code>表当前的容量减一，做按位与运算。</p>
<p>这一步，为什么要减一，又为什么要按位与运算？因为<code>A % B = A &amp; (B-1)</code>，当B是2的指数时，等式成立。本质上使用了<code>除留余数法</code>，保证了<code>index</code>的位置分布均匀。</p>
<p>为什么<code>HashMap</code>的数组长度必须是2的整次幂？数组长度是2的整次幂时，（数组长度-1）正好相当于一个“低位掩码”，“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标来访问。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>如何设计一个工业级的散列函数？</p>
<ol type="1">
<li>工业级的散列表应该具有哪些特性？
<ul>
<li>快速地查询、插入、删除操作</li>
<li>内存占用合理，不能浪费过多的内存空间</li>
<li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况</li>
</ul></li>
<li>如何实现一个这样的散列表？
<ul>
<li>设计一个合适的散列函数</li>
<li>定义装载因子阈值，并且设计动态扩容策略</li>
<li>选择合适的散列冲突解决办法</li>
</ul></li>
</ol>
<p>此外，还需要结合具体的业务场景、具体的业务数据来具体分析。</p>
<h2 id="课后思考">课后思考</h2>
<p>在你熟悉的编程语言中，哪些数据类型底层是基于散列表实现的？散列函数是如何设计的？散列冲突是通过哪种方法解决的？是否支持动态扩容呢？</p>
<p><code>Python</code>中数据类型<code>dict</code>底层是基于散列表来实现的。通过类似开放寻址法来解决散列冲突的。同时支持动态扩容。</p>
<p>本篇文章中其实有很多知识点没搞清楚，比如说<code>Java</code>中的<code>hashCode()</code>到底是怎么实现的？看了下<a href="https://zhuanlan.zhihu.com/p/33915892">java中的hashCode是怎么来的</a>，表示没搞清楚。还有<code>Python</code>中的<code>hash()</code>是怎么实现的？散列函数是如何设计的？装载因子等于多少的时候会自动扩容，扩容大小是多少？<a href="https://github.com/python/cpython/blob/main/Objects/dictobject.c">Python-dict源码地址</a>，表示没看懂。</p>
<p>参考链接：</p>
<ol type="1">
<li><a href="https://blog.csdn.net/sufu1065/article/details/104954306">HashMap 为什么在链表长度为 8 的时候转红黑树，为啥不能是 9 是 10？</a></li>
<li><a href="https://blog.csdn.net/Liu_Wd/article/details/108052428">详解：HashMap红黑树的阈值为什么是8？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/74003719">Python字典dict实现原理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33915892">java中的hashCode是怎么来的</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2021/09/15/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>​ 作为一个程序员，数据结构与算法是基础知识。就好比是武侠小说里的“内功心法”，只有掌握了内功心法，才能以不变应万变。接下来会跟着极客时间里王争老师的专栏《数据结构与算法之美》，对这一块知识进行学习总结。</p>
<span id="more"></span>
<h2 id="定义">定义</h2>
<blockquote>
<p>数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p>
</blockquote>
<p>重点理解：</p>
<ol type="1">
<li><p>线性表。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈等都是线性表结构。非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为数据之间并不是简单的前后关系。</p>
<p>这里我的理解是，数组和链表是两种最基础的数据结构。队列、栈等线性表结构和二叉树、堆等非线性表都可以通过数组和链表来实现。或者说数组和链表是数据在内存中的表示方式，要么是连续的(数组)，要么是非连续的(链表)。</p></li>
<li><p>连续的内存空间和相同类型的数据。优点：随机访问。缺点：插入删除数据时，为保证连续性，需要做数据搬移操作。</p></li>
</ol>
<h2 id="随机访问">随机访问</h2>
<p>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，会通过寻址公式，来计算该元素存储的内存地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure>
<p>数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度O(1)；数组适合查找，查找的复杂度为O(1)”。这种表述不准确，数组是适合查找操作，但是查找的时间复杂度并不是O(1)。即使是排好序的数组，使用二分查找，时间复杂度为O(logn)。所以，正确的表述是数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。</p>
<p>关于这两种表述方式，我理解之间的差异是，一个通过下标查找<code>value</code>，通过寻址方式，时间复杂度是O(1)；另一种是在数组中查找<code>value</code>，排好序的数据，通过二分查找，时间复杂度为O(logn)。(直观理解为字典里根据<code>key</code>查找<code>value</code>和遍历字典查找<code>value</code>的区别，这种理解方式可能不太恰当)</p>
<h2 id="低效的插入和删除">低效的“插入”和“删除”</h2>
<h3 id="插入操作">插入操作</h3>
<p>平均时间复杂度O(n)。计算方式：<code>(1+2+....+n)/n=O(n)</code></p>
<p>改进：将要插入指定位置的原元素放到最后，然后将新元素插入指定位置。时间复杂度O(1)</p>
<h3 id="删除操作">删除操作</h3>
<p>平均时间复杂度O(n)</p>
<p>改进：先记录下已经删除的数据，当数组没有更多空间存储数据时，再触发执行一次真正的删除操作(JVM标记清除垃圾回收算法的核心思想)。时间复杂度视情况而定</p>
<h2 id="警惕数组的访问越界问题">警惕数组的访问越界问题</h2>
<p>在C语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。</p>
<p>数组越界在C语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p>
<p>很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。但并非所有的语言都像C语言一样，把数组越界检测的工作丢给程序员来做，像Java本身就会做越界检查，会抛出越界异常。</p>
<p>文中的代码我在Mac终端通过<code>gcc</code>编译后执行，打印了四次<code>hello world</code>后异常退出，如图，</p>
<p><img src="index_out_of_bound.jpeg" /></p>
<p>这个问题在文章后的评论里找到了答案：<code>gcc</code>有一个编译选项(<code>-fno-stack-protectot</code>)用于关闭堆栈保护功能。默认情况下启动了堆栈保护，不管<code>i</code>声明在前还是在后，<code>i</code>都会在数组之后压栈，只会循环四次；如果关闭堆栈保护功能，则会出现死循环。C语言代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">		arr[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容器能否完全替代数组">容器能否完全替代数组</h2>
<p>针对数组类型，很多语言都提供了容器类，比如<code>Java</code>中的<code>ArrayList</code>、<code>C++ STL</code>中的<code>vector</code>。我的理解，平时<code>Python</code>中经常使用的<code>list</code>、<code>dict</code>、<code>set</code>等提供操作<code>api</code>的类都称之为容器类。</p>
<p><code>ArrayList</code>最大的优势就是<strong>可以将很多数组操作的细节封装起来</strong>。比如数组插入、删除数据时需要搬移其他数据等。另外，还有一个优势，就是支持<strong>支持动态扩容</strong>。</p>
<p>需要注意的是，扩容操作涉及内存申请和数据搬移，是比较耗时的，所以，如果事先能确定需要存储的数据大小，最好在<strong>创建<code>ArrayList</code>的时候事先指定数据大小</strong></p>
<p>总结：</p>
<ol type="1">
<li><code>Java ArrayList</code>无法存储基本数据类型，比如<code>int</code>、<code>long</code>，需要封装为<code>Integer</code>、<code>Long</code>类，而<code>Autoboxing(自动装箱)</code>、<code>Unboxing(自动拆箱)</code>则有一定的性能消耗，所以如果特别关注性能，或希望使用基本数据类型，就可以选用数组。</li>
<li>如果数据大小事先已知，并且对数据的操作非常简单，用不到<code>ArrayList</code>提供的大部分方法，也可以直接使用数组。</li>
<li>当表示多维数组时，用数组往往会更加直观。比如，<code>Object[][] array</code>；而用容器的话，<code>ArrayList&lt;ArrayList&lt;object&gt;&gt; array</code></li>
</ol>
<p>对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能，但是如果做一些特别底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>为什么大多数编程语言中，数组要从0开始编号，而不是从1开始呢？</p>
<ol type="1">
<li>通过寻址公式来看，从0开始编号，<code>a[k]_address = base_address + k * data_type_size</code>；从1开始编号，<code>a[k]_address = base_address + (k-1) * data_type_size</code>。不难发现，从1开始编号，每次随机访问数组元素都多了一次减法元素，对于CPU来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。</li>
<li>历史原因。C语言设计者用0开始计数数组下标，之后的Java、JavaScript等高级语言都效仿了C语言，或者说，为了在一定程度上减少C语言程序员学习Java的学习成本，因此继续沿用了从0开始计数的习惯。</li>
</ol>
<h2 id="课后思考">课后思考</h2>
<ol type="1">
<li><p>JVM的标记清除垃圾回收算法的核心理念</p>
<p>大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有的<code>GC ROOTS</code>，将所有的<code>GC ROOTS</code>可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。</p>
<p>不足：1. 效率问题，标记和清理效率都不高，但是当知道只有少数垃圾产生时会很高效。2.空间问题，会产生不连续的内存空间碎片。</p>
<p>联想：Python中的垃圾回收机制：主要通过引用计数法进行垃圾回收，通过“标记-清除”解决容器对象可能产生的循环引用问题；通过“分代回收”以空间换时间的方法提高垃圾回收率</p></li>
<li><p>二维数组的内存寻址公式</p>
<p>对于<code>m*n</code>的数组，<code>a[i][j] (i&lt;m, j&lt;n)</code>的地址为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address = base_address + (i*n + j) * data_type_size</span><br></pre></td></tr></table></figure></li>
</ol>
<p>参考链接：</p>
<ol type="1">
<li><p><a href="https://zhuanlan.zhihu.com/p/83251959">Python垃圾回收机制！非常实用</a></p></li>
<li><p><a href="https://blog.csdn.net/qq_42019874/article/details/111599687">二维数组和多维数组的本质及寻址方式</a></p></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2021/09/18/%E6%A0%88/</url>
    <content><![CDATA[<p>今天来学习栈。</p>
<span id="more"></span>
<h2 id="如何理解栈">如何理解“栈”</h2>
<p><strong>后进者先出，先进者后出</strong>，这就是典型的”栈“结构。</p>
<p>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这是就应该首选”栈“这种数据结构。</p>
<h2 id="如何实现一个栈">如何实现一个“栈”</h2>
<p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，叫做<strong>顺序栈</strong>，用链表实现的栈，叫做<strong>链式栈</strong>。</p>
<h3 id="基于数组实现">基于数组实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.items = []</span><br><span class="line">        self.length = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.items) == self.length:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>, item)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.items) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;栈为空&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stack = ArrayStack(<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        a.push(<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(a.items)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(a.pop())</span><br></pre></td></tr></table></figure>
<h3 id="基于链表实现">基于链表实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data, next_node=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = next_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.<span class="built_in">next</span> = self.__head</span><br><span class="line">        self.__head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.__head:</span><br><span class="line">            data = self.__head.data</span><br><span class="line">            self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        data = []</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            data.append(cur.data)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;-&gt;&#x27;</span>.join(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stack = LinkedStack()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        stack.push(<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(stack)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(stack.pop(), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>时间复杂度<code>O(1)</code>，空间复杂度<code>O(1)</code></p>
<h2 id="支持动态扩容的顺序栈">支持动态扩容的顺序栈</h2>
<p>当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。</p>
<p>所以如果要实现一个支持动态扩容的栈，只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数组搬移到新数组中。</p>
<p><img src="array_stack.webp" /></p>
<p>实际上，支持动态扩容的顺序栈，平时开发中并不常用到。这里还是重点练习一下复杂度分析。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p>对于出栈操作来说，不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是<code>O(1)</code></p>
<p>对于入栈操作来说，当栈中有空闲空间时，最好情况时间复杂度是<code>O(1)</code>，当空间不够时，就需要重新申请内存和数据搬移，最坏情况时间复杂度是<code>O(n)</code>。</p>
<p>利用<strong>摊还分析法</strong>来分析平均时间复杂度。为了分析的方便，做一些假设和定义：</p>
<ul>
<li>栈空间不够时，重新申请一个是原来大小两倍的数组；</li>
<li>为了简化分析，假设只有入栈操作没有出栈操作；</li>
<li>定义不涉及内存搬移的入栈操作为<code>simple-push</code>操作，时间复杂度为<code>O(1)</code></li>
</ul>
<p>如果当前栈大小为K，并且已满，当再有新的数据要入栈时，就需要重新申请2倍大小的内存，并且做K个数据的搬移操作，然后再入栈。但是，接下来的K-1次入栈操作，都不需要再重新申请内存和搬移数据，所以这K-1次入栈操作都只需要一个<code>simple-push</code>操作就可以完成。</p>
<p><img src="push_stack.jpg" /></p>
<p>这里有一个疑惑点，为什么是K-1次入栈操作？分析，当前栈大小为K，并且已满。当K+1次入栈时，触发内存申请(申请空间为2K)和数据搬移(K个数据)操作，然后再将K+1个元素入栈，接下来的2K-K-1=K-1次入栈操作不需要触发内存申请和数据搬移。</p>
<p><strong>结论：</strong>均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度O都是<code>O(1)</code>，只有在个别时刻才会退化为<code>O(n)</code>，所以把耗时多的入栈操作时间均摊到其他入栈操作上，平均情况下的耗时就接近<code>O(1)</code></p>
<h2 id="栈在函数调用中的应用">栈在函数调用中的应用</h2>
<p>栈比较经典的一个应用场景就是<strong>函数调用栈</strong>。</p>
<p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">   ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">   reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行到<code>add()</code>函数时，函数调用栈的情况</p>
<p><img src="call_stack.webp" /></p>
<p>这里有一个疑惑点，为什么<code>x=3</code>、<code>y=5</code>比<code>sum=0</code>先入栈，翻了翻评论，应该是因为<code>x</code>和<code>y</code>是函数参数，所以先入栈。</p>
<h2 id="栈在表达式求值中的应用">栈在表达式求值中的应用</h2>
<p>栈的另一个应用场景，<strong>表达式求值</strong>。</p>
<p>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p>
<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈(为了拿到下一个操作数)；如果比运算符栈顶元素的优先级低或相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行运算，再把计算完的结果压入操作数栈，继续比较。</p>
<h3 id="后缀逆波兰表达式定义">后缀(逆波兰)表达式定义</h3>
<p><code>9+(3-1)*3+10/2</code>用后缀表示法表示<code>9 3 1 - 3 * 10 2 / +</code></p>
<p>叫后缀的原因在于所有的符号都是在要运算数字的后面出现</p>
<h3 id="后缀表达式计算结果">后缀表达式计算结果</h3>
<p>后缀表达式：<code>9 3 1 - 3 * 10 2 / +</code></p>
<p>规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p>
<h4 id="代码">代码</h4>
<p>待补充...</p>
<h3 id="中缀表达式转后缀表达式">中缀表达式转后缀表达式</h3>
<p>平时所用的标准四则运算表达式，<code>9+(3-1)*3+10/2</code>叫做中缀表达式。</p>
<p>规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p>
<h4 id="代码-1">代码</h4>
<p>待补充...</p>
<h2 id="栈在括号匹配中的应用">栈在括号匹配中的应用</h2>
<p>思路：用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如<code>(</code>和<code>)</code>、<code>[</code>和<code>]</code>、<code>&#123;</code>和<code>&#125;</code>匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p>
<h3 id="代码-2">代码</h3>
<p>待补充...</p>
<h2 id="解答开篇">解答开篇</h2>
<p>如何实现浏览器的前进、后退功能？</p>
<p>思路：使用两个栈，X和Y，我们把首次浏览的页面依次压入栈X，点击后退按钮时，再依次从栈X中出栈，并将出栈的数据依次放入栈Y。当我们点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X没有数据时，那就说明没有页面可以继续后退浏览了。当栈Y中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p>
<h3 id="代码-3">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;LinkedStack.py&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> LinkedStack <span class="keyword">import</span> LinkedStack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewLinkedStack</span>(<span class="params">LinkedStack</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Browser</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 存储要后退的页面</span></span><br><span class="line">        self.x = NewLinkedStack()</span><br><span class="line">        <span class="comment"># 存储要前进的页面</span></span><br><span class="line">        self.y = NewLinkedStack()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">can_forward</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            是否可以前进</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.y.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">can_back</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            是否可以后退</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.x.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            打开页面</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Open new url: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url))</span><br><span class="line">        <span class="comment"># 将浏览过的页面压入栈x</span></span><br><span class="line">        self.x.push(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            后退</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.x.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将浏览过的url从栈x拿出来 实现后退</span></span><br><span class="line">        url = self.x.pop()</span><br><span class="line">        self.y.push(url)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;back: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            前进</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.y.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将后退的页面从栈y拿出来 实现前进</span></span><br><span class="line">        url = self.y.pop()</span><br><span class="line">        self.x.push(url)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;forward: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    browser = Browser()</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> browser.can_back():</span><br><span class="line">        browser.back()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> browser.can_forward():</span><br><span class="line">        browser.forward()</span><br><span class="line"></span><br><span class="line">    browser.back()</span><br><span class="line">    browser.back()</span><br><span class="line">    browser.back()</span><br></pre></td></tr></table></figure>
<h3 id="感受">感受</h3>
<ol type="1">
<li>写这些代码特别锻炼自己抽象能力。</li>
</ol>
<h2 id="课后思考">课后思考</h2>
<ol type="1">
<li><p>为什么函数调用要用栈来保存临时变量？用其他数据结构不行吗？</p>
<p>以下答案来自评论区置顶</p>
<p>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。</p>
<p>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p></li>
<li><p><code>JVM</code>内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储<code>Java</code>中的对象。那么<code>JVM</code>里面的“栈”跟我们这里说的“栈”是不是一回事，如果不是，那它为什么又叫作“栈”呢？</p>
<p>以下答案来自评论区置顶</p>
<p>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。</p>
<p>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区。动态数据区又分为栈区和堆区。</p>
<ul>
<li><p>代码区：存储方法体的二进制代码。高级调度(作业调度)、中级调度(内存调度)、低级调度(进程调度)控制代码区执行代码的切换。</p></li>
<li><p>静态数据区：存储全局变量、静态变量、常量。常量包括<code>final</code>修饰的常量和<code>String</code>常量。系统自动分配和回收。</p></li>
<li><p>动态数据区：</p>
<ul>
<li>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。</li>
<li>堆区：<code>new</code>一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</li>
</ul></li>
</ul></li>
</ol>
<p>参考链接：</p>
<ol type="1">
<li><a href="https://baozoulin.gitbook.io/-data-structure/di-4-zhang-zhan-yu-dui-lie/48zhan-de-ying-yong-2014-2014-si-ze-yun-suan-biao-da-shi-qiu-zhi">栈的应用——四则运算表达式求值</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>线性排序</title>
    <url>/2021/10/17/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>今天来学习三种时间复杂度是<code>O(n)</code>的排序算法：桶排序、计数排序、基数排序。</p>
<span id="more"></span>
<p>因为这些排序算法的时间复杂度是线性的，所以把这类排序算法叫做<strong>线性排序</strong>。之所以能做到线性的时间复杂度，主要原因是，这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。</p>
<p>学习重点是掌握这些排序算法的适用场景。</p>
<h2 id="桶排序">桶排序</h2>
<h3 id="核心思想">核心思想</h3>
<p>将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<p><img src="bucket_sort.webp" /></p>
<h3 id="时间复杂度">时间复杂度</h3>
<p>如果要排序的数据有<code>n</code>个，把它均匀地划分到<code>m</code>个桶内，每个桶里就有<code>k=n/m</code>个元素。每个桶内部使用快速排序，时间复杂度为<code>O(k*logk)</code>。<code>m</code>个桶排序的时间复杂度就是<code>O(m*k*logk)</code>，因为<code>k=n/m</code>，所以整个桶排序的时间复杂度就是<code>O(n*log(n/m))</code>。当桶的个数<code>m</code>接近数据个数<code>n</code>时，<code>log(n/m)</code>就是一个非常小的常量，这个时候桶排序的时间复杂度接近<code>O(n)</code>。</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>空间复杂度为<code>O(n+m)</code>。</p>
<h3 id="稳定性">稳定性</h3>
<p>如果每次桶内使用快速排序，则桶排序是不稳定的。而每次桶内使用归并排序，则桶排序是稳定的排序算法。</p>
<h3 id="前提条件">前提条件</h3>
<p>首先，要排序的数据需要很容易就能划分成<code>m</code>个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</p>
<p>其次，数据在各个桶之间的分布是比较均匀的。</p>
<h3 id="适用场景">适用场景</h3>
<p><strong>桶排序比较适合用在外部排序中。</strong>所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>
<p>比如有10GB的订单数据，希望按订单金额（假设金额都是正整数）进行排序，但是内存有限，只有几百MB，没办法一次性把10GB的数据都加载到内存中，这时候该怎么办？</p>
<p>先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是1元，最大是10万元。我们将所有订单根据金额划分到100个桶里，第一个桶我们存储金额在1元到1000元之间的订单，第二桶存储金额在1001元到2000元之内的订单，以此类推。每个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02...99）。</p>
<p>理想的情况下，如果订单金额在1到10万之间均匀分布，那订单会被均匀划分到100个文件中，每个小文件中存储大约100MB的订单数据，就可以将这100个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。</p>
<p>这里有一个问题，桶的实现方式是文件。还有就是需要注意的是，时间复杂度为<code>O(n)</code>，并不意味着只遍历一次，也可能是两次三次，这里遍历次数很小，系数可以忽略。<code>O(n)</code>指的是程序执行时间随数据规模呈线性关系。</p>
<p>不过，订单按照金额在1元到10万元之间并不一定是均匀分布的，所以10GB订单数据是无法均匀地被划分到100个文件中的。有可能某个金额区间的数据特别多，划分之后对应的文件会很大，没法一次性读入内存。</p>
<p>针对这些划分之后还是比较大的文件，可以继续划分，比如，订单金额在1元到1000元之间的比较多，就将这个区间继续划分为10个小区间，1元到100元，101元到200元...901元到1000元。如果划分之后，101元到200元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。</p>
<h2 id="计数排序">计数排序</h2>
<p><strong>计数排序其实是桶排序的一种特殊情况。</strong>当要排序的<code>n</code>个数据，所处的范围并不大的时候，比如最大值是<code>k</code>，就可以把数据划分成<code>k</code>个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间。计数排序的算法思想跟桶排序非常类似，只是桶的大小粒度不一样。桶排序的粒度是多个，而计数排序的粒度是一个。</p>
<h3 id="适用场景-1">适用场景</h3>
<p>如果所在的省有50万考生，如果通过成绩快速排序得出名次呢？</p>
<p>考生的满分是900分，最小是0分，这个数据的范围很小，所以可以分成901个桶，对应分数从0分到900分。根据考生的成绩，将这50万考生划分到这901个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了50万考生的排序。因为只涉及扫描遍历操作，时间复杂度为<code>O(n)</code>。</p>
<p>和桶排序不同的是，计数排序中桶存的不是元素而是元素的数量。</p>
<h3 id="总结">总结</h3>
<p>计数排序只能用在数据范围不大的场景中，如果数据范围<code>k</code>比要排序的数据<code>n</code>大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
<p>比如，还是拿考生这个例子。如果考生成绩精确到小数后一位，就需要将所有的分数都先乘以10，转化成整数，然后再放到9010个桶内。再比如，如果要排序的数据中有负数，数据的范围是<code>[-1000, 1000]</code>，那我们就需要先对每个数据都加1000，转化成非负整数。</p>
<h2 id="基数排序">基数排序</h2>
<h3 id="适用场景-2">适用场景</h3>
<p>假设有10w个手机号码，希望将这10万个手机号码从小到大排序，有什么比较快速的排序方法？</p>
<p>先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过11次排序之后，手机号码就都有序了。这里按照每位来排序的排序算法必须是稳定的，否则最后一次排序只会考虑最高位的大小顺序，完全不管其他位的大小关系，低位的排序就完全没有意义了。</p>
<p>根据每一位来排序，可以用桶排序或者计数排序，时间复杂度可以做到<code>O(n)</code>。如果要排序的数据有<code>k</code>位，那么就需要<code>k</code>次桶排序或者计数排序，总的时间复杂度是<code>O(k*n)</code>。当<code>k</code>不大的时候，比如手机号码排序的例子，<code>k</code>最大就是11，所以基数排序的时间复杂度近似于<code>O(n)</code>。</p>
<p>当排序的数据不是等长的的时候，可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”，因为根据<code>ASCII</code>值，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续使用基数排序了。</p>
<h3 id="总结-1">总结</h3>
<p>基数排序对要排序的数据是有要求的。需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果<code>a</code>数据的高位比<code>b</code>数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到<code>O(n)</code>了。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>如何根据年龄给100w用户排序？</p>
<p>实际上，根据年龄给100w用户排序，就类似按照成绩给50w考生排序。我们假设年龄的范围最小1岁，最大不超过120岁（或者可以通过遍历看一下年龄范围）。遍历这100w用户，根据年龄将其划分到这120个桶里，然后依次顺序遍历这120个桶中的元素，这样就得到了按照年龄排序的100w用户数据。</p>
<p>那么，这种排序方式是桶排序还是计数排序呢？</p>
<h2 id="课后思考">课后思考</h2>
<p>假设现在需要对<code>D, a, F, B, c, A，z</code>这个字符串进行排序，要求将其中所有小写的字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为<code>a, c, z, D, F, B, A</code>，这个该如何实现呢？如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母的放到后面，数字放在中间，不用排序算法，该怎么解决？</p>
<p>答案一：用两个指针<code>a</code>，<code>b</code>：<code>a</code>指针从头开始往后遍历，遇到大写字母就停下，<code>b</code>从后往前遍历，遇到小写字母就停下，交换<code>a</code>、<code>b</code>指针对应的元素；重复如上过程，直到<code>a</code>、<code>b</code>指针相交。对于小写字母放前面，数字放中间，大写字母放后面，可以先将数据分为小写字母和非小写字母两大类，进行如上交换再在非小写字母区间内分为数字和大写字母做同样处理。</p>
<p>答案二：利用桶排序思想，共小写、大写、数字三个桶，遍历一遍，都放进去，然后再从桶中取出来。时间复杂度为<code>O(n)</code>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>线性排序</tag>
      </tags>
  </entry>
  <entry>
    <title>跳表</title>
    <url>/2021/10/24/%E8%B7%B3%E8%A1%A8/</url>
    <content><![CDATA[<p>今天来学习跳表。</p>
<span id="more"></span>
<p>二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现。如果数据存储在链表中，对链表稍加改造，也可以支持类似“二分”的查找算法，这种改造之后的数据结构叫做跳表。这里我感觉，每一种数据结构的出现都有它出现的历史背景，但这也同时也决定了它的应用场景。</p>
<h2 id="如何理解跳表">如何理解“跳表”</h2>
<p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果要想在其中查找某个数据，也只能从头到尾遍历链表。时间复杂度为<span class="math inline">\(O(n)\)</span>。</p>
<p>那么如何提高效率？比如像图中那样，对链表建立一级“索引”。每两个结点提取一个结点到上一级，把提取出来结点的这一层叫做<strong>索引</strong>或<strong>索引层</strong>。图里的<code>down</code>表示<code>down</code>指针，指向下一级结点。</p>
<p><img src="skip_table_example.webp" /></p>
<p>这里的<code>down</code>不是特别明白，是类似单链表结点中<code>next</code>指针，也单独开辟一块空间，来存储<code>down</code>指针么？</p>
<p>如果现在要查找某个结点，比如16。可以现在索引层遍历，当遍历到索引层中为13的结点时，通过<code>node-&gt;next</code>发现下一个结点是17，那么要查找的结点16肯定就在这两个结点之间。然后通过索引层的<code>down</code>指针，下降到原始链表这一层，继续遍历。这时候，只需要在遍历2个结点，就可以找到值等于16的这个结点了。这样，原来如果要查找16，需要遍历10个结点<code>(1-&gt;3-&gt;4-&gt;5-&gt;7-&gt;8-&gt;9-&gt;10-&gt;13-&gt;16)</code>，现在只需要遍历7个结点<code>(1-&gt;4-&gt;7-&gt;9-&gt;13-&gt;13-&gt;16)</code>。</p>
<p><strong>加一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了。</strong>(利用空间换时间的思想。</p>
<p>当链表的长度<code>n</code>比较大时，在构建索引之后，查找效率的提升就会非常明显。</p>
<p>这种链表加多级索引的结构，就是跳表。</p>
<h2 id="时间复杂度">时间复杂度</h2>
<p>在一个具有多级索引的跳表中，查询某个数据的时间复杂度是多少？</p>
<p>如果链表里有<code>n</code>个结点，会有多少级索引？</p>
<p>第一层索引，<span class="math inline">\(\frac{n}{2}\)</span>个结点，第二层索引，<span class="math inline">\(\frac{n}{4}\)</span>个结点...以此类推，第<code>k</code>层索引，<span class="math inline">\(\frac{n}{2^k}\)</span>个结点，当<span class="math inline">\(\frac{n}{2^k}=2\)</span>时，即<span class="math inline">\(k=log_2n-1\)</span>时，不需要再建立索引。加上原始链表这一层，整个跳表的层数为<span class="math inline">\(log_2n\)</span>。</p>
<p>在跳表中查询某个数据的时候，如果每一层都要遍历<code>m</code>个结点，那么在跳表中查询一个数据的时间复杂度就是<span class="math inline">\(m*logn\)</span>。</p>
<p>这个<code>m</code>值是多少？按照前面这种索引结构，每一级索引都最多只需要遍历3个结点，也就是<code>m=3</code>。自己理解，前面这种索引结构是每两个结点提取一个结点到上一级，因此<code>m=3</code>。如果索引结构按照每三个结点提取一个结点到上一级，则<code>m=4</code>。也就是说，如果说索引结构按照每<code>n</code>个结点提取一个结点到上一级，则<code>m=n+1</code>。</p>
<p>所以在跳表中查询任意数据的时间复杂度就是<span class="math inline">\(logn\)</span>。</p>
<h2 id="空间复杂度">空间复杂度</h2>
<p>假设原始链表大小为<code>n</code>，那第一级索引为<span class="math inline">\(\frac{n}{2}\)</span>个结点，第二级索引为<span class="math inline">\(\frac{n}{4}\)</span>...以此类推，原始链表的大小为<code>n</code>，每2个结点抽1个，每层索引的结点数： <span class="math display">\[
\frac{n}{2},\frac{n}{4},\frac{n}{8}...8,4,2
\]</span> 很明显，这是一个公比为<span class="math inline">\(\frac{1}{2}\)</span>的等比数列，根据求和公式，可以知道，空间复杂度为<code>O(n)</code>。 <span class="math display">\[
S_n=\frac{a_1*(1-q^n)}{1-q}=\frac{a_nq-a_1}{q-1}=\frac{2*\frac{1}{2}-\frac{n}{2}}{\frac{1}{2}-1}=(n-2)
\]</span> 如果，原始链表的大小为<code>n</code>，每3个结点抽1个，每层的结点数： <span class="math display">\[
\frac{n}{3},\frac{n}{6},\frac{n}{9}...9,6,3
\]</span> 根据求和公式，公比为<span class="math inline">\(\frac{1}{3}\)</span> <span class="math display">\[
S_n=\frac{a_1*(1-q^n)}{1-q}=\frac{a_nq-a_1}{q-1}=\frac{3*\frac{1}{3}-\frac{n}{3}}{\frac{1}{3}-1}=\frac{1}{2}(n-3)
\]</span> 尽管空间复杂度依然为<span class="math inline">\(O(n)\)</span>，但是相比之下，还是减少了一半的索引结点存储空间。</p>
<p>实际上，在软件开发中，不必太在意索引占用的额外空间。在讲数据结构与算法时，习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引节点大很多时，那索引占用的额外空间就可以忽略了。</p>
<h2 id="高效的动态插入和删除">高效的动态插入和删除</h2>
<p>跳表不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是<span class="math inline">\(O(logn)\)</span>。这个很好理解，查找时间复杂度为<span class="math inline">\(O(logn)\)</span>，单纯插入和删除的时间复杂度为<span class="math inline">\(O(1)\)</span>。根据时间复杂度求和公式，<strong>总复杂度等于量级最大的那段代码的复杂度</strong>，所以插入、删除操作的时间复杂度为<span class="math inline">\(O(logn)\)</span>。</p>
<p>需要注意的是，在删除操作中，如果这个结点在索引中也有出现，除了要删除原始链表中的结点，还要删除索引中的结点。</p>
<h2 id="跳表索引动态更新">跳表索引动态更新</h2>
<p>当不停地往跳表中插入数据时，如果不更新索引，就有可能出现某2个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p>
<p><img src="skip_table_index.webp" /></p>
<p>作为一种动态数据结构，需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p>
<p>红黑树、<code>AVL</code>数这样的平衡二叉树，是通过左右旋的方式保持左右子树的大小平衡，而跳表是通过随机函数来维护前面提到的“平衡性”。</p>
<p>通过一个随机函数，来决定将这个节点插入到哪几级索引中，比如随机函数生成<code>K</code>，那么就将这个结点添加到第一级到第<code>K</code>级这<code>K</code>级索引中。随机函数的选择很有讲究。从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>为什么<code>Redis</code>要用跳表来实现有序集合，而不是红黑树？</p>
<p><code>Redis</code>中的有序集合是通过跳表来实现的，严格点讲，还用到了散列表。<code>Redis</code>中的有序集合支持的核心操作主要包括：</p>
<ol type="1">
<li>插入一个数据</li>
<li>删除一个数据</li>
<li>查找一个数据</li>
<li>按照区间查找数据（比如查找值在<code>[100, 356]</code>之间的数据）</li>
<li>迭代输出有序序列</li>
</ol>
<p>其实，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成。时间复杂度和跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。对于按照区间查找数据这个操作，跳表可以做到<span class="math inline">\(O(logn)\)</span>的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。</p>
<p>其次，相比红黑树，跳表更容易代码实现。</p>
<p>还有，跳表更加灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</p>
<p>不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的<code>Map</code>类型都是通过红黑树来实现。但是跳表并没有现成的实现。</p>
<h2 id="课后思考">课后思考</h2>
<p>如果每三个或者五个结点提取一个结点作为上级索引，对应的在跳表中的查询数据的时间复杂度是多少？</p>
<p>如果是每三个结点提取一个结点作为上级索引，<span class="math inline">\(\frac{n}{3^k}=3\)</span>，此时<span class="math inline">\(k=log_3n-1\)</span>，算上原始链表，层数为<span class="math inline">\(log_3n\)</span>，每一层需要遍历4个结点，所以时间复杂度为<span class="math inline">\(O(n)=4*log_3n\)</span>，忽略系数，<span class="math inline">\(O(n)=logn\)</span>。同理每五个结点。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>跳表</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2021/09/27/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>今天来学习递归。</p>
<span id="more"></span>
<h2 id="如何理解递归">如何理解“递归”</h2>
<p>数据结构和算法中两个最难理解的知识点，一个是动态规划，另一个是递归。</p>
<p>递归是一种应用非常广泛的算法(或者编程技巧)。比如，合并两个有序链表、斐波那契数列等等。</p>
<p>去的过程称为“递”，回来的过程称为“归”。</p>
<h2 id="递归需要满足的三个条件">递归需要满足的三个条件</h2>
<ol type="1">
<li>一个问题的解可以分解为几个子问题的解。子问题就是数据规模更小的问题。</li>
<li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。</li>
<li>存在递归终止条件</li>
</ol>
<h2 id="如何编写递归代码">如何编写递归代码</h2>
<p>写递归代码最关键的是<strong>写出递归公式，找到终止条件</strong>。</p>
<p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递归公式，然后再敲定终止条件，最后将递推公式和终止条件翻译为代码。</p>
<p>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</p>
<h2 id="递归代码要警惕堆栈溢出">递归代码要警惕堆栈溢出</h2>
<p>原因：函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>
<p>解决方法：在代码中限制递归调用的最大深度。但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如10、50，就可以用这种方法，否则这种方法并不很实用。</p>
<p>将递归代码改为循环处理以避免堆栈溢出。</p>
<h2 id="递归代码要警惕重复计算">递归代码要警惕重复计算</h2>
<p>为了避免重复计算，可以通过一个数据结构(散列表)来保存已经求解过得<code>f(k)</code>。当递归调用到<code>f(k)</code>时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。</p>
<h2 id="将递归代码改写为非递归代码">将递归代码改写为非递归代码</h2>
<p>递归代码有利有弊，利是递归代码的表达能力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。</p>
<p><code>f(x)=f(x-1)+1</code>改写为非递归代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">n</span>):</span></span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        result = result + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>笼统的讲，所有的递归代码都可以改为迭代循环的非递归写法。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>给定一个用户ID，如何查找这个用户的“最终推荐人”。伪代码如下，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">findRootReferrerId</span><span class="params">(<span class="keyword">long</span> actorId)</span> </span>&#123;</span><br><span class="line">  Long referrerId = select referrer_id from [table] where actor_id = actorId;</span><br><span class="line">  <span class="keyword">if</span> (referrerId == <span class="keyword">null</span>) <span class="keyword">return</span> actorId;</span><br><span class="line">  <span class="keyword">return</span> findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在的问题：</p>
<ol type="1">
<li>递归很深，存在堆栈溢出的风险(限制递归次数)</li>
<li>如果数据库里存在脏数据，还需要处理由此产生的无限递归问题，如何检测环？(限制递归次数、快慢指针检测环)</li>
</ol>
<h2 id="课后思考">课后思考</h2>
<p>对于递归代码，有什么好的调试方法？(答案来自评论区)</p>
<ul>
<li>打印日志发现，递归值</li>
<li>结合条件断点进行调试</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>链表(上)</title>
    <url>/2021/09/16/%E9%93%BE%E8%A1%A8-%E4%B8%8A/</url>
    <content><![CDATA[<p>今天来学习链表(上)。</p>
<span id="more"></span>
<h2 id="引言">引言</h2>
<p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。</p>
<p>缓存大小有限，当缓存被用满时，就涉及到了缓存淘汰策略。</p>
<ol type="1">
<li>先进先出策略<code>FIFO</code>(First In, First Out)</li>
<li>最少使用策略<code>LFU</code>(Least Frequently Used)</li>
<li>最近最少使用策略<code>LRU</code>(Least Recently Used)</li>
</ol>
<p>经典的链表应用场景，<code>LRU</code>缓存淘汰算法。</p>
<h2 id="五花八门的链表结构">五花八门的链表结构</h2>
<h3 id="单链表">单链表</h3>
<p>首先需要搞清几个概念</p>
<ul>
<li>链表结点：存储数据和后继指针的内存块</li>
<li>后继指针：记录下个结点地址的指针</li>
<li>头结点：第一个结点</li>
<li>尾结点：最后一个结点，<strong>指向一个空地址NULL</strong></li>
</ul>
<p>插入删除操作时间复杂度O(1)，随机访问时间复杂度O(n)</p>
<h3 id="循环链表">循环链表</h3>
<p><strong>循环链表是一种特殊的单链表</strong>，它跟单链表唯一的区别就在尾结点。单链表的尾结点指针指向空地址。而循环链表的尾结点指针是指向链表的头结点。</p>
<p>和单链表相比，<strong>循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环形结构特点时，就特别适合采用循环链表，比如著名的约瑟夫问题。</strong>尽管用单链表也可以实现，但使用循环链表实现的话，代码会简洁很多。</p>
<h3 id="双向链表">双向链表</h3>
<p>在实际的软件开发，双向链表更加常用。</p>
<p>单链表只有一个方向，结点只有一个后继指针，<code>next</code>指向后面的结点。而双向链表，它支持两个方向，每个结点不止有一个后继指针<code>next</code>指向后面的结点，还有一个前驱指针<code>prev</code>指向前面的结点。</p>
<p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样带来了双向链表操作的灵活性。</p>
<h4 id="单链表-vs-双向链表">单链表 vs 双向链表</h4>
<p>在实际的软件开发中，从链表删除一个数据无外乎这两种情况：</p>
<ul>
<li>删除结点中“值等于某个给定值”的结点</li>
<li>删除给定指针指向的结点</li>
</ul>
<p>对于第一种情况，无论是单链表和双向链表，都需要遍历查找。所以删除操作的时间复杂度是O(1)，遍历查找的时间复杂度是O(n)，根据加法法则，总的时间复杂度O(n)。</p>
<p>对于第二种情况，由于删除某个结点<code>q</code>需要知道其前驱结点，而单链表并不支持直接获取前驱结点，时间复杂度O(n)；而双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历，时间复杂度O(1)</p>
<p>同理在链表的某个结点前面或者后面插入一个结点，双向链表时间复杂度O(1)；单链表时间复杂度O(n)</p>
<p>除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为双向链表可以记录上次查找的位置<code>p</code>，每次查询时，根据要查询值和位置p的值的大小关系，决定往前查找还是往后查找，所以平均只需要查找一半的数据。</p>
<p><code>Java</code>语言中的<code>LinkedHashMap</code>就用到了双向链表，尽管比较费内存，但是应用比较广泛。</p>
<p>这里面，涉及到一个重要的涉及思想：<strong>空间换时间</strong>。对于执行比较慢的程序，可以通过消耗更多的内存(空间换时间)，来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间(时间换空间)来降低内存的消耗。</p>
<h3 id="双向循环链表">双向循环链表</h3>
<p>概念容易理解，但是代码写起来更复杂了....</p>
<h3 id="数组-vs-链表">数组 vs 链表</h3>
<p>底层结构上：数组连续的内存空间；链表零散的内存块</p>
<p>时间复杂度：</p>
<table>
<thead>
<tr class="header">
<th>时间复杂度</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>插入、删除</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr class="even">
<td>随机访问</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<p>在实际开发中，不能简单的根据时间复杂度来决定使用哪个数据结构来存储数据。</p>
<p>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。</p>
<p>数组的缺点是大小固定，一经声明就要占用整块连续内存。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足”。如果声明的数组过小，则可能出现不够用的情况。这是只能再申请一个更大的内存空间，把原数组拷贝过去，非常耗时。链表本身没有大小的限制，天然地支持动态扩容。这是数组和链表最大的区别</p>
<p>除此之外，如果对内存的使用非常苛刻，那么数组更适合。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>如何基于链表实现LRU缓存淘汰算法？</p>
<p>思路：维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历单链表。</p>
<ol type="1">
<li>如果此数据之前已经被缓存在链表中，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li>
<li>如果此数据没有在缓存链表中，又可以分为两种情况：
<ul>
<li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li>
<li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li>
</ul></li>
</ol>
<p>时间复杂度O(n)</p>
<p>思考：如何利用数组来实现LRU缓存淘汰策略？</p>
<h2 id="思考">思考</h2>
<p>如何判断一个字符串是否是回文字符串的问题？</p>
<p>这个问题考查了两个知识点：</p>
<ol type="1">
<li>快慢指针</li>
<li>反转相邻结点</li>
</ol>
<p>花了一个下午写了关于链表的一些基本操作—。—，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  	单链表-结点</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data, next_node=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = next_node</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  	单链表</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__head = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_by_value</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            根据value在链表中查找</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.__head</span><br><span class="line">        <span class="keyword">while</span> (node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (node.data != value):</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_by_index</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            根据index在链表中查找</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.__head</span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (pos != index):</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_to_head</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            头结点插入</span></span><br><span class="line"><span class="string">            时间复杂度O(1)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.<span class="built_in">next</span> = self.__head</span><br><span class="line">        self.__head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_after</span>(<span class="params">self, node, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            在链表的某个指定Node节点之后插入一个存储value数据的Node节点</span></span><br><span class="line"><span class="string">            时间复杂度O(1)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 如果在空结点之后插入数据结点 则什么都不做</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        new_node = Node(value)</span><br><span class="line"></span><br><span class="line">        new_node.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span> = new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_before</span>(<span class="params">self, node, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            在链表的某个指定Node节点之前插入一个存储value数据的Node节点</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 如果在空结点之前或者空链表之前插入结点 则什么都不做</span></span><br><span class="line">        <span class="keyword">if</span> (node <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (self.__head <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 头结点插入</span></span><br><span class="line">        <span class="keyword">if</span> node == self.__head:</span><br><span class="line">            self.insert_to_head(value)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        new_node = Node(value)</span><br><span class="line">        pos = self.__head</span><br><span class="line">        <span class="comment"># 注意：判断node是否存在链表中</span></span><br><span class="line">        not_found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> pos.<span class="built_in">next</span> != node:</span><br><span class="line">            <span class="keyword">if</span> pos.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                not_found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            pos = pos.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> not_found:</span><br><span class="line">            pos.<span class="built_in">next</span> = new_node</span><br><span class="line">            new_node.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_by_node</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            在链表中删除指定Node的节点</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 空链表 什么都不做</span></span><br><span class="line">        <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 删除头结点 头结点后移</span></span><br><span class="line">        <span class="keyword">if</span> node == self.__head:</span><br><span class="line">            self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        pos = self.__head</span><br><span class="line">        not_found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> pos.<span class="built_in">next</span> != node:</span><br><span class="line">            <span class="keyword">if</span> pos.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                not_found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            pos = pos.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> not_found:</span><br><span class="line">            pos.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_by_value</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            在链表中删除指定存储数据的Node节点</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.__head.data == value:</span><br><span class="line">            self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里用到了pre结点 因为删除指定value结点时候需要用到前一个结点</span></span><br><span class="line">        pre = self.__head</span><br><span class="line">        node = self.__head.<span class="built_in">next</span></span><br><span class="line">        not_found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> node.data != value:</span><br><span class="line">            <span class="keyword">if</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                not_found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            pre = node</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> not_found:</span><br><span class="line">            pre.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_last_n_node</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            删除链表中倒数第N个节点</span></span><br><span class="line"><span class="string">            主要思路：</span></span><br><span class="line"><span class="string">                设置快、慢两个指针，快指针先行，慢指针不动；当快指针走了N步时，快慢指针同时向链表尾部移动，</span></span><br><span class="line"><span class="string">                当快指针到达链表尾部时，慢指针指向的就是链表倒数第N个结点(脑子绕不过弯来时，画画图就明白了)</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            ** 单链表删除结点的时候，一定要注意保存被删除结点的前驱结点</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast = self.__head</span><br><span class="line">        slow = self.__head</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> step &lt;= n:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        tmp = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            tmp = slow</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        tmp.<span class="built_in">next</span> = slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_mid_node</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            查找链表中的中间节点</span></span><br><span class="line"><span class="string">            主要思想：</span></span><br><span class="line"><span class="string">                设置快慢指针，快指针每次跨两步，满指针每次跨一步，则当快指针到达链表尾部的时候，慢指针指向链表的中间结点</span></span><br><span class="line"><span class="string">                同理 脑子绕不过弯时，画画图就明白了</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast = self.__head</span><br><span class="line">        slow = self.__head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单链表个数局限为奇数</span></span><br><span class="line">        <span class="comment"># while (fast.next is not None):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单链表个数为奇数或者偶数可以</span></span><br><span class="line">        <span class="keyword">while</span> (fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_node</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            创建一个存储value值的Node节点</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> Node(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_all</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            打印当前链表所有节点数据</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        node = self.__head</span><br><span class="line">        <span class="keyword">while</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(node.data, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 打印最后一个结点</span></span><br><span class="line">        <span class="built_in">print</span>(node.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversed_self</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            翻转链表</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pre = self.__head</span><br><span class="line">        node = self.__head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 结束条件 pre为链表最后一个结点 node为None</span></span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            pre, node = self.__reversed_with_two_node(pre, node)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 修改尾结点和头结点</span></span><br><span class="line">        self.__head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.__head = pre</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed_with_two_node</span>(<span class="params">self, pre, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            翻转相邻两个结点</span></span><br><span class="line"><span class="string">            思路：利用一个中间结点tmp</span></span><br><span class="line"><span class="string">        :return: node, node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 保存node的下一个结点</span></span><br><span class="line">        tmp = node.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 修改node指针</span></span><br><span class="line">        node.<span class="built_in">next</span> = pre</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这两行的意思应该是后移结点</span></span><br><span class="line">        pre = node</span><br><span class="line">        node = tmp</span><br><span class="line">        <span class="keyword">return</span> pre, node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_ring</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            检测是否有环</span></span><br><span class="line"><span class="string">            主要思想：</span></span><br><span class="line"><span class="string">                设置快、慢两个指针，快指针每次跨两步、慢指针每次跨一步，</span></span><br><span class="line"><span class="string">                如果快指针没有与慢指针相遇而是顺利到达链表尾部，说明没有环，反之存在环</span></span><br><span class="line"><span class="string">                自己画画图看看 就明白了</span></span><br><span class="line"><span class="string">            时间复杂度O(n)</span></span><br><span class="line"><span class="string">        :return: True or False</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast = self.__head</span><br><span class="line">        slow = self.__head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当链表为空或者只有一个结点时，直接返回False</span></span><br><span class="line">        <span class="keyword">while</span> (fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_head</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            根据给的结点，翻转之后的结点</span></span><br><span class="line"><span class="string">        :return: node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        reverse_head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            next_node = head.<span class="built_in">next</span></span><br><span class="line">            head.<span class="built_in">next</span> = reverse_head</span><br><span class="line">            reverse_head = head</span><br><span class="line">            head = next_node</span><br><span class="line">        <span class="keyword">return</span> reverse_head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            判断是否是回文串</span></span><br><span class="line"><span class="string">            主要思路：快、慢两个指针，快指针每次前进两步、慢指针每次前进一步。当快指针到达链表尾部时，慢指针到达链表中间节点，翻转慢指针到链表尾部的这部分结										点，然后依次对比链表头部和翻转后的部分链表数据是否相同</span></span><br><span class="line"><span class="string">        :return: True or False</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow = self.__head</span><br><span class="line">        fast = self.__head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        head_a = self.__head</span><br><span class="line">        head_b = self.reverse_head(slow)</span><br><span class="line"></span><br><span class="line">        is_palin = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> head_a <span class="keyword">and</span> head_b:</span><br><span class="line">            <span class="keyword">if</span> head_a.data == head_b.data:</span><br><span class="line">                head_a = head_a.<span class="built_in">next</span></span><br><span class="line">                head_b = head_b.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                is_palin = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> is_palin</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>写链表代码时有几点感受：</p>
<ol type="1">
<li>在删除链表结点的时候一定要注意利用中间变量保存前驱结点</li>
<li>快慢指针法在链表中有着广泛的应用，比如说查找中间结点、检测链表是否包含环、判断是否为回文串、删除链表倒数第N个结点等等。</li>
<li>多写多练</li>
</ol>
<p>参考链接：</p>
<ol type="1">
<li><a href="https://github.com/wangzheng0822/algo">数据结构与算法之美相关代码</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表(下)</title>
    <url>/2021/09/17/%E9%93%BE%E8%A1%A8-%E4%B8%8B/</url>
    <content><![CDATA[<p>链表这块知识理解起来简单，代码实现起来，容易出错，谁写谁知道，所以就有了链表(下)。</p>
<span id="more"></span>
<h2 id="写链表代码的技巧">写链表代码的技巧</h2>
<h3 id="理解指针或引用的含义">理解指针或引用的含义</h3>
<p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针里存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p>
<p>指针，英文定义，<code>A pointer is a variable whose value is the address of another variable.</code></p>
<h3 id="警惕指针丢失和内存泄漏">警惕指针丢失和内存泄漏</h3>
<p>比如，在<code>a</code>、<code>b</code>两个结点之间插入一个结点<code>c</code>，一定是先执行<code>c-&gt;next=a-&gt;next</code>，先把结点<code>c</code>指向结点<code>b</code>，然后再将结点<code>a</code>指向结点<code>c</code>，即<code>a-&gt;next=c</code>。如果顺序颠倒了，就会造成结点<code>b</code>的丢失，链表分成了两半，进而造成内存泄漏。因此，<strong>在插入结点时，一定要注意操作的顺序</strong>。</p>
<p><strong>删除链表结点时，也一定要记得手动释放内存空间</strong>，否则也会出现内存泄漏的情况。当然，对于像<code>Java</code>这种虚拟机自动管理内存的编程语言来说，就不需要考虑那么多了。</p>
<h3 id="利用哨兵简化实现难度">利用哨兵简化实现难度</h3>
<p>非哨兵模式下链表的插入，比如在<code>p</code>结点后插入一个新结点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常情况</span></span><br><span class="line">new_node.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">p.<span class="built_in">next</span> = new_node</span><br><span class="line"><span class="comment"># 边界情况，比如向空链表中插入第一个结点</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">None</span>)&#123;head = new_node&#125;</span><br></pre></td></tr></table></figure>
<p>非哨兵模式下链表的删除，比如删除结点<code>p</code>的后继结点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常情况</span></span><br><span class="line">p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"><span class="comment"># 边界情况，比如删除最后一个结点</span></span><br><span class="line">p.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p><strong>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。</strong></p>
<p>为了解决边界问题，引入哨兵结点。</p>
<p>哨兵结点，结点本身不存储数据，指定链表头结点，称为新的头结点，如图所示，</p>
<p><img src="sentinel.webp" /></p>
<p>带有哨兵结点的链表叫<strong>带头链表</strong>；没有哨兵结点的链表叫做<strong>不带头链表</strong>。</p>
<p>因为哨兵结点一直存在，所以插入第一个节点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑。</p>
<p>不信的话，自己画画图，理解一下代码，发现确实是真的耶</p>
<h3 id="重点留意边界条件处理">重点留意边界条件处理</h3>
<p>检查链表代码是否正确的边界条件有这样几个：</p>
<ul>
<li>如果链表为空时，代码是否能正常工作</li>
<li>如果链表只包含一个结点时，代码是否能正常工作</li>
<li>如果链表只包含两个结点时，代码是否能正常工作</li>
<li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作</li>
</ul>
<h3 id="举例画图辅助思考">举例画图，辅助思考</h3>
<p>举例法和画图法</p>
<h3 id="多写多练没有捷径">多写多练，没有捷径</h3>
<p>5个常见的链表操作</p>
<ul>
<li>单链表反转</li>
<li>链表中环的检测</li>
<li>两个有序的链表合并</li>
<li>删除链表倒数第n个结点</li>
<li>求链表的中间结点</li>
</ul>
<p>其实除了两个有序的链表合并，其余的在链表上(上)都写过了，总结起来就是1.快慢指针2.反转相邻的结点。上节课后思考判断回文串这一道题目就把这两个知识点都考查到了，简直是妙啊！</p>
<h2 id="课后思考">课后思考</h2>
<p>哨兵模式在其他场景上的应用。</p>
<p>暂时没想到，后续用到了再来补充吧=.=</p>
<h2 id="合并两个有序链表">合并两个有序链表</h2>
<h3 id="遍历实现">遍历实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sorted_list</span>(<span class="params">l1: Node, l2: Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        合并两个有序链表</span></span><br><span class="line"><span class="string">        时间复杂度O(m)+O(n)</span></span><br><span class="line"><span class="string">    :param l1: 链表1头结点</span></span><br><span class="line"><span class="string">    :param l2: 链表2头结点</span></span><br><span class="line"><span class="string">    :return: 合并后链表的头结点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    node = Node(data=-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 需要一个变量保存头结点</span></span><br><span class="line">    head = node</span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.data &lt;= l2.data:</span><br><span class="line">            node.<span class="built_in">next</span> = l1</span><br><span class="line">            <span class="comment"># 后移链表1结点</span></span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = l2</span><br><span class="line">            <span class="comment"># 后移链表2结点</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        node = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并 未合并完的链表</span></span><br><span class="line">    node.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">    <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = SingleLinkedList()</span><br><span class="line"></span><br><span class="line">    s.insert_to_head(<span class="number">5</span>)</span><br><span class="line">    s.insert_to_head(<span class="number">3</span>)</span><br><span class="line">    s.insert_to_head(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    p = SingleLinkedList()</span><br><span class="line">    p.insert_to_head(<span class="number">6</span>)</span><br><span class="line">    p.insert_to_head(<span class="number">5</span>)</span><br><span class="line">    p.insert_to_head(<span class="number">4</span>)</span><br><span class="line">    p.insert_to_head(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    q = merge_sorted_list(s.get_head_node(), p.get_head_node())</span><br></pre></td></tr></table></figure>
<h3 id="递归实现">递归实现</h3>
<p>代码先放到这，等学完递归在回过头来看。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sorted_list2</span>(<span class="params">l1: Node, l2: Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        合并两个有序链表</span></span><br><span class="line"><span class="string">        主要思路：</span></span><br><span class="line"><span class="string">        	list1[0] + merge(list1[1], list2[0]) 当list1[0]&lt;list2[0]</span></span><br><span class="line"><span class="string">          list2[0] + merge(list1[0], list2[1]) otherwise</span></span><br><span class="line"><span class="string">    :param l1: 链表1头结点</span></span><br><span class="line"><span class="string">    :param l2: 链表2头结点</span></span><br><span class="line"><span class="string">    :return: 合并后链表的头结点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l2:</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1.data &lt;= l2.data:</span><br><span class="line">        l1.<span class="built_in">next</span> = merge_sorted_list(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l2.<span class="built_in">next</span> = merge_sorted_list(l1, l2.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>
<h2 id="lru缓存算法">LRU缓存算法</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.key = x</span><br><span class="line">        self.value = y</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cap = capacity</span><br><span class="line">        <span class="comment"># 存储key和node</span></span><br><span class="line">        self.hkeys = &#123;&#125;</span><br><span class="line">        <span class="comment"># 哨兵结点 避免考虑边界问题</span></span><br><span class="line">        self.top = Node(<span class="literal">None</span>, -<span class="number">1</span>)</span><br><span class="line">        self.tail = Node(<span class="literal">None</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.top.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.top</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hkeys.keys():</span><br><span class="line">            <span class="comment"># 1.获取结点</span></span><br><span class="line">            cur = self.hkeys[key]</span><br><span class="line">            <span class="comment"># 2.从当前位置拿出</span></span><br><span class="line">            cur.prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span>.prev = cur.prev</span><br><span class="line">            <span class="comment"># 3.放到链表头部</span></span><br><span class="line">            <span class="comment"># 3.1 保存top后面的结点</span></span><br><span class="line">            tmp = self.top.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 3.2 top和cur绑定</span></span><br><span class="line">            self.top.<span class="built_in">next</span> = cur</span><br><span class="line">            cur.prev = self.top</span><br><span class="line">            <span class="comment"># 3.3 cur和tmp绑定</span></span><br><span class="line">            cur.<span class="built_in">next</span> = tmp</span><br><span class="line">            tmp.prev = cur</span><br><span class="line">            <span class="keyword">return</span> self.hkeys[key].value</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hkeys.keys():</span><br><span class="line">            <span class="comment"># 1.获取结点</span></span><br><span class="line">            cur = self.hkeys[key]</span><br><span class="line">            <span class="comment"># 修改value值</span></span><br><span class="line">            cur.value = value</span><br><span class="line">            <span class="comment"># 2.跳出原位置</span></span><br><span class="line">            cur.prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span>.prev = cur.prev</span><br><span class="line">            <span class="comment"># 3.将cur放到头结点</span></span><br><span class="line">            top_node = self.top.<span class="built_in">next</span></span><br><span class="line">            self.top.<span class="built_in">next</span> = cur</span><br><span class="line">            cur.prev = self.top</span><br><span class="line">            cur.<span class="built_in">next</span> = top_node</span><br><span class="line">            top_node.prev = cur</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.hkeys.keys()) &gt; self.cap:</span><br><span class="line">                <span class="comment"># 从哈希表删除key</span></span><br><span class="line">                self.hkeys.pop(self.tail.prev.key)</span><br><span class="line">                <span class="comment"># 去掉了后继指针</span></span><br><span class="line">                self.tail.prev.prev.<span class="built_in">next</span> = self.tail</span><br><span class="line">                <span class="comment"># 修改尾结点前驱指针，self.tail.prev.prev有点懵的</span></span><br><span class="line">                self.tail.prev = self.tail.prev.prev</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 新增结点</span></span><br><span class="line">            cur = Node(key, value)</span><br><span class="line">            self.hkeys[key] = cur</span><br><span class="line">            <span class="comment"># 最近用过的放到链表头部</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                我第一次写的</span></span><br><span class="line"><span class="string">                cur.next = self.top.next</span></span><br><span class="line"><span class="string">                self.top.prev = cur</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">                self.top.next = cur</span></span><br><span class="line"><span class="string">                cur.prev = self.top</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># 利用tmp保留top下一个结点</span></span><br><span class="line">            tmp = self.top.<span class="built_in">next</span>  </span><br><span class="line">            cur.<span class="built_in">next</span> = tmp</span><br><span class="line">            tmp.prev = cur</span><br><span class="line"></span><br><span class="line">            self.top.<span class="built_in">next</span> = cur</span><br><span class="line">            cur.prev = self.top</span><br></pre></td></tr></table></figure>
<h3 id="感受">感受</h3>
<ol type="1">
<li><p>写起来好像也没想象中那么难，可能是因为用到哨兵结点，不需要考虑边界问题。</p></li>
<li><p>主要操作包括：结点从当前位置取出、头部插入结点。</p></li>
<li><p>操作之间不需要考虑先后顺序，比如结点跳出原位置，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 结点跳出原位置</span></span><br><span class="line">cur.<span class="built_in">next</span>.prev = cur.prev</span><br><span class="line">cur.prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链表头部插入结点</span></span><br><span class="line">tmp = self.top.<span class="built_in">next</span></span><br><span class="line">cur.<span class="built_in">next</span> = tmp</span><br><span class="line">tmp.prev = cur</span><br><span class="line"></span><br><span class="line">self.top.<span class="built_in">next</span> = cur</span><br><span class="line">cur.prev = self.top</span><br></pre></td></tr></table></figure>
<p>于是，为了验证这个观点，写一个简单的双向链表<code>demo</code>验证一下，无论怎么更换<code>insert_node_from_head()</code>方法中后四行代码的顺序，结果都是一样的。如果有不对的地方，欢迎指教哈=。=</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoWayLoop</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = Node(value=-<span class="number">1</span>)</span><br><span class="line">        self.tail = Node(value=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.top.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.top</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_node_from_head</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value=value)</span><br><span class="line"></span><br><span class="line">        tmp = self.top.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        tmp.prev = node</span><br><span class="line">        node.prev = self.top</span><br><span class="line">        self.top.<span class="built_in">next</span> = node</span><br><span class="line">        node.<span class="built_in">next</span> = tmp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_node</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            暂时没想好怎么写</span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.top.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_all</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node.<span class="built_in">next</span>:</span><br><span class="line">            <span class="built_in">print</span>(node.value)</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = TwoWayLoop()</span><br><span class="line"></span><br><span class="line">    t.insert_node_from_head(<span class="number">4</span>)</span><br><span class="line">    t.insert_node_from_head(<span class="number">3</span>)</span><br><span class="line">    t.insert_node_from_head(<span class="number">2</span>)</span><br><span class="line">    t.insert_node_from_head(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    t.print_all()  <span class="comment"># 1-&gt;2-&gt;3-&gt;4</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="附获取类对象的私有属性">附：获取类对象的私有属性</h2>
<p>在合并两个有序链表中，需要获取链表的头结点。上篇文章代码中，单链表的<code>SingleLinkedList</code>中的头结点初始化时定义为私有属性<code>self.__head=None</code>，如果直接通过实例对象获取<code>__head</code>会抛出<code>AttributeError</code>异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__head = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  s = SingleLinkedList()</span><br><span class="line">  s.insert_to_head(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(s.__head)  <span class="comment"># AttributeError: &#x27;SingleLinkedList&#x27; object has no attribute &#x27;__head&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="正确的打开方式">正确的打开方式</h3>
<ol type="1">
<li>通过定义一个方法获取私有属性</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__head = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_head_node</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.__head</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  s = SingleLinkedList()</span><br><span class="line">  s.insert_to_head(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(s.get_head_node().data)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>通过<code>property</code>将方法转化为属性</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__head = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_head_node</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.__head</span><br><span class="line"></span><br><span class="line">  head = <span class="built_in">property</span>(get_head_node)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  s = SingleLinkedList()</span><br><span class="line">  s.insert_to_head(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(s.head.data)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>通过<code>property</code>装饰器</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__head = <span class="literal">None</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span>(<span class="params">self</span>):</span></span><br><span class="line">  	<span class="keyword">return</span> self.__head</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  s = SingleLinkedList()</span><br><span class="line">  s.insert_to_head(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(s.head.data)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<p>参考链接：</p>
<ol type="1">
<li><a href="https://zhuanlan.zhihu.com/p/53469919">python变量——单下划线和双下划线</a></li>
<li><a href="https://www.runoob.com/python/python-func-property.html">Python property() 函数</a></li>
<li><a href="https://blog.csdn.net/z_feng12489/article/details/106105227">合并两个有序链表（python）</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2021/09/24/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>今天来学习队列。</p>
<span id="more"></span>
<h2 id="如何理解队列">如何理解“队列”</h2>
<p>先进者先出，就是典型的“队列”。基本操作包括：入队和出队。</p>
<p>队列跟栈一样，也是一种操作受限的线性表数据结构。</p>
<p>队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列<code>Disruptor</code>、<code>Linux</code>环形缓存，都用到了循环并发队列；<code>Java concurrent</code>并发包利用<code>ArrayBlockingQueue</code>来实现公平锁等。</p>
<h2 id="顺序队列和链式队列">顺序队列和链式队列</h2>
<p>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫做顺序栈，用链表实现的栈叫做链式栈。同样，用数组实现的队列叫做<strong>顺序队列</strong>，用链表实现的队列叫做<strong>链式队列</strong>。</p>
<h3 id="顺序队列实现">顺序队列实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.items = []</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.head = <span class="number">0</span></span><br><span class="line">        self.tail = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, item: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            入队</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.tail == self.capacity:</span><br><span class="line">            <span class="comment"># 说明队列已满</span></span><br><span class="line">            <span class="keyword">if</span> self.head == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># self.tail指向数据下一个index</span></span><br><span class="line">            <span class="comment"># self.head=2 self.tail=7 执行5次数据搬移操作</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.tail - self.head):</span><br><span class="line">                <span class="comment"># 数据搬移操作</span></span><br><span class="line">                self.items[i] = self.items[self.head + i]</span><br><span class="line">            <span class="comment"># 修改队首 队尾</span></span><br><span class="line">            self.tail = self.tail - self.head</span><br><span class="line">            self.head = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.items.insert(self.tail, item)</span><br><span class="line">        self.tail += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            出队</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 队列为空</span></span><br><span class="line">        <span class="keyword">if</span> self.tail == self.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        item = self.items[self.head]</span><br><span class="line">        self.head += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> self.items[self.head: self.tail])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    q = ArrayQueue(<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">8</span>):</span><br><span class="line">        q.enqueue(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(q)</span><br><span class="line">    <span class="comment"># self.head=0 self.tail=7</span></span><br><span class="line"></span><br><span class="line">    q.dequeue()</span><br><span class="line">    q.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(q)</span><br><span class="line">    <span class="comment"># self.head=2 self.tail=7</span></span><br><span class="line"></span><br><span class="line">    q.enqueue(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    q.enqueue(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(q)</span><br></pre></td></tr></table></figure>
<h3 id="链式队列实现">链式队列实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.tail:</span><br><span class="line">            self.tail.<span class="built_in">next</span> = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.head = node</span><br><span class="line">        self.tail = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.head:</span><br><span class="line">            item = self.head.data</span><br><span class="line">            <span class="comment"># 后移head</span></span><br><span class="line">            self.head = self.head.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 只有一个元素时</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">                self.tail = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        values = []</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            values.append(current.data)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;-&gt;&#x27;</span>.join([value <span class="keyword">for</span> value <span class="keyword">in</span> values])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lq = LinkedQueue()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        lq.enqueue(<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(lq)</span><br><span class="line"></span><br><span class="line">    lq.dequeue()</span><br><span class="line">    lq.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(lq)</span><br><span class="line"></span><br><span class="line">    lq.enqueue(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    lq.enqueue(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(lq)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="感受">感受</h3>
<p>多画图来分析</p>
<h2 id="循环队列">循环队列</h2>
<p><strong>确定好队空和队满的判定条件。</strong></p>
<p>用数组实现的非循环队列中，队满的判断条件是<code>tail == n</code>，队空的判断条件是<code>head == tail</code></p>
<p>用数组实现的循环队列中，队空的判断条件是<code>head == tail</code>，<strong>队满的判断条件是<code>(tail+1)%n=head</code></strong></p>
<h3 id="示例代码">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        self.items = []</span><br><span class="line">        <span class="comment"># 循环队列会浪费一个数组的存储空间</span></span><br><span class="line">        self.capacity = capacity + <span class="number">1</span></span><br><span class="line">        self.head = <span class="number">0</span></span><br><span class="line">        self.tail = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (self.tail + <span class="number">1</span>) % self.capacity == self.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line">        self.tail = (self.tail + <span class="number">1</span>) % self.capacity</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.tail == self.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        value = self.items[self.head]</span><br><span class="line">        self.head = (self.head+<span class="number">1</span>) % self.capacity</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.tail &gt;= self.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> self.items[self.head: self.tail])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> chain(self.items[self.head:], self.items[:self.tail]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = CircularQueue(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        q.enqueue(<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 0 1 2 3 4</span></span><br><span class="line">    q.dequeue()</span><br><span class="line">    q.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 2 3 4</span></span><br><span class="line">    q.enqueue(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 2 3 4 5</span></span><br><span class="line">    q.enqueue(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 2 3 4 5 5 0</span></span><br></pre></td></tr></table></figure>
<p>这是<code>https://github.com/wangzheng0822/algo/blob/master/python/09_queue/circular_queue.py</code>里面的代码，我在最后又加了一次入队<code>enqueue(str(5))</code>，发现结果不是自己预料的那样，输出<code>2 3 4 5 5</code>，而是输出了<code>2 3 4 5 5 0</code>。</p>
<p>经过画图以及调试分析，发现直接原因是<code>__repr__</code>里面当<code>self.tail &lt; self.head</code>时输出对象的问题。</p>
<p>根本原因是在初始化的时候，<code>self.items = []</code>以及<code>enqueue()</code>中<code>self.items.append(item)</code>。</p>
<h3 id="正确代码">正确代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        self.capacity = capacity + <span class="number">1</span></span><br><span class="line">				<span class="comment"># 初始化固定长度的列表</span></span><br><span class="line">        self.items = [<span class="literal">None</span>] * self.capacity</span><br><span class="line">        self.head = <span class="number">0</span></span><br><span class="line">        self.tail = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (self.tail + <span class="number">1</span>) % self.capacity == self.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        self.items[self.tail] = item</span><br><span class="line">        self.tail = (self.tail + <span class="number">1</span>) % self.capacity</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.tail == self.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        value = self.items[self.head]</span><br><span class="line">        self.head = (self.head + <span class="number">1</span>) % self.capacity</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.tail &gt;= self.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> self.items[self.head: self.tail])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> chain(self.items[self.head:], self.items[: self.tail]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = CircularQueue(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        q.enqueue(<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 0 1 2 3 4</span></span><br><span class="line">    q.dequeue()</span><br><span class="line">    q.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 2 3 4</span></span><br><span class="line">    q.enqueue(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 2 3 4 5</span></span><br><span class="line">    q.enqueue(<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 2 3 4 5 6</span></span><br><span class="line">    q.dequeue()  <span class="comment"># 3 4 5 6</span></span><br><span class="line">    q.enqueue(<span class="built_in">str</span>(<span class="number">7</span>))</span><br><span class="line">    <span class="built_in">print</span>(q)  <span class="comment"># 3 4 5 6 7</span></span><br></pre></td></tr></table></figure>
<h2 id="阻塞队列和并发队列">阻塞队列和并发队列</h2>
<h3 id="阻塞队列">阻塞队列</h3>
<p>阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>
<p>通过阻塞队列，可以实现一个“生产者-消费者模型”</p>
<h3 id="并发队列">并发队列</h3>
<p>线程安全的队列称为并发队列。最简单的实现方式是直接在<code>enqueue()</code>、<code>dequeue()</code>方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用<code>CAS</code>原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>
<h2 id="解答开篇">解答开篇</h2>
<p>线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的？</p>
<ol type="1">
<li>非阻塞的处理方式，直接拒绝任务请求。</li>
<li>阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。
<ul>
<li>基于链表的实现方式，可以实现一个支持无限排队的无界队列，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</li>
<li>基于数组实现的有界队列，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源，发挥最大性能。</li>
</ul></li>
</ol>
<p>实际上，对于大部分资源有限的场景，当没有空闲资源时，基本都可以通过“队列”这种数据结构来实现请求排队。</p>
<h2 id="课后思考">课后思考</h2>
<ol type="1">
<li><p>还有哪些类似的池结构或者场景中会用到队列的排队请求？</p>
<p><code>redis</code>连接池；<code>kafka</code>、<code>RabbitMQ</code>等消息队列</p></li>
<li><p>如何实现无锁并发队列？</p>
<p>可以使用<code>CAS</code>+数组的方式来实现</p></li>
</ol>
<p>参考链接：</p>
<ol type="1">
<li><a href="https://www.jianshu.com/p/bae9e0b0a91c">Python实现循环队列（基于list）</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>队列</tag>
      </tags>
  </entry>
</search>
